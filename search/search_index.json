{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programming With Python Banyan The Python Banyan Framework is a lightweight, reactive framework used to create flexible, non-blocking, event-driven, asynchronous applications. It was designed primarily to aid in implementing real-time physical computing applications for devices such as the Raspberry Pi, ESP8266, and Arduino. Still, it may easily be applied to projects outside of the physical programming domain. Guide Contents How To Use Python Banyan using a learn-by-example approach. How To Create Portable Physical Computing Projects Using The OneGPIO API Specification . Last Updated: 12 September, 2020 python-banyan version: v3.9 Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Welcome"},{"location":"#guide-contents","text":"How To Use Python Banyan using a learn-by-example approach. How To Create Portable Physical Computing Projects Using The OneGPIO API Specification . Last Updated: 12 September, 2020 python-banyan version: v3.9 Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Guide Contents"},{"location":"about/","text":"Contact Information If you have any questions or comments, please send email to: MisterYsLab@gmail.com License GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software. A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public. The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version. An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU Affero General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Remote Network Interaction; Use with the GNU General Public License. Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS","title":"About"},{"location":"about/#contact-information","text":"If you have any questions or comments, please send email to: MisterYsLab@gmail.com","title":"Contact Information"},{"location":"about/#license","text":"GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software. A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public. The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version. An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU Affero General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Remote Network Interaction; Use with the GNU General Public License. Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS","title":"License"},{"location":"additional_gateways/","text":"MQTT Gateway If you need to interconnect with MQTT, a Banyan MQTT Gateway has been provided. This gateway has been documented here. WebSocket Gateway The OneGPIO Demo Examples include Web pages to control an Arduino, ESP-8266, and Raspberry Pi. The WebPages publish commands via a WebSocket connection. This gateway translates the WebSocket command messages to OneGPIO command messages. It also translates OneGPIO reporter messages to WebSocket reporter messages to allow reports to be displayed on the Web page. The WebSocket IP address that this component uses is localhost since it is intended to be used in conjunction with a Web Browser running on the same computer as the Gateway. The WebSocket IP port is fixed to a value of 9000. If you need to, you can modify the supplied code to allow the user to modify these values on the command line. IMPORTANT NOTE The WebSocket Gateway utilizes a Python asyncio WebSocket library. It requires that Python 3.7 or higher be used. A Quick Overview Of The WsGateway Component The Banyan WebSocket Gateway is an executable Banyan component. It follows the command line patterns exposed in the Banyan User's Guide: usage: ws_gateway.py [-h] [-b BACK_PLANE_IP_ADDRESS] [-m SUBSCRIPTION_LIST [SUBSCRIPTION_LIST ...]] [-n PROCESS_NAME] [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] optional arguments: -h, --help show this help message and exit -b BACK_PLANE_IP_ADDRESS None or IP address used by Back Plane -m SUBSCRIPTION_LIST [SUBSCRIPTION_LIST ...] A space delimited list of topics -n PROCESS_NAME Set process name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port A Quick Look At The WsGateway Internals Once again, a block of code will be presented, followed by a discussion. 24 import argparse 25 import asyncio 26 import datetime 27 import json 28 import signal 29 import sys 30 31 import websockets 32 33 from python_banyan.banyan_base_aio import BanyanBaseAIO 34 35 36 class WsGateway(BanyanBaseAIO): 37 \"\"\" 38 This class is a gateway between a websocket client and the 39 Banyan network. 40 41 NOTE: This class requires Python 3.7 or above. 42 43 It implements a websocket server. A websocket client, upon 44 connection, must send an id message e.g.: {\"id\": \"to_arduino\"}. 45 46 The id will be used as the topic to publish data to the banyan 47 network. 48 \"\"\" 49 50 def __init__(self, *subscription_list, back_plane_ip_address=None, 51 subscriber_port='43125', 52 publisher_port='43124', process_name='WebSocketGateway', 53 event_loop=None): 54 \"\"\" 55 These are all the normal base class parameters 56 :param subscription_list: 57 :param back_plane_ip_address: 58 :param subscriber_port: 59 :param publisher_port: 60 :param process_name: 61 :param event_loop: 62 \"\"\" 63 64 # initialize the base class 65 super(WsGateway, self).__init__(subscriber_list=subscription_list, 66 back_plane_ip_address=back_plane_ip_address, 67 subscriber_port=subscriber_port, 68 publisher_port=publisher_port, 69 process_name=process_name, 70 event_loop=event_loop) 71 # save the event loop 72 self.event_loop = event_loop 73 74 # array of active sockets 75 self.active_sockets = [] 76 77 try: 78 # start the websocket server and call the main task, wsg 79 self.start_server = websockets.serve(self.wsg, '127.0.0.1', 9000) 80 self.event_loop.run_until_complete(self.start_server) 81 self.event_loop.run_forever() 82 except (websockets.exceptions.ConnectionClosed, 83 RuntimeError, 84 KeyboardInterrupt): 85 sys.exit() In this section of code, the necessary packages are imported and we define the WsGateway class, which is derived from BanyanBaseAIO. Being an asyncio based class, one of the parameters that may be passed to this class is an asyncio event loop. Usually, the default event loop is used, but you can supply your own event loop if you need to. This component implements a WebSocket server that permits connections to multiple WebSocket clients. An empty array, self.active_sockets is created on line 75 to store a record for each connected socket. Lines 79-85 start the WebSocket server. When a client connects to the WebSocket server, the wsg method is called on line 79. For information about the WebSocket server, please go to this link . 87 async def wsg(self, websocket, path): 88 \"\"\" 89 This method handles connections and will be used to send 90 messages to the client 91 :param websocket: websocket for connected client 92 :param path: required, but unused 93 :return: 94 \"\"\" 95 # start up banyan 96 await self.begin() 97 98 # wait for a connection 99 data = await websocket.recv() 100 101 # expecting an id string from client 102 data = json.loads(data) 103 104 # if id field not present then raise an exception 105 try: 106 id_string = data['id'] 107 except KeyError: 108 print('Client did not provide an ID string') 109 raise 110 111 # create a subscriber string from the id 112 subscriber_string = id_string.replace('to', 'from') 113 114 # subscribe to that topic 115 await self.set_subscriber_topic(subscriber_string) 116 117 # add an entry into the active_sockets table 118 entry = {websocket: 'to_banyan_topic', subscriber_string: websocket} 119 self.active_sockets.append(entry) 120 121 # create a task to receive messages from the client 122 await asyncio.create_task(self.receive_data(websocket, data['id'])) The wsg method is called when a WebSocket client connects to the WebSocket Gateway. Line 96 establishes the zeromq subscriber and publisher sockets for this component as well as providing a connection to the Banyan Backplane. Line 99 waits to receive initial identification data from a WebSocket client. This data is used to create a subscription topic for the WebSocket Gateway. Using the Arduino Demo Station Page as an example, the ID string sent as a WebSocket message from the Web page is \"to_arduino_gateway.\" This ID string is used to create subscription topic strings that the WebSocket Gateway uses for its operation. This is accomplished on lines 112-115. An entry for the socket connection is created and added to the active_websockets array. The entry is used to dispatch messages to the correct WebSocket during data transfer. This is accomplished on lines 118-119. Line 122 creates an asyncio task to continuously receive WebSocket messages from any connected WebSocket client. This task passes these messages to the receive_data method for further processing. 124 async def receive_data(self, websocket, publisher_topic): 125 \"\"\" 126 This method processes a received WebSocket command message 127 and translates it to a Banyan command message. 128 :param websocket: The currently active websocket 129 :param publisher_topic: The publishing topic 130 \"\"\" 131 while True: 132 try: 133 data = await websocket.recv() 134 data = json.loads(data) 135 except (websockets.exceptions.ConnectionClosed, TypeError): 136 # remove the entry from active_sockets 137 # using a list comprehension 138 self.active_sockets = [entry for entry in self.active_sockets if websocket not in entry] 139 break 140 141 await self.publish_payload(data, publisher_topic) The receive_data method processes WebSocket messages sent from the WebSocket client. The message is in the form of a JSON message and it is decoded on line 134. The message is then published as a Banyan OneGPIO message on line 141. 143 async def incoming_message_processing(self, topic, payload): 144 \"\"\" 145 This method converts the incoming messages to ws messages 146 and sends them to the ws client 147 148 :param topic: Message Topic string. 149 150 :param payload: Message Data. 151 \"\"\" 152 if 'timestamp' in payload: 153 timestamp = datetime.datetime.fromtimestamp(payload['timestamp']).strftime('%Y-%m-%d %H:%M:%S') 154 payload['timestamp'] = timestamp 155 156 ws_data = json.dumps(payload) 157 158 # find the websocket of interest by looking for the topic in 159 # active_sockets 160 for socket in self.active_sockets: 161 if topic in socket.keys(): 162 pub_socket = socket[topic] 163 await pub_socket.send(ws_data) 164 # print(ws_data) The incoming_message_processing method is the standard Banyan message processing method, overwritten to process OneGPIO messages received from the target hardware in the form of a report message. Using the topic of the message as a key, it looks up the associated WebSocket in the active_sockets array and publishes the message to the correct WebSocket. On lines 152-154, if the gateway provided a timestamp, the timestamp is formatted and appended to the report message. Line 156 encodes the message as a JSON message and sends the message to the WebSocket client on line 163. 167 def ws_gateway(): 168 # allow user to bypass the IP address auto-discovery. This is necessary if the component resides on a computer 169 # other than the computing running the backplane. 170 171 parser = argparse.ArgumentParser() 172 parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 173 help=\"None or IP address used by Back Plane\") 174 # allow the user to specify a name for the component and have it shown on the console banner. 175 # modify the default process name to one you wish to see on the banner. 176 # change the default in the derived class to set the name 177 parser.add_argument(\"-m\", dest=\"subscription_list\", default=\"from_arduino_gateway, \" 178 \"from_ESP8266_gateway, \" 179 \"from_rpi_gateway, \" 180 \"from_microbit_gateway\", nargs='+', 181 help=\"A space-delimited list of topics\") 182 parser.add_argument(\"-n\", dest=\"process_name\", default=\"WebSocket Gateway\", 183 help=\"Set process name in banner\") 184 parser.add_argument(\"-p\", dest=\"publisher_port\", default='43124', 185 help=\"Publisher IP port\") 186 parser.add_argument(\"-s\", dest=\"subscriber_port\", default='43125', 187 help=\"Subscriber IP port\") 188 189 args = parser.parse_args() 190 191 subscription_list = args.subscription_list.split(',') 192 193 kw_options = { 194 'publisher_port': args.publisher_port, 195 'subscriber_port': args.subscriber_port, 196 'process_name': args.process_name, 197 } 198 199 if args.back_plane_ip_address != 'None': 200 kw_options['back_plane_ip_address'] = args.back_plane_ip_address 201 202 # get the event loop 203 loop = asyncio.get_event_loop() 204 205 WsGateway(*subscription_list, **kw_options, event_loop=loop) 206 207 208 def signal_handler(sig, frame): 209 print('Exiting Through Signal Handler') 210 raise KeyboardInterrupt 211 212 213 # listen for SIGINT 214 signal.signal(signal.SIGINT, signal_handler) 215 signal.signal(signal.SIGTERM, signal_handler) 216 217 if __name__ == '__main__': 218 ws_gateway() Lines 167-219 implement the standard way of instantiating a Banyan component. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Additional Banyan Gateways"},{"location":"additional_gateways/#mqtt-gateway","text":"If you need to interconnect with MQTT, a Banyan MQTT Gateway has been provided. This gateway has been documented here.","title":"MQTT Gateway"},{"location":"additional_gateways/#websocket-gateway","text":"The OneGPIO Demo Examples include Web pages to control an Arduino, ESP-8266, and Raspberry Pi. The WebPages publish commands via a WebSocket connection. This gateway translates the WebSocket command messages to OneGPIO command messages. It also translates OneGPIO reporter messages to WebSocket reporter messages to allow reports to be displayed on the Web page. The WebSocket IP address that this component uses is localhost since it is intended to be used in conjunction with a Web Browser running on the same computer as the Gateway. The WebSocket IP port is fixed to a value of 9000. If you need to, you can modify the supplied code to allow the user to modify these values on the command line. IMPORTANT NOTE The WebSocket Gateway utilizes a Python asyncio WebSocket library. It requires that Python 3.7 or higher be used.","title":"WebSocket Gateway"},{"location":"additional_gateways/#a-quick-overview-of-the-wsgateway-component","text":"The Banyan WebSocket Gateway is an executable Banyan component. It follows the command line patterns exposed in the Banyan User's Guide: usage: ws_gateway.py [-h] [-b BACK_PLANE_IP_ADDRESS] [-m SUBSCRIPTION_LIST [SUBSCRIPTION_LIST ...]] [-n PROCESS_NAME] [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] optional arguments: -h, --help show this help message and exit -b BACK_PLANE_IP_ADDRESS None or IP address used by Back Plane -m SUBSCRIPTION_LIST [SUBSCRIPTION_LIST ...] A space delimited list of topics -n PROCESS_NAME Set process name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port","title":"A Quick Overview Of The WsGateway Component"},{"location":"additional_gateways/#a-quick-look-at-the-wsgateway-internals","text":"Once again, a block of code will be presented, followed by a discussion. 24 import argparse 25 import asyncio 26 import datetime 27 import json 28 import signal 29 import sys 30 31 import websockets 32 33 from python_banyan.banyan_base_aio import BanyanBaseAIO 34 35 36 class WsGateway(BanyanBaseAIO): 37 \"\"\" 38 This class is a gateway between a websocket client and the 39 Banyan network. 40 41 NOTE: This class requires Python 3.7 or above. 42 43 It implements a websocket server. A websocket client, upon 44 connection, must send an id message e.g.: {\"id\": \"to_arduino\"}. 45 46 The id will be used as the topic to publish data to the banyan 47 network. 48 \"\"\" 49 50 def __init__(self, *subscription_list, back_plane_ip_address=None, 51 subscriber_port='43125', 52 publisher_port='43124', process_name='WebSocketGateway', 53 event_loop=None): 54 \"\"\" 55 These are all the normal base class parameters 56 :param subscription_list: 57 :param back_plane_ip_address: 58 :param subscriber_port: 59 :param publisher_port: 60 :param process_name: 61 :param event_loop: 62 \"\"\" 63 64 # initialize the base class 65 super(WsGateway, self).__init__(subscriber_list=subscription_list, 66 back_plane_ip_address=back_plane_ip_address, 67 subscriber_port=subscriber_port, 68 publisher_port=publisher_port, 69 process_name=process_name, 70 event_loop=event_loop) 71 # save the event loop 72 self.event_loop = event_loop 73 74 # array of active sockets 75 self.active_sockets = [] 76 77 try: 78 # start the websocket server and call the main task, wsg 79 self.start_server = websockets.serve(self.wsg, '127.0.0.1', 9000) 80 self.event_loop.run_until_complete(self.start_server) 81 self.event_loop.run_forever() 82 except (websockets.exceptions.ConnectionClosed, 83 RuntimeError, 84 KeyboardInterrupt): 85 sys.exit() In this section of code, the necessary packages are imported and we define the WsGateway class, which is derived from BanyanBaseAIO. Being an asyncio based class, one of the parameters that may be passed to this class is an asyncio event loop. Usually, the default event loop is used, but you can supply your own event loop if you need to. This component implements a WebSocket server that permits connections to multiple WebSocket clients. An empty array, self.active_sockets is created on line 75 to store a record for each connected socket. Lines 79-85 start the WebSocket server. When a client connects to the WebSocket server, the wsg method is called on line 79. For information about the WebSocket server, please go to this link . 87 async def wsg(self, websocket, path): 88 \"\"\" 89 This method handles connections and will be used to send 90 messages to the client 91 :param websocket: websocket for connected client 92 :param path: required, but unused 93 :return: 94 \"\"\" 95 # start up banyan 96 await self.begin() 97 98 # wait for a connection 99 data = await websocket.recv() 100 101 # expecting an id string from client 102 data = json.loads(data) 103 104 # if id field not present then raise an exception 105 try: 106 id_string = data['id'] 107 except KeyError: 108 print('Client did not provide an ID string') 109 raise 110 111 # create a subscriber string from the id 112 subscriber_string = id_string.replace('to', 'from') 113 114 # subscribe to that topic 115 await self.set_subscriber_topic(subscriber_string) 116 117 # add an entry into the active_sockets table 118 entry = {websocket: 'to_banyan_topic', subscriber_string: websocket} 119 self.active_sockets.append(entry) 120 121 # create a task to receive messages from the client 122 await asyncio.create_task(self.receive_data(websocket, data['id'])) The wsg method is called when a WebSocket client connects to the WebSocket Gateway. Line 96 establishes the zeromq subscriber and publisher sockets for this component as well as providing a connection to the Banyan Backplane. Line 99 waits to receive initial identification data from a WebSocket client. This data is used to create a subscription topic for the WebSocket Gateway. Using the Arduino Demo Station Page as an example, the ID string sent as a WebSocket message from the Web page is \"to_arduino_gateway.\" This ID string is used to create subscription topic strings that the WebSocket Gateway uses for its operation. This is accomplished on lines 112-115. An entry for the socket connection is created and added to the active_websockets array. The entry is used to dispatch messages to the correct WebSocket during data transfer. This is accomplished on lines 118-119. Line 122 creates an asyncio task to continuously receive WebSocket messages from any connected WebSocket client. This task passes these messages to the receive_data method for further processing. 124 async def receive_data(self, websocket, publisher_topic): 125 \"\"\" 126 This method processes a received WebSocket command message 127 and translates it to a Banyan command message. 128 :param websocket: The currently active websocket 129 :param publisher_topic: The publishing topic 130 \"\"\" 131 while True: 132 try: 133 data = await websocket.recv() 134 data = json.loads(data) 135 except (websockets.exceptions.ConnectionClosed, TypeError): 136 # remove the entry from active_sockets 137 # using a list comprehension 138 self.active_sockets = [entry for entry in self.active_sockets if websocket not in entry] 139 break 140 141 await self.publish_payload(data, publisher_topic) The receive_data method processes WebSocket messages sent from the WebSocket client. The message is in the form of a JSON message and it is decoded on line 134. The message is then published as a Banyan OneGPIO message on line 141. 143 async def incoming_message_processing(self, topic, payload): 144 \"\"\" 145 This method converts the incoming messages to ws messages 146 and sends them to the ws client 147 148 :param topic: Message Topic string. 149 150 :param payload: Message Data. 151 \"\"\" 152 if 'timestamp' in payload: 153 timestamp = datetime.datetime.fromtimestamp(payload['timestamp']).strftime('%Y-%m-%d %H:%M:%S') 154 payload['timestamp'] = timestamp 155 156 ws_data = json.dumps(payload) 157 158 # find the websocket of interest by looking for the topic in 159 # active_sockets 160 for socket in self.active_sockets: 161 if topic in socket.keys(): 162 pub_socket = socket[topic] 163 await pub_socket.send(ws_data) 164 # print(ws_data) The incoming_message_processing method is the standard Banyan message processing method, overwritten to process OneGPIO messages received from the target hardware in the form of a report message. Using the topic of the message as a key, it looks up the associated WebSocket in the active_sockets array and publishes the message to the correct WebSocket. On lines 152-154, if the gateway provided a timestamp, the timestamp is formatted and appended to the report message. Line 156 encodes the message as a JSON message and sends the message to the WebSocket client on line 163. 167 def ws_gateway(): 168 # allow user to bypass the IP address auto-discovery. This is necessary if the component resides on a computer 169 # other than the computing running the backplane. 170 171 parser = argparse.ArgumentParser() 172 parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 173 help=\"None or IP address used by Back Plane\") 174 # allow the user to specify a name for the component and have it shown on the console banner. 175 # modify the default process name to one you wish to see on the banner. 176 # change the default in the derived class to set the name 177 parser.add_argument(\"-m\", dest=\"subscription_list\", default=\"from_arduino_gateway, \" 178 \"from_ESP8266_gateway, \" 179 \"from_rpi_gateway, \" 180 \"from_microbit_gateway\", nargs='+', 181 help=\"A space-delimited list of topics\") 182 parser.add_argument(\"-n\", dest=\"process_name\", default=\"WebSocket Gateway\", 183 help=\"Set process name in banner\") 184 parser.add_argument(\"-p\", dest=\"publisher_port\", default='43124', 185 help=\"Publisher IP port\") 186 parser.add_argument(\"-s\", dest=\"subscriber_port\", default='43125', 187 help=\"Subscriber IP port\") 188 189 args = parser.parse_args() 190 191 subscription_list = args.subscription_list.split(',') 192 193 kw_options = { 194 'publisher_port': args.publisher_port, 195 'subscriber_port': args.subscriber_port, 196 'process_name': args.process_name, 197 } 198 199 if args.back_plane_ip_address != 'None': 200 kw_options['back_plane_ip_address'] = args.back_plane_ip_address 201 202 # get the event loop 203 loop = asyncio.get_event_loop() 204 205 WsGateway(*subscription_list, **kw_options, event_loop=loop) 206 207 208 def signal_handler(sig, frame): 209 print('Exiting Through Signal Handler') 210 raise KeyboardInterrupt 211 212 213 # listen for SIGINT 214 signal.signal(signal.SIGINT, signal_handler) 215 signal.signal(signal.SIGTERM, signal_handler) 216 217 if __name__ == '__main__': 218 ws_gateway() Lines 167-219 implement the standard way of instantiating a Banyan component. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"A Quick Look At The WsGateway Internals"},{"location":"api/","text":"You may view the API for all of the base classes by clicking on this link.","title":"Base Class API Reference"},{"location":"banyan_gateways/","text":"A OneGPIO Gateway is a specialized Banyan component that is target-hardware specific. It subscribes to and translates OneGPIO command messages to and from native target hardware GPIO API calls. OneGPIO Gateways for the Arduino , ESP-8266, and Raspberry Pi are included with this distribution. A base class, called GatewayBase, is made available to simplify creating a OneGPIO Gateway. This class encapsulates both BanyanBase functionality as well as OneGPIO Gateway functionality. When implementing a OneGPIO Gateway, you may choose any target GPIO API. For example, in creating the Raspberry Pi Gateway, the pigpio library was chosen. If you prefer to use some other API, there are no restrictions to do so. There is also a Python asyncio version of the base class, called GatewayBaseAIO . This additional base class was necessary to support the pymata-express asyncio GPIO library for the Arduino. It is very similar to the GatewayBase class, and so it will not be discussed here. Understanding The GatewayBase Class Let's look at the code. Below are code sections that are followed by a discussion. 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class GatewayBase(BanyanBase): 27 \"\"\" 28 This class provides a common front end abstraction for all asyncio hardware gateways. 29 \"\"\" 30 31 # pin modes 32 DIGITAL_INPUT_MODE = 0 33 DIGITAL_OUTPUT_MODE = 1 34 PWM_OUTPUT_MODE = 2 35 ANALOG_INPUT_MODE = 3 36 ANALOG_OUTPUT_MODE = 4 37 DIGITAL_INPUT_PULLUP_MODE = 5 38 I2C_MODE = 6 39 TONE_MODE = 7 40 SERVO_MODE = 8 41 STEPPER_MODE = 9 42 SONAR_MODE = 10 43 WILD_CARD_MODE = 11 44 45 # board types 46 ARDUINO = 0 47 RPi = 1 48 ESP8266 = 2 Since GatewayBase is derived by the BanyanBase class, we import BanyanBase on line 23. Lines 31-43 define a set of pin mode \"constants\" as class variables. Lines 46-48 define some common board type identifiers. 51 def __init__(self, back_plane_ip_address=None, subscriber_port='43125', 52 publisher_port='43124', process_name='', 53 subscriber_list=None, board_type=None, ): 54 \"\"\" 55 56 :param back_plane_ip_address: banyan_base back_planeIP Address - 57 if not specified, it will be set to the local computer 58 :param subscriber_port: banyan_base back plane subscriber port. 59 This must match that of the banyan_base backplane 60 :param publisher_port: banyan_base back plane publisher port. 61 This must match that of the banyan_base 62 backplane 63 :param process_name: Component identifier 64 :param subscriber_list: a tuple or list of topics to be subscribed to 65 :param board_type: micro-controller type ID 66 67 \"\"\" The __init__ method accepts the standard BanyanBase input parameters, as well as 2 additional parameters. The subscriber_list parameter allows the user to supply a list of subscription topics for the gateway, and board_type is an optional parameter that will allow the user to supply a board type id. 68 if board_type: 69 self.board_type = board_type 70 71 if subscriber_list: 72 self.subscriber_list = subscriber_list 73 else: 74 self.subscriber_list = ('all') 75 76 # dictionaries for pin modes set by user 77 # an entry is board type specific 78 79 # this dictionary initially contains an entry for each default 80 # digital input pin 81 82 self.pins_dictionary = {} 83 84 # a pin can optionally be given a tag, it is used as a key to find 85 # pin number 86 # tag(string): pin(integer) 87 self.tags_dictionary = {} 88 89 self.init_pins_dictionary() 90 In this section, we save the input parameters and establish some data structures. On line 74, if a subscriber_list was not provided, a default subscription topic of all is used as the lone entry into the subscriber_list. Of course, subscription topics may be added at any time during run-time. Line 82 creates an empty pins_dictionary . This dictionary is used by each hardware-specific gateway to store pin information, such as the pin's mode and current state. Line 87 creates an empty tags_dictionary . When setting a pin mode, if a tag is provided, an entry is made into this dictionary. The tag is used as a key, and the pin number is the entry's value. Line 89 calls the init_pins_dictionary method. See the discussion below for line 126 for more information about this method. 91 # initialize the parent 92 super(GatewayBase, self).__init__(back_plane_ip_address=back_plane_ip_address, 93 subscriber_port=subscriber_port, 94 publisher_port=publisher_port, 95 process_name=process_name, 96 ) Line 91 initializes the BanyanBase class 98 self.command_dictionary = {'analog_write': self.analog_write, 99 'digital_write': self.digital_write, 100 'disable_analog_reporting': self.disable_analog_reporting, 101 'disable_digital_reporting': self.disable_digital_reporting, 102 'enable_analog_reporting': self.disable_analog_reporting, 103 'enable_digital_reporting': self.disable_digital_reporting, 104 'i2c_read': self.i2c_read, 105 'i2c_write': self.i2c_write, 106 'play_tone': self.play_tone, 107 'pwm_write': self.pwm_write, 108 'servo_position': self.servo_position, 109 'set_mode_analog_input': self.set_mode_analog_input, 110 'set_mode_digital_input': self.set_mode_digital_input, 111 'set_mode_digital_input_pullup': self.set_mode_digital_input_pullup, 112 'set_mode_digital_output': self.set_mode_digital_output, 113 'set_mode_i2c': self.set_mode_i2c, 114 'set_mode_pwm': self.set_mode_pwm, 115 'set_mode_servo': self.set_mode_servo, 116 'set_mode_sonar': self.set_mode_sonar, 117 'set_mode_stepper': self.set_mode_stepper, 118 'set_mode_tone': self.set_mode_tone, 119 'stepper_write': self.stepper_write, 120 } Lines 98-120 create a command_dictionary . Every OneGPIO Gateway contains a command_dictionary . The command_dictionary maps OneGPIO commands to methods that ultimately process the command. A OneGPIO command string is used as a key, and the value for each key is a method reference that will be called on line 161 below. 121 122 if subscriber_list is not None: 123 for topic in subscriber_list: 124 self.set_subscriber_topic(topic) The __init__ method concludes by subscribing to all the topics within the subscriber_list. 126 def init_pins_dictionary(self): 127 \"\"\" 128 This method will initialize the pins dictionary 129 This is handled within the class for each hardware type 130 \"\"\" 131 raise NotImplementedError This method must be overwritten by each hardware-specific OneGPiO Gateway, even if not needed. This is to ensure that you have not forgotten to implement this method. 133 def incoming_message_processing(self, topic, payload): 134 \"\"\" 135 Messages are sent here from the receive_loop 136 :param topic: Message Topic string 137 :param payload: Message Data 138 :return: 139 \"\"\" 140 # process payload command 141 try: 142 command = payload['command'] 143 except KeyError: 144 print(payload) 145 raise 146 147 # if a tag is provided and the tag is in the dictionary, fetch 148 # the associated pin number 149 if 'tag' in payload: 150 tag = payload['tag'] 151 if tag: 152 if tag in self.tags_dictionary: 153 pin = self.tags_dictionary[tag] 154 # the pin is optional if using tag, so add it to the payload 155 payload['pin'] = pin 156 else: 157 self.tags_dictionary[payload['tag']] = payload['pin'] 158 159 # if command is in the command dictionary, execute the command 160 if command in self.command_dictionary.keys(): 161 self.command_dictionary[command](topic, payload) 162 163 # for unknown requests, pass them along to the hardware gateway to handle 164 else: 165 self.additional_banyan_messages(topic, payload) 166 Lines 133-168 implement the Banyan incoming_message_processing method. Received OneGPIO commands are processed by this method. Line 141-145 retrieves the command key string of the OneGPIO incoming message. Line 149 checks to see if an optional tag key is in the message. If it is, lines 149-158 process the tag. If the tag is not in the tags_dictionary , the tag and its associated pin number are added to the dictionary. Lines 160-165 check to see if the value of the command key is within the command_dictionary. If it is, the command method is called. If it is not found, the additional_banyan_messages method is called. This allows you to add hardware-specific commands not found in the command dictionary easily. 179 def analog_write(self, topic, payload): 180 \"\"\" 181 This method will pass any messages not handled by this class to the 182 specific gateway class. Must be overwritten by the hardware gateway class. 183 :param topic: message topic 184 :param payload: message payload 185 \"\"\" 186 raise NotImplementedError The remainder of the class is the set of command methods that need to be overwritten in the derived class. Lines 179-186 are an illustration of the analog_write method. All the other command methods follow a similar pattern (lines 170-378). Some Specific Command Examples To illustrate the flexibility of using the OneGPIO specification, let's look at some sample OneGPIO command implementations. Both examples presented below are from the Raspberry Pi Gateway. Adding A Custom Spin To The Command When implementing a OneGPIO command, you can go beyond a simple one to one mapping between the OneGPIO command and the underlying GPIO API. Let's look at set_mode_digital_input for the Raspberry Pi. The Raspberry Pi Gateway uses the pigpio GPIO library. Of course, you can use any GPIO library you wish to choose. def set_mode_digital_input(self, topic, payload): \"\"\" This method sets a pin as digital input. :param topic: message topic :param payload: {\"command\": \"set_mode_digital_input\", \"pin\": \u201cPIN\u201d, \"tag\":\u201dTAG\u201d } \"\"\" pin = payload['pin'] entry = self.pins_dictionary[pin] entry['mode'] = self.DIGITAL_INPUT_MODE self.pi.set_glitch_filter(pin, 20000) self.pi.set_mode(pin, pigpio.INPUT) self.pi.set_pull_up_down(pin, pigpio.PUD_DOWN) self.pi.callback(pin, pigpio.EITHER_EDGE, self.input_callback) The pin number is extracted from the OneGPIO payload. The pin mode is set within the pins_dictionary for the pin. Next, it performs 4 pigpio functions. A glitch filter to debounce the pin. The pin mode is set to input . The internal pull-up/pull-down resistor for the pin is set to pull-down . A callback method is set. This method is called whenever there is a state change for the pin. The OneGPIO Application Component has no knowledge of all of this underlying logic. It merely sends the command to set the pin mode to digital input, and the OneGPIO Gateway interprets the behavior for the specific target hardware. Adding Some More Spin The Raspberry Pi GPIO does not directly support analog input. But since you control the definition of a command, the gateway can implement anything you choose, including using an external device to perform analog input. Here we implement analog input for the Raspberry Pi by using a PFC8591 A/D converter. def set_mode_analog_input(self, topic, payload): \"\"\" This method programs a PCF8591 AD/DA for analog input. :param topic: message topic :param payload: {\"command\": \"set_mode_analog_input\", \"pin\": \u201cPIN\u201d, \"tag\":\u201dTAG\u201d } \"\"\" # pin is used as channel number value = None i2c_handle = self.pi.i2c_open(1, 72, 0) pin = payload['pin'] self.pi.i2c_write_byte_data(i2c_handle, 64 | (pin & 0x03), 0) time.sleep(0.1) for i in range(3): value = self.pi.i2c_read_byte(i2c_handle) self.pi.i2c_close(i2c_handle) # publish an analog input report payload = {'report': 'analog_input', 'pin': pin, 'value': value} self.publish_payload(payload, 'from_rpi_gateway') The A/D device is i2c based, and so this method implements the i2c communication. The method retrieves the current value for one of the 4 channels supported by the PCF8591 A/D converter. It then publishes that value using a OneGPIO report message. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"An Introduction To OneGPIO Gateways"},{"location":"banyan_gateways/#understanding-the-gatewaybase-class","text":"Let's look at the code. Below are code sections that are followed by a discussion. 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class GatewayBase(BanyanBase): 27 \"\"\" 28 This class provides a common front end abstraction for all asyncio hardware gateways. 29 \"\"\" 30 31 # pin modes 32 DIGITAL_INPUT_MODE = 0 33 DIGITAL_OUTPUT_MODE = 1 34 PWM_OUTPUT_MODE = 2 35 ANALOG_INPUT_MODE = 3 36 ANALOG_OUTPUT_MODE = 4 37 DIGITAL_INPUT_PULLUP_MODE = 5 38 I2C_MODE = 6 39 TONE_MODE = 7 40 SERVO_MODE = 8 41 STEPPER_MODE = 9 42 SONAR_MODE = 10 43 WILD_CARD_MODE = 11 44 45 # board types 46 ARDUINO = 0 47 RPi = 1 48 ESP8266 = 2 Since GatewayBase is derived by the BanyanBase class, we import BanyanBase on line 23. Lines 31-43 define a set of pin mode \"constants\" as class variables. Lines 46-48 define some common board type identifiers. 51 def __init__(self, back_plane_ip_address=None, subscriber_port='43125', 52 publisher_port='43124', process_name='', 53 subscriber_list=None, board_type=None, ): 54 \"\"\" 55 56 :param back_plane_ip_address: banyan_base back_planeIP Address - 57 if not specified, it will be set to the local computer 58 :param subscriber_port: banyan_base back plane subscriber port. 59 This must match that of the banyan_base backplane 60 :param publisher_port: banyan_base back plane publisher port. 61 This must match that of the banyan_base 62 backplane 63 :param process_name: Component identifier 64 :param subscriber_list: a tuple or list of topics to be subscribed to 65 :param board_type: micro-controller type ID 66 67 \"\"\" The __init__ method accepts the standard BanyanBase input parameters, as well as 2 additional parameters. The subscriber_list parameter allows the user to supply a list of subscription topics for the gateway, and board_type is an optional parameter that will allow the user to supply a board type id. 68 if board_type: 69 self.board_type = board_type 70 71 if subscriber_list: 72 self.subscriber_list = subscriber_list 73 else: 74 self.subscriber_list = ('all') 75 76 # dictionaries for pin modes set by user 77 # an entry is board type specific 78 79 # this dictionary initially contains an entry for each default 80 # digital input pin 81 82 self.pins_dictionary = {} 83 84 # a pin can optionally be given a tag, it is used as a key to find 85 # pin number 86 # tag(string): pin(integer) 87 self.tags_dictionary = {} 88 89 self.init_pins_dictionary() 90 In this section, we save the input parameters and establish some data structures. On line 74, if a subscriber_list was not provided, a default subscription topic of all is used as the lone entry into the subscriber_list. Of course, subscription topics may be added at any time during run-time. Line 82 creates an empty pins_dictionary . This dictionary is used by each hardware-specific gateway to store pin information, such as the pin's mode and current state. Line 87 creates an empty tags_dictionary . When setting a pin mode, if a tag is provided, an entry is made into this dictionary. The tag is used as a key, and the pin number is the entry's value. Line 89 calls the init_pins_dictionary method. See the discussion below for line 126 for more information about this method. 91 # initialize the parent 92 super(GatewayBase, self).__init__(back_plane_ip_address=back_plane_ip_address, 93 subscriber_port=subscriber_port, 94 publisher_port=publisher_port, 95 process_name=process_name, 96 ) Line 91 initializes the BanyanBase class 98 self.command_dictionary = {'analog_write': self.analog_write, 99 'digital_write': self.digital_write, 100 'disable_analog_reporting': self.disable_analog_reporting, 101 'disable_digital_reporting': self.disable_digital_reporting, 102 'enable_analog_reporting': self.disable_analog_reporting, 103 'enable_digital_reporting': self.disable_digital_reporting, 104 'i2c_read': self.i2c_read, 105 'i2c_write': self.i2c_write, 106 'play_tone': self.play_tone, 107 'pwm_write': self.pwm_write, 108 'servo_position': self.servo_position, 109 'set_mode_analog_input': self.set_mode_analog_input, 110 'set_mode_digital_input': self.set_mode_digital_input, 111 'set_mode_digital_input_pullup': self.set_mode_digital_input_pullup, 112 'set_mode_digital_output': self.set_mode_digital_output, 113 'set_mode_i2c': self.set_mode_i2c, 114 'set_mode_pwm': self.set_mode_pwm, 115 'set_mode_servo': self.set_mode_servo, 116 'set_mode_sonar': self.set_mode_sonar, 117 'set_mode_stepper': self.set_mode_stepper, 118 'set_mode_tone': self.set_mode_tone, 119 'stepper_write': self.stepper_write, 120 } Lines 98-120 create a command_dictionary . Every OneGPIO Gateway contains a command_dictionary . The command_dictionary maps OneGPIO commands to methods that ultimately process the command. A OneGPIO command string is used as a key, and the value for each key is a method reference that will be called on line 161 below. 121 122 if subscriber_list is not None: 123 for topic in subscriber_list: 124 self.set_subscriber_topic(topic) The __init__ method concludes by subscribing to all the topics within the subscriber_list. 126 def init_pins_dictionary(self): 127 \"\"\" 128 This method will initialize the pins dictionary 129 This is handled within the class for each hardware type 130 \"\"\" 131 raise NotImplementedError This method must be overwritten by each hardware-specific OneGPiO Gateway, even if not needed. This is to ensure that you have not forgotten to implement this method. 133 def incoming_message_processing(self, topic, payload): 134 \"\"\" 135 Messages are sent here from the receive_loop 136 :param topic: Message Topic string 137 :param payload: Message Data 138 :return: 139 \"\"\" 140 # process payload command 141 try: 142 command = payload['command'] 143 except KeyError: 144 print(payload) 145 raise 146 147 # if a tag is provided and the tag is in the dictionary, fetch 148 # the associated pin number 149 if 'tag' in payload: 150 tag = payload['tag'] 151 if tag: 152 if tag in self.tags_dictionary: 153 pin = self.tags_dictionary[tag] 154 # the pin is optional if using tag, so add it to the payload 155 payload['pin'] = pin 156 else: 157 self.tags_dictionary[payload['tag']] = payload['pin'] 158 159 # if command is in the command dictionary, execute the command 160 if command in self.command_dictionary.keys(): 161 self.command_dictionary[command](topic, payload) 162 163 # for unknown requests, pass them along to the hardware gateway to handle 164 else: 165 self.additional_banyan_messages(topic, payload) 166 Lines 133-168 implement the Banyan incoming_message_processing method. Received OneGPIO commands are processed by this method. Line 141-145 retrieves the command key string of the OneGPIO incoming message. Line 149 checks to see if an optional tag key is in the message. If it is, lines 149-158 process the tag. If the tag is not in the tags_dictionary , the tag and its associated pin number are added to the dictionary. Lines 160-165 check to see if the value of the command key is within the command_dictionary. If it is, the command method is called. If it is not found, the additional_banyan_messages method is called. This allows you to add hardware-specific commands not found in the command dictionary easily. 179 def analog_write(self, topic, payload): 180 \"\"\" 181 This method will pass any messages not handled by this class to the 182 specific gateway class. Must be overwritten by the hardware gateway class. 183 :param topic: message topic 184 :param payload: message payload 185 \"\"\" 186 raise NotImplementedError The remainder of the class is the set of command methods that need to be overwritten in the derived class. Lines 179-186 are an illustration of the analog_write method. All the other command methods follow a similar pattern (lines 170-378).","title":"Understanding The GatewayBase Class"},{"location":"banyan_gateways/#some-specific-command-examples","text":"To illustrate the flexibility of using the OneGPIO specification, let's look at some sample OneGPIO command implementations. Both examples presented below are from the Raspberry Pi Gateway.","title":"Some Specific Command Examples"},{"location":"banyan_gateways/#adding-a-custom-spin-to-the-command","text":"When implementing a OneGPIO command, you can go beyond a simple one to one mapping between the OneGPIO command and the underlying GPIO API. Let's look at set_mode_digital_input for the Raspberry Pi. The Raspberry Pi Gateway uses the pigpio GPIO library. Of course, you can use any GPIO library you wish to choose. def set_mode_digital_input(self, topic, payload): \"\"\" This method sets a pin as digital input. :param topic: message topic :param payload: {\"command\": \"set_mode_digital_input\", \"pin\": \u201cPIN\u201d, \"tag\":\u201dTAG\u201d } \"\"\" pin = payload['pin'] entry = self.pins_dictionary[pin] entry['mode'] = self.DIGITAL_INPUT_MODE self.pi.set_glitch_filter(pin, 20000) self.pi.set_mode(pin, pigpio.INPUT) self.pi.set_pull_up_down(pin, pigpio.PUD_DOWN) self.pi.callback(pin, pigpio.EITHER_EDGE, self.input_callback) The pin number is extracted from the OneGPIO payload. The pin mode is set within the pins_dictionary for the pin. Next, it performs 4 pigpio functions. A glitch filter to debounce the pin. The pin mode is set to input . The internal pull-up/pull-down resistor for the pin is set to pull-down . A callback method is set. This method is called whenever there is a state change for the pin. The OneGPIO Application Component has no knowledge of all of this underlying logic. It merely sends the command to set the pin mode to digital input, and the OneGPIO Gateway interprets the behavior for the specific target hardware.","title":"Adding A Custom Spin To The Command"},{"location":"banyan_gateways/#adding-some-more-spin","text":"The Raspberry Pi GPIO does not directly support analog input. But since you control the definition of a command, the gateway can implement anything you choose, including using an external device to perform analog input. Here we implement analog input for the Raspberry Pi by using a PFC8591 A/D converter. def set_mode_analog_input(self, topic, payload): \"\"\" This method programs a PCF8591 AD/DA for analog input. :param topic: message topic :param payload: {\"command\": \"set_mode_analog_input\", \"pin\": \u201cPIN\u201d, \"tag\":\u201dTAG\u201d } \"\"\" # pin is used as channel number value = None i2c_handle = self.pi.i2c_open(1, 72, 0) pin = payload['pin'] self.pi.i2c_write_byte_data(i2c_handle, 64 | (pin & 0x03), 0) time.sleep(0.1) for i in range(3): value = self.pi.i2c_read_byte(i2c_handle) self.pi.i2c_close(i2c_handle) # publish an analog input report payload = {'report': 'analog_input', 'pin': pin, 'value': value} self.publish_payload(payload, 'from_rpi_gateway') The A/D device is i2c based, and so this method implements the i2c communication. The method retrieves the current value for one of the 4 channels supported by the PCF8591 A/D converter. It then publishes that value using a OneGPIO report message. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Adding Some More Spin"},{"location":"benchmark/","text":"Benchmarking Banyan and MQTT MQTT is an excellent tool if used for what it is designed - that is, publishing messages across the greater Internet. But when traffic is limited to within a given LAN, MQTT is highly inefficient. We ran a simple benchmark comparing MQTT to Python Banyan. For each framework, the benchmark consists of a publisher that publishes 100000 messages and a subscriber that receives those messages. The total transfer time is calculated for each, and total latency between the publisher and subscriber is explored. To view the benchmark code, click on these links: MQTT subscriber , MQTT publisher , Python Banyan subscriber , Python Banyan publisher . Testing Environment All tests were run on Ubuntu Linux 18.10 on a computer using an Intel Core i5-2500K CPU running at 3.30GHz. Python 3.7.2 compiled with the --enable_optimizations flag set was used for both tests. Mosquitto version 1.4.15 and paho version 1.3.1 was used for the MQTT tests. Using MQTT Here are the MQTT test results for the subscriber: $ python3 mqsub.py MQSUB Connected - Expecting 100000 Messages Task completed on: Wed Feb 13 17:27:25 2019 100000 Total messages received in 4.819453239440918 seconds. And here are the results for the MQTT publisher: $ python mqpub.py MQPUB Connected - Sending 100000 messages Task completed on: Wed Feb 13 17:27:24 2019 We can see that it took a little over 4.18 seconds to send and receive the 100000 messages. Using Python Banyan Here are the Banyan subscriber results: $ python3 banyan_sub.py ************************************************************ Banyan Subscriber using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Expecting 100000 messages. Task completed at: Wed Feb 13 17:38:42 2019 100000 Total messages received in 1.695580244064331 seconds. Here are the Banyan publisher results: $ python3 banyan_pub.py ************************************************************ Banyan publisher using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Publishing 100000 messages. Task completed at: Wed Feb 13 17:38:42 2019 Looking at the results, Python Banyan was almost 2.5 times faster than the MQTT. What is more interesting is the latency between the publishers' and subscribers' completions. Looking at the time stamps reported, MQTT had a latency of 1 second, while Banyan had a latency of 0 seconds. Running the Benchmarks On A Raspberry Pi The tests were also run on a Raspberry Pi 3 with Raspbian Stretch March 2018 release updated and upgraded on February 14, 2019. Python 3.6.4 was used for all tests. Mosquitto version 1.4.15 and paho version 1.3.1 were used for the MQTT tests. In this case, MQTT took a little over 36 seconds to complete, and Banyan a little over 17. Latency for MQTT was approximately 7 seconds, and for Banyan, approximately 1 second. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Comparing Banyan and MQTT"},{"location":"benchmark/#benchmarking-banyan-and-mqtt","text":"MQTT is an excellent tool if used for what it is designed - that is, publishing messages across the greater Internet. But when traffic is limited to within a given LAN, MQTT is highly inefficient. We ran a simple benchmark comparing MQTT to Python Banyan. For each framework, the benchmark consists of a publisher that publishes 100000 messages and a subscriber that receives those messages. The total transfer time is calculated for each, and total latency between the publisher and subscriber is explored. To view the benchmark code, click on these links: MQTT subscriber , MQTT publisher , Python Banyan subscriber , Python Banyan publisher .","title":"Benchmarking Banyan and MQTT"},{"location":"benchmark/#testing-environment","text":"All tests were run on Ubuntu Linux 18.10 on a computer using an Intel Core i5-2500K CPU running at 3.30GHz. Python 3.7.2 compiled with the --enable_optimizations flag set was used for both tests. Mosquitto version 1.4.15 and paho version 1.3.1 was used for the MQTT tests.","title":"Testing Environment"},{"location":"benchmark/#using-mqtt","text":"Here are the MQTT test results for the subscriber: $ python3 mqsub.py MQSUB Connected - Expecting 100000 Messages Task completed on: Wed Feb 13 17:27:25 2019 100000 Total messages received in 4.819453239440918 seconds. And here are the results for the MQTT publisher: $ python mqpub.py MQPUB Connected - Sending 100000 messages Task completed on: Wed Feb 13 17:27:24 2019 We can see that it took a little over 4.18 seconds to send and receive the 100000 messages.","title":"Using MQTT"},{"location":"benchmark/#using-python-banyan","text":"Here are the Banyan subscriber results: $ python3 banyan_sub.py ************************************************************ Banyan Subscriber using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Expecting 100000 messages. Task completed at: Wed Feb 13 17:38:42 2019 100000 Total messages received in 1.695580244064331 seconds. Here are the Banyan publisher results: $ python3 banyan_pub.py ************************************************************ Banyan publisher using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Publishing 100000 messages. Task completed at: Wed Feb 13 17:38:42 2019 Looking at the results, Python Banyan was almost 2.5 times faster than the MQTT. What is more interesting is the latency between the publishers' and subscribers' completions. Looking at the time stamps reported, MQTT had a latency of 1 second, while Banyan had a latency of 0 seconds.","title":"Using Python Banyan"},{"location":"benchmark/#running-the-benchmarks-on-a-raspberry-pi","text":"The tests were also run on a Raspberry Pi 3 with Raspbian Stretch March 2018 release updated and upgraded on February 14, 2019. Python 3.6.4 was used for all tests. Mosquitto version 1.4.15 and paho version 1.3.1 were used for the MQTT tests. In this case, MQTT took a little over 36 seconds to complete, and Banyan a little over 17. Latency for MQTT was approximately 7 seconds, and for Banyan, approximately 1 second. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Running the Benchmarks On A Raspberry Pi"},{"location":"common_messaging_protocol/","text":"Introduction To The OneGPIO Message API Unlike traditional GPIO libraries that use a hardware-specific method call API interface, OneGPIO uses a Banyan Messaging API interface. The OneGPIO Specification provides Banyan message templates for all OneGPIO commands and reports. The OneGPIO Specification is a hardware and computer language independent abstraction of GPIO operations. A OneGPIO Command Message is published by a OneGPIO Application Component to transmit GPIO command information to the target hardware. A OneGPIO Report Message is published by a OneGPIO Gateway after receiving report data from the target hardware. Because the Gateway is translating native report messages into OneGPIO messages, it has the freedom to add additional data to the report message, such as a timestamp. A command message contains the keyword command, and a report contains the keyword report In general, a GPIO pin must have its mode set before use. For example, to set a pin to digital output mode, you would use the following message template: GPIO Operation OneGPIO Message Set Pin To Digital Output Mode {\"command\": \"set_mode_digital_output\", \"pin\": PIN, \"tag\":\u201dTAG\u201d } When setting a pin mode, you have the option to name or tag the pin. This helps to improve code readability when interacting with that pin. You may reference the pin using either its tag or pin number interchangeably. However, if you wish to use a tag, the tag must be set when the pin mode is set. The pin tag to pin number mapping is automatically maintained within the OneGPIO Gateways. To illustrate, let's populate the 'set_mode_digital_output' command message to set pin 4 as a digital output pin and tag the pin with \"green_led.\" {'command': 'set_mode_digital_output', 'pin': 4, 'tag': 'green_led' } Notice that pin is an integer and not a string. All OneGPIO message keys are strings. Within the OneGPIO message specification, if a value is not within quotes, it is specified as an integer. Otherwise, it is specified as a string. The OneGpio command to set the state of a digital output pin is: GPIO Operation OneGPIO Message Set Digital Output Pin State {\"command\": \"digital_write\", \"pin\": PIN, \"tag\": \"TAG\", \"value\": VALUE} Now that the pin mode has been set with a tag, we can set the green LED to ON with the following message: {'command': 'digital_write', 'tag': 'green_led', 'value': 1 } We do not need to specify the pin number since we specified a tag when we set the pin mode. Also notice, that the value is an integer and not a string. If a pin tag is specified when setting the pin mode, you may use either the tag or pin number when referencing the pin in a command. To port a OneGPIO application to a different hardware platform, you need only change the pin number for the chosen hardware platform. This can easily be implemented using command line arguments when designing the component. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"The OneGPIO Messaging Protocol"},{"location":"common_messaging_protocol/#introduction-to-the-onegpio-message-api","text":"Unlike traditional GPIO libraries that use a hardware-specific method call API interface, OneGPIO uses a Banyan Messaging API interface. The OneGPIO Specification provides Banyan message templates for all OneGPIO commands and reports. The OneGPIO Specification is a hardware and computer language independent abstraction of GPIO operations. A OneGPIO Command Message is published by a OneGPIO Application Component to transmit GPIO command information to the target hardware. A OneGPIO Report Message is published by a OneGPIO Gateway after receiving report data from the target hardware. Because the Gateway is translating native report messages into OneGPIO messages, it has the freedom to add additional data to the report message, such as a timestamp. A command message contains the keyword command, and a report contains the keyword report In general, a GPIO pin must have its mode set before use. For example, to set a pin to digital output mode, you would use the following message template: GPIO Operation OneGPIO Message Set Pin To Digital Output Mode {\"command\": \"set_mode_digital_output\", \"pin\": PIN, \"tag\":\u201dTAG\u201d } When setting a pin mode, you have the option to name or tag the pin. This helps to improve code readability when interacting with that pin. You may reference the pin using either its tag or pin number interchangeably. However, if you wish to use a tag, the tag must be set when the pin mode is set. The pin tag to pin number mapping is automatically maintained within the OneGPIO Gateways. To illustrate, let's populate the 'set_mode_digital_output' command message to set pin 4 as a digital output pin and tag the pin with \"green_led.\" {'command': 'set_mode_digital_output', 'pin': 4, 'tag': 'green_led' } Notice that pin is an integer and not a string. All OneGPIO message keys are strings. Within the OneGPIO message specification, if a value is not within quotes, it is specified as an integer. Otherwise, it is specified as a string. The OneGpio command to set the state of a digital output pin is: GPIO Operation OneGPIO Message Set Digital Output Pin State {\"command\": \"digital_write\", \"pin\": PIN, \"tag\": \"TAG\", \"value\": VALUE} Now that the pin mode has been set with a tag, we can set the green LED to ON with the following message: {'command': 'digital_write', 'tag': 'green_led', 'value': 1 } We do not need to specify the pin number since we specified a tag when we set the pin mode. Also notice, that the value is an integer and not a string. If a pin tag is specified when setting the pin mode, you may use either the tag or pin number when referencing the pin in a command. To port a OneGPIO application to a different hardware platform, you need only change the pin number for the chosen hardware platform. This can easily be implemented using command line arguments when designing the component. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Introduction To The OneGPIO Message API"},{"location":"example1/","text":"An Echo Server-Client Example In this section, we will build a simple echo server-client application using the Python Banyan Framework. First, we will run the demo and then examine the code for both the server and client Banyan components. Running The Example The Backplane is installed as an executable module when Python Banyan is installed. By typing 'backplane' in a command or terminal window, the Backplane will start. The components, simple_echo_server.py, and simple_echo_client.py are invoked from the command line using the typical method to start a Python program. The following screenshots were taken on a Linux computer running Python 3, and that is why the python3 command is displayed. You may run these examples on Linux, Windows, Mac or, Raspberry using either Python 2 or Python 3. Simply substitute your system's specific python command to run the examples. First, start the Backplane in a terminal window. backplane Start the server in a second terminal window. Go to the directory that contains simple_echo_server.py and type: python3 simple_echo_server.py The base class prints an informational header to the console. Start the client in a third terminal window. Go to the directory that contains simple_echo_client.py and type: python3 simple_echo_client.py A standard Banyan header is printed to the client's console, and the client begins sending its messages. When the client completes sending all of its messages, the client's console will indicate the number of messages sent and received. The console for the server will display all of the message numbers it received Examining The Server Code The server's role is to simply wait for the \"echo\" topic messages to arrive and then to extract the message's payload and publish a \"reply\" topic message. Let's look at the code below: Lines 20 through 22 import the component's required modules. Line 22 illustrates the standard syntax used to import the BanyanBase base class. Line 25 declares the EchoServer component class. It inherits from the BanyanBase base class. 1 \"\"\" 2 simple_echo_server.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 22 from python_banyan.banyan_base import BanyanBase 23 24 25 class EchoServer(BanyanBase): 26 \"\"\" 27 This class is a simple Banyan echo server 28 29 \"\"\" Lines 31 through 44 define the __init__ method. When inheriting from another class, the parent class must be initialized. Line 34 initializes the parent and sets the parent's process_name parameter. The process_name is printed to the console when the component is first invoked. All other default values are accepted as is. Line 37 calls the BanyanBase method set_subscriber_topic to subscribe to 'echo' messages. Line 41 calls the BanyanBase method receive_loop to wait for incoming messages. Line 42 through 44 traps a Control-C entered by the user. The inherited BanyanBase clean_up method is called to close the ZeroMQ connections. The program is then exited. 31 def __init__(self, ): 32 33 # initialize the parent 34 super(EchoServer, self).__init__(process_name='EchoServer') 35 36 # subscribe to receive 'echo' messages from the client 37 self.set_subscriber_topic('echo') 38 39 # wait for messages to arrive 40 try: 41 self.receive_loop() 42 except KeyboardInterrupt: 43 self.clean_up() 44 sys.exit(0) Lines 46 through 55 overrides the base class incoming_message_process method. Whenever a message is received by the receive_loop , it calls incoming_message_processing to process the message. The incoming_message_processing method requires two parameters, a topic string and a payload. Both the topic and payload are decoded within the receive_loop, so they are ready for use by the incoming_message_processing method. Line 53 republishes the payload just received, setting the topic to 'reply,' The message number of the received message is then printed to the console. 46 def incoming_message_processing(self, topic, payload): 47 \"\"\" 48 Process incoming messages from the client 49 :param topic: message topic 50 :param payload: message payload 51 :return: 52 \"\"\" 53 self.publish_payload(payload, 'reply') 54 print('Message number:', payload['message_number']) 55 Lines 61 through 62 create a function to instantiate the EchoServer class. This function is added so that we can install our component as an executable file in our system if we desire to do so. Installing Components as executable modules is explained in a later section. Lines 57 through 62 use a standard Python construct to call the instantiation function. 57 def echo_server(): 58 EchoServer() 59 60 61 if __name__ == '__main__': 62 echo_server() Examining The Client Code The role of the client is to publish 'echo' messages. It maintains a message sequencing number, incorporated into the payload. Shortly after being invoked, the client sends out the first 'echo' message. It then waits for a 'reply' message from the server before publishing the next message. The messaging sequencing number is decremented after each message is published. When the sequencing number reaches zero, the final message is published, and the client halts. The code for the client is very similar to that of the server . In this section, the major differences between the client and server are highlighted. Line 38 calls the inherited BanyanBase method set_subscriber_topic to subscribe to 'reply' messages. Line 41 establishes instance variables to keep track of the current message sequencing number and the total messages sent. Both are initialized to a value of 10. Line 44 publishes an \"echo\" message with a payload containing the current message number. Line 48 calls the component's receive_loop, and the client waits for the next incoming 'reply' message. 1 \"\"\" 2 simple_echo_client.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 21 import sys 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class EchoClient(BanyanBase): 27 \"\"\" 28 This is a simple echo client derived from the BanyanBase class. It sends out a series of messages and expects an 29 echo reply from the server. 30 \"\"\" 31 32 def __init__(self): 33 34 # initialize the parent 35 super(EchoClient, self).__init__(process_name='EchoClient') 36 37 # accept banyan messages with the topic of reply 38 self.set_subscriber_topic('reply') 39 40 # sequence number of messages and total number of messages to send 41 self.message_number = self.number_of_messages = 10 42 43 # send the first message - make sure that the server is already started 44 self.publish_payload({'message_number': self.message_number}, 'echo') 45 46 # get the reply messages 47 try: 48 self.receive_loop() 49 except KeyboardInterrupt: 50 self.clean_up() 51 sys.exit(0) Line 53 is the incoming_message_processing method. Line 62 tests the sequencing value of the 'reply' message. When the sequencing value is set to 0, the final message was sent and received. Lines 63 through 66 print the total number of messages sent and received to the console, and the user is asked to press enter to exit the program. Lines 69 through 71 process non-terminating 'reply' messages. The message number is decremented by 1, and the next 'echo' message is then built and published. 53 def incoming_message_processing(self, topic, payload): 54 \"\"\" 55 Process incoming messages received from the echo client 56 :param topic: Message Topic string 57 :param payload: Message Data 58 :return: 59 \"\"\" 60 61 # When a message is received and its number is zero, finish up. 62 if payload['message_number'] == 0: 63 print(str(self.number_of_messages) + ' messages sent and received. ') 64 input('Press enter to exit.') 65 self.clean_up() 66 sys.exit(0) 67 # bump the message number and send the message out 68 else: 69 self.message_number -= 1 70 if self.message_number >= 0: 71 self.publish_payload({'message_number': self.message_number}, 'echo') 72 73 74 def echo_client(): 75 EchoClient() 76 77 78 if __name__ == '__main__': 79 echo_client() Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 1  - A Simple Echo Server/Client"},{"location":"example1/#an-echo-server-client-example","text":"In this section, we will build a simple echo server-client application using the Python Banyan Framework. First, we will run the demo and then examine the code for both the server and client Banyan components.","title":"An Echo Server-Client Example"},{"location":"example1/#running-the-example","text":"The Backplane is installed as an executable module when Python Banyan is installed. By typing 'backplane' in a command or terminal window, the Backplane will start. The components, simple_echo_server.py, and simple_echo_client.py are invoked from the command line using the typical method to start a Python program. The following screenshots were taken on a Linux computer running Python 3, and that is why the python3 command is displayed. You may run these examples on Linux, Windows, Mac or, Raspberry using either Python 2 or Python 3. Simply substitute your system's specific python command to run the examples.","title":"Running The Example"},{"location":"example1/#first-start-the-backplane-in-a-terminal-window","text":"backplane","title":"First, start the Backplane in a terminal window."},{"location":"example1/#start-the-server-in-a-second-terminal-window","text":"Go to the directory that contains simple_echo_server.py and type: python3 simple_echo_server.py The base class prints an informational header to the console.","title":"Start the server in a second terminal window."},{"location":"example1/#start-the-client-in-a-third-terminal-window","text":"Go to the directory that contains simple_echo_client.py and type: python3 simple_echo_client.py A standard Banyan header is printed to the client's console, and the client begins sending its messages. When the client completes sending all of its messages, the client's console will indicate the number of messages sent and received. The console for the server will display all of the message numbers it received","title":"Start the client in a third terminal window."},{"location":"example1/#examining-the-server-code","text":"The server's role is to simply wait for the \"echo\" topic messages to arrive and then to extract the message's payload and publish a \"reply\" topic message. Let's look at the code below: Lines 20 through 22 import the component's required modules. Line 22 illustrates the standard syntax used to import the BanyanBase base class. Line 25 declares the EchoServer component class. It inherits from the BanyanBase base class. 1 \"\"\" 2 simple_echo_server.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 22 from python_banyan.banyan_base import BanyanBase 23 24 25 class EchoServer(BanyanBase): 26 \"\"\" 27 This class is a simple Banyan echo server 28 29 \"\"\" Lines 31 through 44 define the __init__ method. When inheriting from another class, the parent class must be initialized. Line 34 initializes the parent and sets the parent's process_name parameter. The process_name is printed to the console when the component is first invoked. All other default values are accepted as is. Line 37 calls the BanyanBase method set_subscriber_topic to subscribe to 'echo' messages. Line 41 calls the BanyanBase method receive_loop to wait for incoming messages. Line 42 through 44 traps a Control-C entered by the user. The inherited BanyanBase clean_up method is called to close the ZeroMQ connections. The program is then exited. 31 def __init__(self, ): 32 33 # initialize the parent 34 super(EchoServer, self).__init__(process_name='EchoServer') 35 36 # subscribe to receive 'echo' messages from the client 37 self.set_subscriber_topic('echo') 38 39 # wait for messages to arrive 40 try: 41 self.receive_loop() 42 except KeyboardInterrupt: 43 self.clean_up() 44 sys.exit(0) Lines 46 through 55 overrides the base class incoming_message_process method. Whenever a message is received by the receive_loop , it calls incoming_message_processing to process the message. The incoming_message_processing method requires two parameters, a topic string and a payload. Both the topic and payload are decoded within the receive_loop, so they are ready for use by the incoming_message_processing method. Line 53 republishes the payload just received, setting the topic to 'reply,' The message number of the received message is then printed to the console. 46 def incoming_message_processing(self, topic, payload): 47 \"\"\" 48 Process incoming messages from the client 49 :param topic: message topic 50 :param payload: message payload 51 :return: 52 \"\"\" 53 self.publish_payload(payload, 'reply') 54 print('Message number:', payload['message_number']) 55 Lines 61 through 62 create a function to instantiate the EchoServer class. This function is added so that we can install our component as an executable file in our system if we desire to do so. Installing Components as executable modules is explained in a later section. Lines 57 through 62 use a standard Python construct to call the instantiation function. 57 def echo_server(): 58 EchoServer() 59 60 61 if __name__ == '__main__': 62 echo_server()","title":"Examining The Server Code"},{"location":"example1/#examining-the-client-code","text":"The role of the client is to publish 'echo' messages. It maintains a message sequencing number, incorporated into the payload. Shortly after being invoked, the client sends out the first 'echo' message. It then waits for a 'reply' message from the server before publishing the next message. The messaging sequencing number is decremented after each message is published. When the sequencing number reaches zero, the final message is published, and the client halts. The code for the client is very similar to that of the server . In this section, the major differences between the client and server are highlighted. Line 38 calls the inherited BanyanBase method set_subscriber_topic to subscribe to 'reply' messages. Line 41 establishes instance variables to keep track of the current message sequencing number and the total messages sent. Both are initialized to a value of 10. Line 44 publishes an \"echo\" message with a payload containing the current message number. Line 48 calls the component's receive_loop, and the client waits for the next incoming 'reply' message. 1 \"\"\" 2 simple_echo_client.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 21 import sys 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class EchoClient(BanyanBase): 27 \"\"\" 28 This is a simple echo client derived from the BanyanBase class. It sends out a series of messages and expects an 29 echo reply from the server. 30 \"\"\" 31 32 def __init__(self): 33 34 # initialize the parent 35 super(EchoClient, self).__init__(process_name='EchoClient') 36 37 # accept banyan messages with the topic of reply 38 self.set_subscriber_topic('reply') 39 40 # sequence number of messages and total number of messages to send 41 self.message_number = self.number_of_messages = 10 42 43 # send the first message - make sure that the server is already started 44 self.publish_payload({'message_number': self.message_number}, 'echo') 45 46 # get the reply messages 47 try: 48 self.receive_loop() 49 except KeyboardInterrupt: 50 self.clean_up() 51 sys.exit(0) Line 53 is the incoming_message_processing method. Line 62 tests the sequencing value of the 'reply' message. When the sequencing value is set to 0, the final message was sent and received. Lines 63 through 66 print the total number of messages sent and received to the console, and the user is asked to press enter to exit the program. Lines 69 through 71 process non-terminating 'reply' messages. The message number is decremented by 1, and the next 'echo' message is then built and published. 53 def incoming_message_processing(self, topic, payload): 54 \"\"\" 55 Process incoming messages received from the echo client 56 :param topic: Message Topic string 57 :param payload: Message Data 58 :return: 59 \"\"\" 60 61 # When a message is received and its number is zero, finish up. 62 if payload['message_number'] == 0: 63 print(str(self.number_of_messages) + ' messages sent and received. ') 64 input('Press enter to exit.') 65 self.clean_up() 66 sys.exit(0) 67 # bump the message number and send the message out 68 else: 69 self.message_number -= 1 70 if self.message_number >= 0: 71 self.publish_payload({'message_number': self.message_number}, 'echo') 72 73 74 def echo_client(): 75 EchoClient() 76 77 78 if __name__ == '__main__': 79 echo_client() Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Examining The Client Code"},{"location":"example10/","text":"Connecting Banyan Applications To MQTT The MQTT Gateway is a Banyan component that can subscribe to receive MQTT messages from the MQTT network, and then forward those messages to the Banyan network. It also can subscribe to receive Banyan messages, and then forward those to the MQTT network. The MQTT Gateway is installed as a command-line executable when Python Banyan is installed. To invoke the MQTT Gateway, open a terminal window and type: mgw There are several optional command-line parameters available in mgw. For the examples that follow, the default values are accepted Here is a list of all the optional parameters. mgw -h usage: mqtt_gateway.py [-h] [-a MQTT_IP_ADDRESS] [-b BACK_PLANE_IP_ADDRESS] [-d MQTT_PORT] [-e BANYAN_PUB_TOPIC] [-g BANYAN_SUB_TOPICS [BANYAN_SUB_TOPICS ...]] [-i MQTT_PUB_TOPIC] [-j MQTT_SUB_TOPICS [MQTT_SUB_TOPICS ...]] [-n PROCESS_NAME] [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] [-t LOOP_TIME] optional arguments: -h, --help show this help message and exit -a MQTT_IP_ADDRESS IP address of mqtt broker -b BACK_PLANE_IP_ADDRESS None or IP address used by Back Plane -d MQTT_PORT MQTT Port Number -e BANYAN_PUB_TOPIC Topic for messages to MQTT -g BANYAN_SUB_TOPICS [BANYAN_SUB_TOPICS ...] Banyan topics space-delimited: topic1 topic2 topic3 -i MQTT_PUB_TOPIC Topic for messages sent to MQTT -j MQTT_SUB_TOPICS [MQTT_SUB_TOPICS ...] MQTT topics space-delimited: topic1 topic2 topic3 -n PROCESS_NAME Set process name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port -t LOOP_TIME Event Loop Timer in seconds When the MQTT Gateway is invoked, it automatically connects to both the Banyan Backplane and the MQTT Broker. Before running the following examples, make sure that you have a mosquitto broker and a Python Banyan Backplane running. Example 1: Pure MQTT Publish And Subscribe This example will publish a simple MQTT message to be received by a simple MQTT subscriber. MQTT Publisher Below is the code for a simple MQTT publisher that publishes a single message and exits. import json import paho.mqtt.client as mqtt # This is a simple MQTT publisher example. # It connects to an MQTT broker, builds a payload and # then publishes the message with a topic of \"mqtt_network\". my_client = mqtt.Client() my_client.connect(\"localhost\", 1883, 60) z = {'from_mqtt_client': 'hello'} payload = json.dumps(z).encode() my_client.publish(\"mqtt_network\", payload) my_client.disconnect() MQTT Subscriber The MQTT subscriber connects to an MQTT broker and subscribes to 2 topics. The mqtt_network messages are for messages originated on the MQTT network. The from_banyan messages are messages that were originated on the Banyan network. For this first example, no messages are originated from the Banyan network. import paho.mqtt.client as mqtt import json # This is a simple MQTT subscriber example. # It connects to an MQTT broker and # subscribes to \"mqtt_network\" messages # and prints a message when one is received. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \" + str(rc)) client.subscribe(\"mqtt_network\") client.subscribe(\"from_banyan\") def on_message(client, userdata, msg): m = msg.payload.decode() x = json.loads(m) print(x) my_client = mqtt.Client() my_client.connect(\"localhost\", 1883, 60) my_client.on_connect = on_connect my_client.on_message = on_message my_client.loop_forever() First, we start the subscriber and then the publisher. The subscriber prints any messages it receives. Here is the subscriber console output after running the publisher: python3 sub.py Connected with result code 0 {'from_mqtt_client': 'hello'} Example 2: Publishing a Banyan Message To the MQTT Network Start the MQTT Gateway by opening a terminal window and typing: mgw The Gateway connects to the Python Backplane and the MQTT broker $ mgw ************************************************************ MqttGateway using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ MQTT Gateway Connected to MQTT localhost:1883 with result code 0. If it not already running, start the MQTT subscriber, sub.py. To generate a message from Banyan to the MQTT network, we will use a Banyan component called bpub.py: from python_banyan.banyan_base import BanyanBase class Bpub(BanyanBase): \"\"\" This class will publish a message for the MqttGateway to forward to the MQTT network. \"\"\" def __init__(self): \"\"\" This is constructor for the Bpub class \"\"\" # initialize the base class super(Bpub, self).__init__(process_name='Bpub') # send a message to the MqttGateway self.publish_payload({'from_banyan': 'hello_mqtt_world'}, 'to_mqtt') # exit self.clean_up() b = Bpub() If we then start the bpub.py and look at the MQTT Subscriber's output, we see the message from Banyan was sent out over MQTT and received by the MQTT subscriber: ~/PycharmProjects/python_banyan$ python3 sub.py Connected with result code 0 {'from_banyan': 'hello_mqtt_world'} The Gateway received a Banyan message, translated it to an MQTT message, published this message on the MQTT network, and received the translated message by the MQTT subscriber. Example 3: Publishing an MQTT Message To the Banyan Network In this example, an MQTT message will be published by pub.py. The MQTT Gateway will receive this message. It will then translate this message to a Banyan message and publish the message to the Banyan network. A Banyan component called bsub.py subscribes to receive the translated message and will publish it to the console. To run this example, start the MQTT Gateway as we did in Example 2. Start bsub.py: python3 bsub.py from python_banyan.banyan_base import BanyanBase class Bsub(BanyanBase): \"\"\" This class will receive any MQTT messages intercepted by MqttGateway \"\"\" def __init__(self): \"\"\" This is constructor for the Bpub class \"\"\" # initialize the base class super(Bsub, self).__init__(process_name='Bsub') # subscribe to receive MQTT messages processed # by the MqttGateway self.set_subscriber_topic('from_mqtt') # start the receive_loop self.receive_loop() def incoming_message_processing(self, topic, payload): print(topic, payload) b = Bsub() And finally, start the MQTT publisher pub.py python3 pub.py Looking at the console for bsub.py, we see that the message was received from the MQTT network and received by the Banyan network. python3 bsub.py ************************************************************ Bsub using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ from_mqtt {'from_mqtt_client': 'hello'} Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 10 - Connecting Banyan To An MQTT Network"},{"location":"example10/#connecting-banyan-applications-to-mqtt","text":"The MQTT Gateway is a Banyan component that can subscribe to receive MQTT messages from the MQTT network, and then forward those messages to the Banyan network. It also can subscribe to receive Banyan messages, and then forward those to the MQTT network. The MQTT Gateway is installed as a command-line executable when Python Banyan is installed. To invoke the MQTT Gateway, open a terminal window and type: mgw There are several optional command-line parameters available in mgw. For the examples that follow, the default values are accepted Here is a list of all the optional parameters. mgw -h usage: mqtt_gateway.py [-h] [-a MQTT_IP_ADDRESS] [-b BACK_PLANE_IP_ADDRESS] [-d MQTT_PORT] [-e BANYAN_PUB_TOPIC] [-g BANYAN_SUB_TOPICS [BANYAN_SUB_TOPICS ...]] [-i MQTT_PUB_TOPIC] [-j MQTT_SUB_TOPICS [MQTT_SUB_TOPICS ...]] [-n PROCESS_NAME] [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] [-t LOOP_TIME] optional arguments: -h, --help show this help message and exit -a MQTT_IP_ADDRESS IP address of mqtt broker -b BACK_PLANE_IP_ADDRESS None or IP address used by Back Plane -d MQTT_PORT MQTT Port Number -e BANYAN_PUB_TOPIC Topic for messages to MQTT -g BANYAN_SUB_TOPICS [BANYAN_SUB_TOPICS ...] Banyan topics space-delimited: topic1 topic2 topic3 -i MQTT_PUB_TOPIC Topic for messages sent to MQTT -j MQTT_SUB_TOPICS [MQTT_SUB_TOPICS ...] MQTT topics space-delimited: topic1 topic2 topic3 -n PROCESS_NAME Set process name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port -t LOOP_TIME Event Loop Timer in seconds When the MQTT Gateway is invoked, it automatically connects to both the Banyan Backplane and the MQTT Broker. Before running the following examples, make sure that you have a mosquitto broker and a Python Banyan Backplane running.","title":"Connecting Banyan Applications To MQTT"},{"location":"example10/#example-1-pure-mqtt-publish-and-subscribe","text":"This example will publish a simple MQTT message to be received by a simple MQTT subscriber.","title":"Example 1: Pure MQTT Publish And Subscribe"},{"location":"example10/#mqtt-publisher","text":"Below is the code for a simple MQTT publisher that publishes a single message and exits. import json import paho.mqtt.client as mqtt # This is a simple MQTT publisher example. # It connects to an MQTT broker, builds a payload and # then publishes the message with a topic of \"mqtt_network\". my_client = mqtt.Client() my_client.connect(\"localhost\", 1883, 60) z = {'from_mqtt_client': 'hello'} payload = json.dumps(z).encode() my_client.publish(\"mqtt_network\", payload) my_client.disconnect()","title":"MQTT Publisher"},{"location":"example10/#mqtt-subscriber","text":"The MQTT subscriber connects to an MQTT broker and subscribes to 2 topics. The mqtt_network messages are for messages originated on the MQTT network. The from_banyan messages are messages that were originated on the Banyan network. For this first example, no messages are originated from the Banyan network. import paho.mqtt.client as mqtt import json # This is a simple MQTT subscriber example. # It connects to an MQTT broker and # subscribes to \"mqtt_network\" messages # and prints a message when one is received. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \" + str(rc)) client.subscribe(\"mqtt_network\") client.subscribe(\"from_banyan\") def on_message(client, userdata, msg): m = msg.payload.decode() x = json.loads(m) print(x) my_client = mqtt.Client() my_client.connect(\"localhost\", 1883, 60) my_client.on_connect = on_connect my_client.on_message = on_message my_client.loop_forever() First, we start the subscriber and then the publisher. The subscriber prints any messages it receives. Here is the subscriber console output after running the publisher: python3 sub.py Connected with result code 0 {'from_mqtt_client': 'hello'}","title":"MQTT Subscriber"},{"location":"example10/#example-2-publishing-a-banyan-message-to-the-mqtt-network","text":"Start the MQTT Gateway by opening a terminal window and typing: mgw The Gateway connects to the Python Backplane and the MQTT broker $ mgw ************************************************************ MqttGateway using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ MQTT Gateway Connected to MQTT localhost:1883 with result code 0. If it not already running, start the MQTT subscriber, sub.py. To generate a message from Banyan to the MQTT network, we will use a Banyan component called bpub.py: from python_banyan.banyan_base import BanyanBase class Bpub(BanyanBase): \"\"\" This class will publish a message for the MqttGateway to forward to the MQTT network. \"\"\" def __init__(self): \"\"\" This is constructor for the Bpub class \"\"\" # initialize the base class super(Bpub, self).__init__(process_name='Bpub') # send a message to the MqttGateway self.publish_payload({'from_banyan': 'hello_mqtt_world'}, 'to_mqtt') # exit self.clean_up() b = Bpub() If we then start the bpub.py and look at the MQTT Subscriber's output, we see the message from Banyan was sent out over MQTT and received by the MQTT subscriber: ~/PycharmProjects/python_banyan$ python3 sub.py Connected with result code 0 {'from_banyan': 'hello_mqtt_world'} The Gateway received a Banyan message, translated it to an MQTT message, published this message on the MQTT network, and received the translated message by the MQTT subscriber.","title":"Example 2: Publishing a Banyan Message To the MQTT Network"},{"location":"example10/#example-3-publishing-an-mqtt-message-to-the-banyan-network","text":"In this example, an MQTT message will be published by pub.py. The MQTT Gateway will receive this message. It will then translate this message to a Banyan message and publish the message to the Banyan network. A Banyan component called bsub.py subscribes to receive the translated message and will publish it to the console. To run this example, start the MQTT Gateway as we did in Example 2. Start bsub.py: python3 bsub.py from python_banyan.banyan_base import BanyanBase class Bsub(BanyanBase): \"\"\" This class will receive any MQTT messages intercepted by MqttGateway \"\"\" def __init__(self): \"\"\" This is constructor for the Bpub class \"\"\" # initialize the base class super(Bsub, self).__init__(process_name='Bsub') # subscribe to receive MQTT messages processed # by the MqttGateway self.set_subscriber_topic('from_mqtt') # start the receive_loop self.receive_loop() def incoming_message_processing(self, topic, payload): print(topic, payload) b = Bsub() And finally, start the MQTT publisher pub.py python3 pub.py Looking at the console for bsub.py, we see that the message was received from the MQTT network and received by the Banyan network. python3 bsub.py ************************************************************ Bsub using Back Plane IP address: 192.168.2.189 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ from_mqtt {'from_mqtt_client': 'hello'} Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Example 3: Publishing an MQTT Message To the Banyan Network"},{"location":"example11/","text":"GPIO Control This section will look at a simple example illustrating GPIO control of a Raspberry Pi using Python Banyan. The problem we will solve is this: When a user presses a mechanical push button, an LED will light up, and a Banyan message will be published. The Banyan message contains the state change details of the push button - the GPIO pin number, the current state of the button, and a time tick to indicate when the change occurred. When the user releases the pushbutton, the LED will be extinguished. Another message will be published, indicating the new state change. All examples will use a Raspberry Pi Model 3 connected to a Pibrella hat for ease of use. The Pibrella has a push button and several LEDs. This precludes us from having to wire individual components to the Raspberry Pi. For GPIO control, the pigpio GPIO library will be used. A Simple Solution To GPIO Control Of A Raspberry Pi Let's begin by looking at a simple example named single.py . The Code Line By Line 1 \"\"\" 2 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 3 4 This program is free software; you can redistribute it and/or 5 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 6 Version 3 as published by the Free Software Foundation; either 7 or (at your option) any later version. 8 This library is distributed in the hope that it will be useful, 9 but WITHOUT ANY WARRANTY; without even the implied warranty of 10 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 11 General Public License for more details. 12 13 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 14 along with this library; if not, write to the Free Software 15 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 16 17 \"\"\" 18 19 import sys 20 21 import pigpio 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class Single(BanyanBase): 27 \"\"\" 28 This class will monitor a push button connected to a 29 Raspberry Pi. When the button is pressed, an LED will light, 30 and message will be published with changed state of the input pin. 31 \"\"\" 32 33 def __init__(self, push_button=11, led=4, publish_topic='button'): 34 \"\"\" 35 This method initialize the class for operation 36 :param push_button: push_button pin 37 :param led: led pin 38 :param publish_topic: publishing topic 39 \"\"\" 40 41 # initialize the parent 42 super(Single, self).__init__(process_name='Single') 43 44 # make the input parameters available to the entire class 45 self.push_button = push_button 46 self.led = led 47 self.publish_topic = publish_topic 48 49 # initialize the GPIO pins using pigpio 50 self.pi = pigpio.pi() 51 self.pi.set_mode(self.push_button, pigpio.INPUT) 52 self.pi.set_pull_up_down(self.push_button, pigpio.PUD_DOWN) 53 self.pi.set_mode(led, pigpio.OUTPUT) 54 55 # set a glitch filter to debounce the switch 56 self.pi.set_glitch_filter(push_button, 100) 57 58 # set a callback for when the button is pressed 59 self.pi.callback(self.push_button, pigpio.EITHER_EDGE, 60 self.button_callback) 61 62 # this will keep the program running forever 63 try: 64 self.receive_loop() 65 except KeyboardInterrupt: 66 sys.exit(0) 67 68 def button_callback(self, gpio, level, tick): 69 \"\"\" 70 This method receives a change in state of the 71 pushbutton. 72 73 It will print the current state to the console 74 and reflect that state by turning the LED on 75 or OFF based on the state. 76 77 It will also publish a message containing the state 78 change. 79 80 :param gpio: pin number 81 :param level: pin level 82 :param tick: timer tick 83 \"\"\" 84 print('The pushbutton state is {} on pin {} ' 85 'and changed at tick {}'.format(level, gpio, tick)) 86 87 self.pi.write(self.led, level) 88 89 # create a publishing payload 90 payload = {'pushbutton state': level, 'gpio_pin': gpio, 91 'time_tick':tick} 92 self.publish_payload(payload, self.publish_topic) 93 94 95 Single() Line 21 imports the pigpio library. Lines 49 through 60 set the pin mode for both the push button and the LED. Note: The Pibrella requires that the pull-down resistor be enabled on the Raspberry Pi. Line 52 enables the pull-down resistor. A \"glitch\" filter is set on line 56 to prevent the push button from generating multiple events from a single press or release of the button. Line 59 establishes a callback for when the button is either pressed or released. Line 64 calls the base class receive_loop method to keep the loop running until the user quits the program. The callback method is contained in lines 68 through 92. When the user presses or releases the pushbutton, the callback method will be called by pigpio. Lines 84 and 85 print a message to the console containing the parameters passed by pigpio to this method. On line 87, the LED is set to the reported state. Finally, lines 89-92 create and publish a Banyan message about the push button event. Here is the output on the console after pressing and releasing the button twice: python3 single.py ************************************************************ Single using Back Plane IP address: 192.168.2.192 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ The pushbutton state is 1 on pin 11 and changed at tick 3856477239 The pushbutton state is 0 on pin 11 and changed at tick 3857470672 The pushbutton state is 1 on pin 11 and changed at tick 3858747310 The pushbutton state is 0 on pin 11 and changed at tick 3859867653 And here is the output from a Monitor session as the button is pressed and released. $ monitor ************************************************************ Monitor using Back Plane IP address: 192.168.2.192 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ button {'time_tick': 3856477239, 'pushbutton state': 1, 'gpio_pin': 11} button {'time_tick': 3857470672, 'pushbutton state': 0, 'gpio_pin': 11} button {'time_tick': 3858747310, 'pushbutton state': 1, 'gpio_pin': 11} button {'time_tick': 3859867653, 'pushbutton state': 0, 'gpio_pin': 11} Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 11 - Physical Computing And GPIO"},{"location":"example11/#gpio-control","text":"This section will look at a simple example illustrating GPIO control of a Raspberry Pi using Python Banyan. The problem we will solve is this: When a user presses a mechanical push button, an LED will light up, and a Banyan message will be published. The Banyan message contains the state change details of the push button - the GPIO pin number, the current state of the button, and a time tick to indicate when the change occurred. When the user releases the pushbutton, the LED will be extinguished. Another message will be published, indicating the new state change. All examples will use a Raspberry Pi Model 3 connected to a Pibrella hat for ease of use. The Pibrella has a push button and several LEDs. This precludes us from having to wire individual components to the Raspberry Pi. For GPIO control, the pigpio GPIO library will be used.","title":"GPIO Control"},{"location":"example11/#a-simple-solution-to-gpio-control-of-a-raspberry-pi","text":"Let's begin by looking at a simple example named single.py .","title":"A Simple Solution To GPIO Control Of A Raspberry Pi"},{"location":"example11/#the-code-line-by-line","text":"1 \"\"\" 2 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 3 4 This program is free software; you can redistribute it and/or 5 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 6 Version 3 as published by the Free Software Foundation; either 7 or (at your option) any later version. 8 This library is distributed in the hope that it will be useful, 9 but WITHOUT ANY WARRANTY; without even the implied warranty of 10 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 11 General Public License for more details. 12 13 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 14 along with this library; if not, write to the Free Software 15 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 16 17 \"\"\" 18 19 import sys 20 21 import pigpio 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class Single(BanyanBase): 27 \"\"\" 28 This class will monitor a push button connected to a 29 Raspberry Pi. When the button is pressed, an LED will light, 30 and message will be published with changed state of the input pin. 31 \"\"\" 32 33 def __init__(self, push_button=11, led=4, publish_topic='button'): 34 \"\"\" 35 This method initialize the class for operation 36 :param push_button: push_button pin 37 :param led: led pin 38 :param publish_topic: publishing topic 39 \"\"\" 40 41 # initialize the parent 42 super(Single, self).__init__(process_name='Single') 43 44 # make the input parameters available to the entire class 45 self.push_button = push_button 46 self.led = led 47 self.publish_topic = publish_topic 48 49 # initialize the GPIO pins using pigpio 50 self.pi = pigpio.pi() 51 self.pi.set_mode(self.push_button, pigpio.INPUT) 52 self.pi.set_pull_up_down(self.push_button, pigpio.PUD_DOWN) 53 self.pi.set_mode(led, pigpio.OUTPUT) 54 55 # set a glitch filter to debounce the switch 56 self.pi.set_glitch_filter(push_button, 100) 57 58 # set a callback for when the button is pressed 59 self.pi.callback(self.push_button, pigpio.EITHER_EDGE, 60 self.button_callback) 61 62 # this will keep the program running forever 63 try: 64 self.receive_loop() 65 except KeyboardInterrupt: 66 sys.exit(0) 67 68 def button_callback(self, gpio, level, tick): 69 \"\"\" 70 This method receives a change in state of the 71 pushbutton. 72 73 It will print the current state to the console 74 and reflect that state by turning the LED on 75 or OFF based on the state. 76 77 It will also publish a message containing the state 78 change. 79 80 :param gpio: pin number 81 :param level: pin level 82 :param tick: timer tick 83 \"\"\" 84 print('The pushbutton state is {} on pin {} ' 85 'and changed at tick {}'.format(level, gpio, tick)) 86 87 self.pi.write(self.led, level) 88 89 # create a publishing payload 90 payload = {'pushbutton state': level, 'gpio_pin': gpio, 91 'time_tick':tick} 92 self.publish_payload(payload, self.publish_topic) 93 94 95 Single() Line 21 imports the pigpio library. Lines 49 through 60 set the pin mode for both the push button and the LED. Note: The Pibrella requires that the pull-down resistor be enabled on the Raspberry Pi. Line 52 enables the pull-down resistor. A \"glitch\" filter is set on line 56 to prevent the push button from generating multiple events from a single press or release of the button. Line 59 establishes a callback for when the button is either pressed or released. Line 64 calls the base class receive_loop method to keep the loop running until the user quits the program. The callback method is contained in lines 68 through 92. When the user presses or releases the pushbutton, the callback method will be called by pigpio. Lines 84 and 85 print a message to the console containing the parameters passed by pigpio to this method. On line 87, the LED is set to the reported state. Finally, lines 89-92 create and publish a Banyan message about the push button event. Here is the output on the console after pressing and releasing the button twice: python3 single.py ************************************************************ Single using Back Plane IP address: 192.168.2.192 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ The pushbutton state is 1 on pin 11 and changed at tick 3856477239 The pushbutton state is 0 on pin 11 and changed at tick 3857470672 The pushbutton state is 1 on pin 11 and changed at tick 3858747310 The pushbutton state is 0 on pin 11 and changed at tick 3859867653 And here is the output from a Monitor session as the button is pressed and released. $ monitor ************************************************************ Monitor using Back Plane IP address: 192.168.2.192 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ button {'time_tick': 3856477239, 'pushbutton state': 1, 'gpio_pin': 11} button {'time_tick': 3857470672, 'pushbutton state': 0, 'gpio_pin': 11} button {'time_tick': 3858747310, 'pushbutton state': 1, 'gpio_pin': 11} button {'time_tick': 3859867653, 'pushbutton state': 0, 'gpio_pin': 11} Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"The Code Line By Line"},{"location":"example2/","text":"Modifying The Simple Echo Client Being able to set a component's parameters using command-line options allows the user to change a component's behavior. To demonstrate, we will use the existing simple echo client. The code will be modified to allow the user to do the following via the command line: Specify the Backplane IP address Specify the publisher and subscriber port numbers Specify the number of messages to send to the server Specify a process name to display on the banner Specify the loop time This example allows the user to specify, none, one, or any combination of parameters, allowing maximum flexibility. To process user-specified command-line parameters, we will use the argparse library . A code comparison will be provided for the modified code. Any new code that is required is also shown for the feature. Once we modify the code, we will be able to print a help screen to the console by merely invoking the program with a -h command-line option. A list of all command-line options will be displayed for the user to choose from. Adding the Necessary Imports We will import the argparse package as well as the signal package to the original file. Argparse allows us to create the command line arguments. The signal enables us to trap and process a Control-C entered by the user. 22 import argparse 23 import signal Modifying The Component Class Line 29 declares the name for our modified client. Lines 31 through 56 provide usage information. Lines 59 defines the __init__ method, and it accepts a dictionary of parameters, called kwargs . The kwargs dictionary is populated near the end of the program. Lines 88 through 92 dereference the kwargs values and passes the values to the parent class. The rest of the class definition is unchanged. 29 class EchoCmdClient(BanyanBase): 30 \"\"\" 31 This is an echo client that will allow the user 32 to specify command line arguments to change the default behavior 33 of the client. 34 35 It sends out a series of messages and expects an 36 echo reply from the server. When it completes, press enter, and it 37 will send a message to the server so that it also quits 38 39 To use: 1. Start the backplane. 40 2. Start the server. 41 3. Start this client. 42 43 usage: echo_cmdline_client.py [-h] [-b BACK_PLANE_IP_ADDRESS] 44 [-m NUMBER_OF_MESSAGES] [-n PROCESS_NAME] 45 [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] [-t LOOP_TIME] 46 47 optional arguments: 48 -h, --help show this help message and exit 49 -b BACK_PLANE_IP_ADDRESS 50 None or IP address used by Back Plane 51 -m NUMBER_OF_MESSAGES 52 Number of messages to publish 53 -n PROCESS_NAME Set process name in banner 54 -p PUBLISHER_PORT Publisher IP port 55 -s SUBSCRIBER_PORT Subscriber IP port 56 -t LOOP_TIME Event Loop Timer in seconds 57 \"\"\" 58 59 def __init__(self, **kwargs): 60 61 \"\"\" 62 kwargs is a dictionary that will contain the following keys: 63 64 :param back_plane_ip_address: banyan_base back_planeIP Address - 65 if not specified, it will be set to the 66 local computer 67 :param subscriber_port: banyan_base back plane subscriber port. 68 This must match that of the banyan_base backplane 69 :param publisher_port: banyan_base back plane publisher port. 70 This must match that of the 71 banyan_base backplane. 72 :param number_of_messages: number of message to transmit 73 :param process_name: Component identifier 74 :param loop_time: receive loop sleep time 75 76 \"\"\" 77 78 # initialize the parent 79 super(EchoCmdClient, self).__init__(back_plane_ip_address=kwargs['back_plane_ip_address'], 80 subscriber_port=kwargs['subscriber_port'], 81 publisher_port=kwargs['publisher_port'], 82 process_name=kwargs['process_name'], 83 loop_time=kwargs['loop_time']) 84 85 # accept banyan messages with the topic of reply 86 self.set_subscriber_topic('reply') 87 88 # sequence number of messages 89 self.message_number = kwargs['number_of_messages'] 90 91 # number of messages to send 92 self.number_of_messages = kwargs['number_of_messages'] 93 94 # send the first message - make sure that the server is already started 95 self.publish_payload({'message_number': self.message_number}, 'echo') 96 97 # get the reply messages 98 try: 99 self.receive_loop() 100 except KeyboardInterrupt: 101 self.clean_up() 102 sys.exit(0) Adding A Startup Function After The Class Definition Here, we create a function that follows the class definition. This function, called echo_cmdline_client(), will instantiate the class and parse any command-line options that the user may have specified. This function is contained within lines 125 to 168. Line 126 creates an instance of an ArgumentParser. Lines 129 through 144 create the command-line options and adds them to the argument parser. Line 146 creates a variable called args and populates args with the values for all of the command-line options. Lines 148 through 155 retrieve the option values using the defaults or the values provided by the user. The options are then added to a Python dictionary called kw_options. Line 158 instantiates the class, passing in the kw_options. Lines 161 through 164 add a signal handler to trap a user entered Control-C. Line 172 calls the echo_cmdline_client function on line 125 to invoke the client. 125 def echo_cmdline_client(): 126 parser = argparse.ArgumentParser() 127 # allow user to bypass the IP address auto-discovery. 128 # This is necessary if the component resides on a computer 129 # other than the computing running the backplane. 130 parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 131 help=\"None or IP address used by Back Plane\") 132 parser.add_argument(\"-m\", dest=\"number_of_messages\", default=\"10\", 133 help=\"Number of messages to publish\") 134 # allow the user to specify a name for the component and have it shown on the console banner. 135 # modify the default process name to one you wish to see on the banner. 136 # change the default in the derived class to set the name 137 parser.add_argument(\"-n\", dest=\"process_name\", default=\"EchoCmdClient\", 138 help=\"Set process name in banner\") 139 parser.add_argument(\"-p\", dest=\"publisher_port\", default='43124', 140 help=\"Publisher IP port\") 141 parser.add_argument(\"-s\", dest=\"subscriber_port\", default='43125', 142 help=\"Subscriber IP port\") 143 parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", 144 help=\"Event Loop Timer in seconds\") 145 146 args = parser.parse_args() 147 148 if args.back_plane_ip_address == 'None': 149 args.back_plane_ip_address = None 150 kw_options = {'back_plane_ip_address': args.back_plane_ip_address, 151 'number_of_messages': int(args.number_of_messages), 152 'publisher_port': args.publisher_port, 153 'subscriber_port': args.subscriber_port, 154 'process_name': args.process_name, 155 'loop_time': float(args.loop_time)} 156 157 # replace with the name of your class 158 EchoCmdClient(**kw_options) 159 160 161 # signal handler function called when Control-C occurs 162 def signal_handler(sig, frame): 163 raise KeyboardInterrupt 164 165 166 # listen for SIGINT 167 signal.signal(signal.SIGINT, signal_handler) 168 signal.signal(signal.SIGTERM, signal_handler) 169 170 171 if __name__ == '__main__': 172 echo_cmdline_client() Using The -m Option We can now specify the number of messages the client produces while accepting the other parameters' default values. Ensuring that the backplane and server are already running, we can start the new client, asking it to produce 20 messages. python3 echo_cmdline_client.py -m 20 This command will create 20 messages. Here is what the client console displays after running this command. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 2  - Adding Command Line Options To A Component"},{"location":"example2/#modifying-the-simple-echo-client","text":"Being able to set a component's parameters using command-line options allows the user to change a component's behavior. To demonstrate, we will use the existing simple echo client. The code will be modified to allow the user to do the following via the command line: Specify the Backplane IP address Specify the publisher and subscriber port numbers Specify the number of messages to send to the server Specify a process name to display on the banner Specify the loop time This example allows the user to specify, none, one, or any combination of parameters, allowing maximum flexibility. To process user-specified command-line parameters, we will use the argparse library . A code comparison will be provided for the modified code. Any new code that is required is also shown for the feature. Once we modify the code, we will be able to print a help screen to the console by merely invoking the program with a -h command-line option. A list of all command-line options will be displayed for the user to choose from.","title":"Modifying The Simple Echo Client"},{"location":"example2/#adding-the-necessary-imports","text":"We will import the argparse package as well as the signal package to the original file. Argparse allows us to create the command line arguments. The signal enables us to trap and process a Control-C entered by the user. 22 import argparse 23 import signal","title":"Adding the Necessary Imports"},{"location":"example2/#modifying-the-component-class","text":"Line 29 declares the name for our modified client. Lines 31 through 56 provide usage information. Lines 59 defines the __init__ method, and it accepts a dictionary of parameters, called kwargs . The kwargs dictionary is populated near the end of the program. Lines 88 through 92 dereference the kwargs values and passes the values to the parent class. The rest of the class definition is unchanged. 29 class EchoCmdClient(BanyanBase): 30 \"\"\" 31 This is an echo client that will allow the user 32 to specify command line arguments to change the default behavior 33 of the client. 34 35 It sends out a series of messages and expects an 36 echo reply from the server. When it completes, press enter, and it 37 will send a message to the server so that it also quits 38 39 To use: 1. Start the backplane. 40 2. Start the server. 41 3. Start this client. 42 43 usage: echo_cmdline_client.py [-h] [-b BACK_PLANE_IP_ADDRESS] 44 [-m NUMBER_OF_MESSAGES] [-n PROCESS_NAME] 45 [-p PUBLISHER_PORT] [-s SUBSCRIBER_PORT] [-t LOOP_TIME] 46 47 optional arguments: 48 -h, --help show this help message and exit 49 -b BACK_PLANE_IP_ADDRESS 50 None or IP address used by Back Plane 51 -m NUMBER_OF_MESSAGES 52 Number of messages to publish 53 -n PROCESS_NAME Set process name in banner 54 -p PUBLISHER_PORT Publisher IP port 55 -s SUBSCRIBER_PORT Subscriber IP port 56 -t LOOP_TIME Event Loop Timer in seconds 57 \"\"\" 58 59 def __init__(self, **kwargs): 60 61 \"\"\" 62 kwargs is a dictionary that will contain the following keys: 63 64 :param back_plane_ip_address: banyan_base back_planeIP Address - 65 if not specified, it will be set to the 66 local computer 67 :param subscriber_port: banyan_base back plane subscriber port. 68 This must match that of the banyan_base backplane 69 :param publisher_port: banyan_base back plane publisher port. 70 This must match that of the 71 banyan_base backplane. 72 :param number_of_messages: number of message to transmit 73 :param process_name: Component identifier 74 :param loop_time: receive loop sleep time 75 76 \"\"\" 77 78 # initialize the parent 79 super(EchoCmdClient, self).__init__(back_plane_ip_address=kwargs['back_plane_ip_address'], 80 subscriber_port=kwargs['subscriber_port'], 81 publisher_port=kwargs['publisher_port'], 82 process_name=kwargs['process_name'], 83 loop_time=kwargs['loop_time']) 84 85 # accept banyan messages with the topic of reply 86 self.set_subscriber_topic('reply') 87 88 # sequence number of messages 89 self.message_number = kwargs['number_of_messages'] 90 91 # number of messages to send 92 self.number_of_messages = kwargs['number_of_messages'] 93 94 # send the first message - make sure that the server is already started 95 self.publish_payload({'message_number': self.message_number}, 'echo') 96 97 # get the reply messages 98 try: 99 self.receive_loop() 100 except KeyboardInterrupt: 101 self.clean_up() 102 sys.exit(0)","title":"Modifying The Component Class"},{"location":"example2/#adding-a-startup-function-after-the-class-definition","text":"Here, we create a function that follows the class definition. This function, called echo_cmdline_client(), will instantiate the class and parse any command-line options that the user may have specified. This function is contained within lines 125 to 168. Line 126 creates an instance of an ArgumentParser. Lines 129 through 144 create the command-line options and adds them to the argument parser. Line 146 creates a variable called args and populates args with the values for all of the command-line options. Lines 148 through 155 retrieve the option values using the defaults or the values provided by the user. The options are then added to a Python dictionary called kw_options. Line 158 instantiates the class, passing in the kw_options. Lines 161 through 164 add a signal handler to trap a user entered Control-C. Line 172 calls the echo_cmdline_client function on line 125 to invoke the client. 125 def echo_cmdline_client(): 126 parser = argparse.ArgumentParser() 127 # allow user to bypass the IP address auto-discovery. 128 # This is necessary if the component resides on a computer 129 # other than the computing running the backplane. 130 parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 131 help=\"None or IP address used by Back Plane\") 132 parser.add_argument(\"-m\", dest=\"number_of_messages\", default=\"10\", 133 help=\"Number of messages to publish\") 134 # allow the user to specify a name for the component and have it shown on the console banner. 135 # modify the default process name to one you wish to see on the banner. 136 # change the default in the derived class to set the name 137 parser.add_argument(\"-n\", dest=\"process_name\", default=\"EchoCmdClient\", 138 help=\"Set process name in banner\") 139 parser.add_argument(\"-p\", dest=\"publisher_port\", default='43124', 140 help=\"Publisher IP port\") 141 parser.add_argument(\"-s\", dest=\"subscriber_port\", default='43125', 142 help=\"Subscriber IP port\") 143 parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", 144 help=\"Event Loop Timer in seconds\") 145 146 args = parser.parse_args() 147 148 if args.back_plane_ip_address == 'None': 149 args.back_plane_ip_address = None 150 kw_options = {'back_plane_ip_address': args.back_plane_ip_address, 151 'number_of_messages': int(args.number_of_messages), 152 'publisher_port': args.publisher_port, 153 'subscriber_port': args.subscriber_port, 154 'process_name': args.process_name, 155 'loop_time': float(args.loop_time)} 156 157 # replace with the name of your class 158 EchoCmdClient(**kw_options) 159 160 161 # signal handler function called when Control-C occurs 162 def signal_handler(sig, frame): 163 raise KeyboardInterrupt 164 165 166 # listen for SIGINT 167 signal.signal(signal.SIGINT, signal_handler) 168 signal.signal(signal.SIGTERM, signal_handler) 169 170 171 if __name__ == '__main__': 172 echo_cmdline_client()","title":"Adding A Startup Function After The Class Definition"},{"location":"example2/#using-the-m-option","text":"We can now specify the number of messages the client produces while accepting the other parameters' default values. Ensuring that the backplane and server are already running, we can start the new client, asking it to produce 20 messages. python3 echo_cmdline_client.py -m 20 This command will create 20 messages. Here is what the client console displays after running this command. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Using The -m Option"},{"location":"example3/","text":"Distributing Banyan Application Components Across Multiple Computers Distributing the components of a Banyan application across multiple computers is a simple matter of copying the component's Python code to the desired computer and then pointing the component to the running backplane's IP address and ports. For example, let's say we have 2 computers on a network, one with an IP address of 192.168.1.100 and the other with an address of 192.168.1.200. We can distribute the application across two computers. In this scenario, the backplane and the echo server from example 1 run on computer 1. The modified echo client from example 2 runs on computer 2. We need to specify the backplane address using the -b 192.168.1.100 option to point to the backplane on computer 1: python3 echo_cmdline_client.py -b 192.168.1.100 That's it - no configuration files, no recoding, just a simple command-line option! The client will publish 10 messages, but we can easily modify that with the -m command-line option: python3 echo_cmdline_client.py -b 192.168.1.100 -m 20 Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 3  - Distributed Applications"},{"location":"example3/#distributing-banyan-application-components-across-multiple-computers","text":"Distributing the components of a Banyan application across multiple computers is a simple matter of copying the component's Python code to the desired computer and then pointing the component to the running backplane's IP address and ports. For example, let's say we have 2 computers on a network, one with an IP address of 192.168.1.100 and the other with an address of 192.168.1.200. We can distribute the application across two computers. In this scenario, the backplane and the echo server from example 1 run on computer 1. The modified echo client from example 2 runs on computer 2. We need to specify the backplane address using the -b 192.168.1.100 option to point to the backplane on computer 1: python3 echo_cmdline_client.py -b 192.168.1.100 That's it - no configuration files, no recoding, just a simple command-line option! The client will publish 10 messages, but we can easily modify that with the -m command-line option: python3 echo_cmdline_client.py -b 192.168.1.100 -m 20 Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Distributing Banyan Application Components Across Multiple Computers"},{"location":"example4/","text":"JavaScript, Ruby, and Java Banyan Frameworks There are versions of the Banyan Framework available for JavaScript , Ruby , Java . Banyan components can be written with any of these frameworks, and the components can be combined into a single Banyan application. Below is the simple echo server rewritten using the JavaScript Banyan Framework. #!/usr/bin/env node /** Copyright (c) 2017-2019 Alan Yorinks All right reserved. Python Banyan is free software; you can redistribute it and/or modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE Version 3 as published by the Free Software Foundation; either or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA */ const BanyanBase = require('js-banyan/lib/banyan_base'); class SimpleEchoServer extends BanyanBase { constructor() { super({ processName: 'SimpleEchoServer' }); this.set_subscriber_topic('echo'); this.receive_loop(); } incoming_message_processing( topic, payload) { console.log('Message number:', payload['message_number']); this.publish_payload(payload, 'reply'); } } try { new SimpleEchoServer(); } catch(err){ process.exit() } Compare it to the Python version, and you can easily see how similar they are. To run the example, first start the Backplane (it can be any of the Backplanes - Python, JavaScript, Ruby or Java), then start the JavaScript server: node simple_echo_server.js and finally start the Python client. The application runs as if it was written for a single platform. No changes to the protocol messages or the code are necessary. The components, in conjunction with any of the Backplanes, create a cohesive, seamless application. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 4  - Applications From Components On Differing Platforms"},{"location":"example4/#javascript-ruby-and-java-banyan-frameworks","text":"There are versions of the Banyan Framework available for JavaScript , Ruby , Java . Banyan components can be written with any of these frameworks, and the components can be combined into a single Banyan application. Below is the simple echo server rewritten using the JavaScript Banyan Framework. #!/usr/bin/env node /** Copyright (c) 2017-2019 Alan Yorinks All right reserved. Python Banyan is free software; you can redistribute it and/or modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE Version 3 as published by the Free Software Foundation; either or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA */ const BanyanBase = require('js-banyan/lib/banyan_base'); class SimpleEchoServer extends BanyanBase { constructor() { super({ processName: 'SimpleEchoServer' }); this.set_subscriber_topic('echo'); this.receive_loop(); } incoming_message_processing( topic, payload) { console.log('Message number:', payload['message_number']); this.publish_payload(payload, 'reply'); } } try { new SimpleEchoServer(); } catch(err){ process.exit() } Compare it to the Python version, and you can easily see how similar they are. To run the example, first start the Backplane (it can be any of the Backplanes - Python, JavaScript, Ruby or Java), then start the JavaScript server: node simple_echo_server.js and finally start the Python client. The application runs as if it was written for a single platform. No changes to the protocol messages or the code are necessary. The components, in conjunction with any of the Backplanes, create a cohesive, seamless application. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"JavaScript, Ruby, and Java Banyan Frameworks"},{"location":"example5/","text":"The Banyan Monitor When Python Banyan is installed, an executable program called monitor is automatically installed. The monitor is a special Banyan component that prints all protocol messages published to the Backplane. It displays the message topic as well as the payload for each message. It is used mainly as a debugging aid to monitor and debug messaging traffic. To see the monitor in action, start the Backplane and server as described in Section 1 . Before starting the client, open a terminal or command window and type: monitor The monitor displays a familiar Banyan banner. Now start the client. The monitor will display all of the protocol messages published by both the client and the server. The monitor displays each protocol message. The topic is displayed, followed by the payload. The topic is displayed as a string and the payload as a Python dictionary. Note that CPU utilization is likely to increase when the monitor is active, so you may wish to dismiss the monitor once an application is debugged. The monitor has several command-line options available: The monitor may be located on any computer and be connected to any backplane by using the -b, -s, and -p options. If you wish to display numpy data payloads, use the -m option and set it to True. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 5  - Debugging Using The Monitor"},{"location":"example5/#the-banyan-monitor","text":"When Python Banyan is installed, an executable program called monitor is automatically installed. The monitor is a special Banyan component that prints all protocol messages published to the Backplane. It displays the message topic as well as the payload for each message. It is used mainly as a debugging aid to monitor and debug messaging traffic. To see the monitor in action, start the Backplane and server as described in Section 1 . Before starting the client, open a terminal or command window and type: monitor The monitor displays a familiar Banyan banner. Now start the client. The monitor will display all of the protocol messages published by both the client and the server. The monitor displays each protocol message. The topic is displayed, followed by the payload. The topic is displayed as a string and the payload as a Python dictionary. Note that CPU utilization is likely to increase when the monitor is active, so you may wish to dismiss the monitor once an application is debugged. The monitor has several command-line options available: The monitor may be located on any computer and be connected to any backplane by using the -b, -s, and -p options. If you wish to display numpy data payloads, use the -m option and set it to True. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"The Banyan Monitor"},{"location":"example6/","text":"Creating A Banyan GUI Component This section will demonstrate how to create a Banyan compatible GUI client for the simple echo server example. Both Banyan and GUI frameworks are implemented using event loops . Because only one event loop can run within any given thread of execution, we need to find a way for both event loops to coexist. One solution is to create a multi-threaded application with each event loop running in its own thread. This, however, introduces unnecessary complexity and complicates the testing and debugging efforts. If you are using a GUI that provides a callback hook to allow you to link your own code into the GUI's event loop, a much simpler solution is at hand. The Tkinter GUI framework provides such a hook, and we will integrate Banyan into our GUI using this technique. Note that many other GUI frameworks also provide a callback hook. The techniques shown here may also be applied similarly to those frameworks. The remi library, for example, uses a method called idle to provide the callback hook. The Tkinter callback hook method is called after . We will pass in 2 parameters to after , a sleep time in milliseconds, and the user callback function called when the sleep time expires. The example code shown below illustrates integrating the Banyan receive_loop into the GUI event loop using the after method. Some discussion of Tkinter will be provided for clarity. However, a detailed discussion of the Tkinter framework is beyond the scope of this document. This ebook offers a concise and useful discussion of building GUIs with Tkinter. An online version may be found here . Running The Example Make sure that the backplane and server are running. Next, start tk_echo_client.py . After starting the GUI client code, you should see the GUI shown at the top of this section appear on your screen, and the console should display something similar to this: If you press the \"Send Messages\" button, you should the \"Messages Sent\" field update to 10. If you start the Monitor before pressing the \"Send Messages\" button, you can verify the messages' contents. Exploring The Example Code The code is shown below. Importing Tkinter Lines 27 through 34 handle the Tkinter differences for Python 2 and 3 and allow a single code source to service both Tkinter versions. Lines 37 through 39 import not only the BanyanBase class but MessagePack and ZeroMQ as well. Our GUI component needs direct access to these packages because portions of the Python Banyan receive_loop will be placed in the Tkinter mainloop. Lines 62 through 68 are in preparation for initializing the parent BanyanBase class on line 71. Lines 77 and 78 subscribe to all topics of interest. Breaking Into The GUI Event Loop Line 149 uses the Tkinter after method. The first parameter specifies a delay in milliseconds before the callback function specified by the second parameter is called. In this example, the callback function is the get_message method defined on line 156. This method is essentially the same code normally run in the BanyanBase receive_loop. It checks to see if there any Banyan messages to process, and if there are, it processes them. If there are no messages available, line 169 re-arms the Tkinter after method to check for Banyan messages within the GUI event loop. 1 #!/usr/bin/env python 2 3 \"\"\" 4 tk_echo_client.py 5 6 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 7 8 Python Banyan is free software; you can redistribute it and/or 9 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 10 Version 3 as published by the Free Software Foundation; either 11 or (at your option) any later version. 12 This library is distributed in the hope that it will be useful, 13 but WITHOUT ANY WARRANTY; without even the implied warranty of 14 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 15 General Public License for more details. 16 17 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 18 along with this library; if not, write to the Free Software 19 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 20 21 \"\"\" 22 from __future__ import unicode_literals 23 24 import time 25 26 # python 2/3 compatibility 27 try: 28 from Tkinter import * 29 from Tkinter import font 30 from Tkinter import ttk 31 except ImportError: 32 from Tkinter import * 33 import tkFont as font 34 import ttk 35 36 import sys 37 import umsgpack 38 import zmq 39 from python_banyan.banyan_base import BanyanBase 40 41 42 # noinspection PyMethodMayBeStatic,PyUnresolvedReferences,PyUnusedLocal 43 class TkEchoClient(BanyanBase): 44 \"\"\" 45 A graphical echo client. 46 \"\"\" 47 48 def __init__(self, topics=['reply'], number_of_messages=10, 49 back_plane_ip_address=None, subscriber_port='43125', 50 publisher_port='43124', process_name='Banyan Echo Client'): 51 \"\"\" 52 53 :param topics: A list of topics to subscribe to 54 :param number_of_messages: Default number of echo messages to send 55 :param back_plane_ip_address: 56 :param subscriber_port: 57 :param publisher_port: 58 :param process_name: 59 \"\"\" 60 61 # establish some banyan variables 62 self.back_plane_ip_address = back_plane_ip_address 63 self.subscriber_port = subscriber_port 64 self.publisher_port = publisher_port 65 66 # subscribe to the topic 67 if topics is None: 68 raise ValueError('No Topic List Was Specified.') 69 70 # initialize the banyan base class 71 super(TkEchoClient, self).__init__(back_plane_ip_address=back_plane_ip_address, 72 subscriber_port=subscriber_port, 73 publisher_port=publisher_port, 74 process_name=process_name) 75 76 # subscribe to all topics specified 77 for x in topics: 78 self.set_subscriber_topic(str(x)) 79 80 # setup root window 81 self.root = Tk() 82 # create content window into which everything else is placed 83 84 self.root.title(process_name) 85 self.content = ttk.Frame(self.root, borderwidth=5, 86 relief=\"sunken\", padding=12) 87 88 # use a grid layout 89 self.content.grid(column=0, row=0, sticky=(N, S, E, W)) 90 91 self.content.columnconfigure(0, weight=1) 92 self.content.rowconfigure(0, weight=1) 93 94 # setup some display variables 95 96 # messages to be sent 97 self.messages_to_be_sent = StringVar() 98 self.messages_to_be_sent.set('10') 99 100 # messages sent count 101 self.messages_sent = StringVar() 102 self.message_sent_count = 0 103 self.messages_sent.set(str(self.message_sent_count)) 104 105 # set up font variant 106 self.larger_font = font.Font(size=12) 107 108 # add the widgets 109 ttk.Label(self.content, font=self.larger_font, text=\"Messages To Be Sent\").grid(column=3, row=1, sticky=W) 110 ttk.Label(self.content, font=self.larger_font, text=\"Messages Sent\").grid(column=3, row=2, sticky=W) 111 112 style = ttk.Style() 113 style.configure(\"BW.TLabel\", foreground=\"black\", background=\"white\") 114 115 ttk.Label(self.content, font=self.larger_font, 116 textvariable=self.messages_sent, 117 width=5, 118 anchor=E, justify=RIGHT, style=\"BW.TLabel\").grid(column=2, row=2, sticky=W) 119 120 self.to_send_entry = ttk.Entry(self.content, width=5, 121 font=self.larger_font, 122 textvariable=self.messages_to_be_sent, 123 justify='right') 124 self.to_send_entry.grid(column=2, row=1, sticky=(W, E)) 125 126 s = ttk.Style() 127 s.configure('my.TButton', font=self.larger_font) 128 129 self.send_button = ttk.Button(self.content, text=\"Send Messages\", 130 command=self.send, style='my.TButton') 131 self.send_button.grid(column=4, row=3, sticky=W) 132 133 for child in self.content.winfo_children(): 134 child.grid_configure(padx=20, pady=5) 135 136 self.to_send_entry.focus() 137 self.root.bind('<Return>', self.send) 138 139 self.number_of_messages = number_of_messages 140 141 # sequence number of messages 142 self.message_number = self.number_of_messages 143 144 # send the first message - make sure that the server is already started 145 # self.publish_payload({'message_number': self.message_number}, 'echo') 146 self.message_number -= 1 147 self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing) 148 149 self.root.after(1, self.get_message) 150 151 try: 152 self.root.mainloop() 153 except KeyboardInterrupt: 154 self.on_closing() 155 156 def get_message(self): 157 \"\"\" 158 This method is called from the tkevent loop \"after\" call. It will poll for new zeromq messages 159 :return: 160 \"\"\" 161 try: 162 data = self.subscriber.recv_multipart(zmq.NOBLOCK) 163 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 164 self.root.after(1, self.get_message) 165 166 except zmq.error.Again: 167 try: 168 time.sleep(.0001) 169 self.root.after(1, self.get_message) 170 171 except KeyboardInterrupt: 172 self.root.destroy() 173 self.publisher.close() 174 self.subscriber.close() 175 self.my_context.term() 176 sys.exit(0) 177 except KeyboardInterrupt: 178 self.root.destroy() 179 self.publisher.close() 180 self.subscriber.close() 181 self.my_context.term() 182 sys.exit(0) 183 184 def incoming_message_processing(self, topic, payload): 185 # When a message is received and its number is zero, finish up. 186 if self.message_number == 0: 187 self.messages_sent.set(str(self.number_of_messages)) 188 189 # bump the message number and send the message out 190 else: 191 self.message_number -= 1 192 self.message_sent_count += 1 193 self.messages_sent.set(str(self.message_sent_count)) 194 195 # account for python2 vs python3 differences 196 if sys.version_info[0] < 3: 197 self.publish_payload({'message_number': self.message_number}, 'echo'.encode()) 198 else: 199 self.publish_payload({'message_number': self.message_number}, 'echo') 200 201 202 def send(self, *args): 203 msgs = self.to_send_entry.get() 204 # reset the sent count variables to zero 205 self.message_sent_count = 0 206 self.messages_sent.set(str(self.message_sent_count)) 207 208 # set current message number to the number of messages to be sent 209 self.message_number = int(msgs) 210 211 # update the number of messages to be sent 212 self.number_of_messages = int(msgs) 213 214 # account for python2 vs python3 differences 215 if sys.version_info[0] < 3: 216 self.publish_payload({'message_number': self.message_number}, 'echo'.encode()) 217 else: 218 self.publish_payload({'message_number': self.message_number}, 'echo') 219 220 def on_closing(self): 221 \"\"\" 222 Destroy the window 223 :return: 224 \"\"\" 225 self.clean_up() 226 self.root.destroy() 227 228 229 def gui_client(): 230 TkEchoClient() 231 232 233 if __name__ == '__main__': 234 gui_client() Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 6  - Integrating With A GUI Event Loop"},{"location":"example6/#creating-a-banyan-gui-component","text":"This section will demonstrate how to create a Banyan compatible GUI client for the simple echo server example. Both Banyan and GUI frameworks are implemented using event loops . Because only one event loop can run within any given thread of execution, we need to find a way for both event loops to coexist. One solution is to create a multi-threaded application with each event loop running in its own thread. This, however, introduces unnecessary complexity and complicates the testing and debugging efforts. If you are using a GUI that provides a callback hook to allow you to link your own code into the GUI's event loop, a much simpler solution is at hand. The Tkinter GUI framework provides such a hook, and we will integrate Banyan into our GUI using this technique. Note that many other GUI frameworks also provide a callback hook. The techniques shown here may also be applied similarly to those frameworks. The remi library, for example, uses a method called idle to provide the callback hook. The Tkinter callback hook method is called after . We will pass in 2 parameters to after , a sleep time in milliseconds, and the user callback function called when the sleep time expires. The example code shown below illustrates integrating the Banyan receive_loop into the GUI event loop using the after method. Some discussion of Tkinter will be provided for clarity. However, a detailed discussion of the Tkinter framework is beyond the scope of this document. This ebook offers a concise and useful discussion of building GUIs with Tkinter. An online version may be found here .","title":"Creating A Banyan GUI Component"},{"location":"example6/#running-the-example","text":"Make sure that the backplane and server are running. Next, start tk_echo_client.py . After starting the GUI client code, you should see the GUI shown at the top of this section appear on your screen, and the console should display something similar to this: If you press the \"Send Messages\" button, you should the \"Messages Sent\" field update to 10. If you start the Monitor before pressing the \"Send Messages\" button, you can verify the messages' contents.","title":"Running The Example"},{"location":"example6/#exploring-the-example-code","text":"The code is shown below.","title":"Exploring The Example Code"},{"location":"example6/#importing-tkinter","text":"Lines 27 through 34 handle the Tkinter differences for Python 2 and 3 and allow a single code source to service both Tkinter versions. Lines 37 through 39 import not only the BanyanBase class but MessagePack and ZeroMQ as well. Our GUI component needs direct access to these packages because portions of the Python Banyan receive_loop will be placed in the Tkinter mainloop. Lines 62 through 68 are in preparation for initializing the parent BanyanBase class on line 71. Lines 77 and 78 subscribe to all topics of interest.","title":"Importing Tkinter"},{"location":"example6/#breaking-into-the-gui-event-loop","text":"Line 149 uses the Tkinter after method. The first parameter specifies a delay in milliseconds before the callback function specified by the second parameter is called. In this example, the callback function is the get_message method defined on line 156. This method is essentially the same code normally run in the BanyanBase receive_loop. It checks to see if there any Banyan messages to process, and if there are, it processes them. If there are no messages available, line 169 re-arms the Tkinter after method to check for Banyan messages within the GUI event loop. 1 #!/usr/bin/env python 2 3 \"\"\" 4 tk_echo_client.py 5 6 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 7 8 Python Banyan is free software; you can redistribute it and/or 9 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 10 Version 3 as published by the Free Software Foundation; either 11 or (at your option) any later version. 12 This library is distributed in the hope that it will be useful, 13 but WITHOUT ANY WARRANTY; without even the implied warranty of 14 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 15 General Public License for more details. 16 17 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 18 along with this library; if not, write to the Free Software 19 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 20 21 \"\"\" 22 from __future__ import unicode_literals 23 24 import time 25 26 # python 2/3 compatibility 27 try: 28 from Tkinter import * 29 from Tkinter import font 30 from Tkinter import ttk 31 except ImportError: 32 from Tkinter import * 33 import tkFont as font 34 import ttk 35 36 import sys 37 import umsgpack 38 import zmq 39 from python_banyan.banyan_base import BanyanBase 40 41 42 # noinspection PyMethodMayBeStatic,PyUnresolvedReferences,PyUnusedLocal 43 class TkEchoClient(BanyanBase): 44 \"\"\" 45 A graphical echo client. 46 \"\"\" 47 48 def __init__(self, topics=['reply'], number_of_messages=10, 49 back_plane_ip_address=None, subscriber_port='43125', 50 publisher_port='43124', process_name='Banyan Echo Client'): 51 \"\"\" 52 53 :param topics: A list of topics to subscribe to 54 :param number_of_messages: Default number of echo messages to send 55 :param back_plane_ip_address: 56 :param subscriber_port: 57 :param publisher_port: 58 :param process_name: 59 \"\"\" 60 61 # establish some banyan variables 62 self.back_plane_ip_address = back_plane_ip_address 63 self.subscriber_port = subscriber_port 64 self.publisher_port = publisher_port 65 66 # subscribe to the topic 67 if topics is None: 68 raise ValueError('No Topic List Was Specified.') 69 70 # initialize the banyan base class 71 super(TkEchoClient, self).__init__(back_plane_ip_address=back_plane_ip_address, 72 subscriber_port=subscriber_port, 73 publisher_port=publisher_port, 74 process_name=process_name) 75 76 # subscribe to all topics specified 77 for x in topics: 78 self.set_subscriber_topic(str(x)) 79 80 # setup root window 81 self.root = Tk() 82 # create content window into which everything else is placed 83 84 self.root.title(process_name) 85 self.content = ttk.Frame(self.root, borderwidth=5, 86 relief=\"sunken\", padding=12) 87 88 # use a grid layout 89 self.content.grid(column=0, row=0, sticky=(N, S, E, W)) 90 91 self.content.columnconfigure(0, weight=1) 92 self.content.rowconfigure(0, weight=1) 93 94 # setup some display variables 95 96 # messages to be sent 97 self.messages_to_be_sent = StringVar() 98 self.messages_to_be_sent.set('10') 99 100 # messages sent count 101 self.messages_sent = StringVar() 102 self.message_sent_count = 0 103 self.messages_sent.set(str(self.message_sent_count)) 104 105 # set up font variant 106 self.larger_font = font.Font(size=12) 107 108 # add the widgets 109 ttk.Label(self.content, font=self.larger_font, text=\"Messages To Be Sent\").grid(column=3, row=1, sticky=W) 110 ttk.Label(self.content, font=self.larger_font, text=\"Messages Sent\").grid(column=3, row=2, sticky=W) 111 112 style = ttk.Style() 113 style.configure(\"BW.TLabel\", foreground=\"black\", background=\"white\") 114 115 ttk.Label(self.content, font=self.larger_font, 116 textvariable=self.messages_sent, 117 width=5, 118 anchor=E, justify=RIGHT, style=\"BW.TLabel\").grid(column=2, row=2, sticky=W) 119 120 self.to_send_entry = ttk.Entry(self.content, width=5, 121 font=self.larger_font, 122 textvariable=self.messages_to_be_sent, 123 justify='right') 124 self.to_send_entry.grid(column=2, row=1, sticky=(W, E)) 125 126 s = ttk.Style() 127 s.configure('my.TButton', font=self.larger_font) 128 129 self.send_button = ttk.Button(self.content, text=\"Send Messages\", 130 command=self.send, style='my.TButton') 131 self.send_button.grid(column=4, row=3, sticky=W) 132 133 for child in self.content.winfo_children(): 134 child.grid_configure(padx=20, pady=5) 135 136 self.to_send_entry.focus() 137 self.root.bind('<Return>', self.send) 138 139 self.number_of_messages = number_of_messages 140 141 # sequence number of messages 142 self.message_number = self.number_of_messages 143 144 # send the first message - make sure that the server is already started 145 # self.publish_payload({'message_number': self.message_number}, 'echo') 146 self.message_number -= 1 147 self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing) 148 149 self.root.after(1, self.get_message) 150 151 try: 152 self.root.mainloop() 153 except KeyboardInterrupt: 154 self.on_closing() 155 156 def get_message(self): 157 \"\"\" 158 This method is called from the tkevent loop \"after\" call. It will poll for new zeromq messages 159 :return: 160 \"\"\" 161 try: 162 data = self.subscriber.recv_multipart(zmq.NOBLOCK) 163 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 164 self.root.after(1, self.get_message) 165 166 except zmq.error.Again: 167 try: 168 time.sleep(.0001) 169 self.root.after(1, self.get_message) 170 171 except KeyboardInterrupt: 172 self.root.destroy() 173 self.publisher.close() 174 self.subscriber.close() 175 self.my_context.term() 176 sys.exit(0) 177 except KeyboardInterrupt: 178 self.root.destroy() 179 self.publisher.close() 180 self.subscriber.close() 181 self.my_context.term() 182 sys.exit(0) 183 184 def incoming_message_processing(self, topic, payload): 185 # When a message is received and its number is zero, finish up. 186 if self.message_number == 0: 187 self.messages_sent.set(str(self.number_of_messages)) 188 189 # bump the message number and send the message out 190 else: 191 self.message_number -= 1 192 self.message_sent_count += 1 193 self.messages_sent.set(str(self.message_sent_count)) 194 195 # account for python2 vs python3 differences 196 if sys.version_info[0] < 3: 197 self.publish_payload({'message_number': self.message_number}, 'echo'.encode()) 198 else: 199 self.publish_payload({'message_number': self.message_number}, 'echo') 200 201 202 def send(self, *args): 203 msgs = self.to_send_entry.get() 204 # reset the sent count variables to zero 205 self.message_sent_count = 0 206 self.messages_sent.set(str(self.message_sent_count)) 207 208 # set current message number to the number of messages to be sent 209 self.message_number = int(msgs) 210 211 # update the number of messages to be sent 212 self.number_of_messages = int(msgs) 213 214 # account for python2 vs python3 differences 215 if sys.version_info[0] < 3: 216 self.publish_payload({'message_number': self.message_number}, 'echo'.encode()) 217 else: 218 self.publish_payload({'message_number': self.message_number}, 'echo') 219 220 def on_closing(self): 221 \"\"\" 222 Destroy the window 223 :return: 224 \"\"\" 225 self.clean_up() 226 self.root.destroy() 227 228 229 def gui_client(): 230 TkEchoClient() 231 232 233 if __name__ == '__main__': 234 gui_client() Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Breaking Into The GUI Event Loop"},{"location":"example7/","text":"Installing Your Components As Executable Modules There are times when it is more convenient to start a Banyan component using the command-line without having to invoke the Python interpreter explicitly. For example, instead of starting the server with: python simple_echo_server.py You might wish to start it by simply typing: server Fortunately, the Python setuptools provide a reasonably simple way to install a Python script as a command-line executable. The setuptools can perform the installation in a platform-independent way. So no matter if you are running Windows, Mac, or Linux, no code changes are necessary, and installation is performed consistently across all platforms. Creating A Package Directory Structure The first thing you need to do is to set up a directory structure for setuptools to use. Setuptools expects a specific directory structure. Here is a directory structure for an example project called ecs . ecs \u251c\u2500\u2500 ecs \u2502 \u251c\u2500\u2500 echo_cmdline_client.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 simple_echo_server.py \u2502 \u2514\u2500\u2500 tk_echo_client.py \u2514\u2500\u2500 setup.py You can find a copy of this directory and all of its files on GitHub. We start with a top-level directory called ecs. The ecs directory contains the setup.py file, in addition to a directory with the package name. The package name is also ecs . This second directory holds the package's source files, as well as __init__.py . Even though this file is empty, it identifies the directory as a python package for setuptools. The setup.py file will be configured to install the three Python source files as executables called server , client, and gui . To perform the installation, we will use the pip facility. setup.py Let's start by looking at the setup.py file shown below. 1 from setuptools import setup 2 3 setup( 4 name='ecs', 5 version='1.0', 6 packages=[ 7 'ecs', 8 ], 9 install_requires=[ 10 'pyzmq', 11 'u-msgpack-python', 12 'msgpack-python', 13 'numpy>=1.9', 14 'msgpack-numpy', 15 'psutil' 16 ], 17 18 entry_points={ 19 'console_scripts': [ 20 'client = ecs.echo_cmdline_client:echo_cmdline_client', 21 'server = ecs.simple_echo_server:echo_server', 22 'gui = ecs.tk_echo_client:gui_client' 23 ] 24 }, 25 ) Line 1 imports setup from setuptools. Lines 3 through 25 define the setup function required by setuptools. Line 4 is the name parameter that specifies the name we wish to give to our package. Line 5 is the version number. We can change the version as we make changes. Line 6 is a list of packages that make up our package. A package can be comprised of a set of packages, and therefore it is expressed as a list. For our purposes, we only have one package. Lines 9 through 16 is a list of packages our package requires to run. Lines 18 through 24 defines a dictionary called entry_points that contains a single key called console_scripts , with a list of 3 strings as its value. For each of the three entries, the string to the left of the equals sign specifies the script command-line name. The string between the equals sign and the colon defines the python script's location, and the string after the colon defines the name of the function that will be called within the script to start it. Let's look at the format for the first executable, 'client.' Executable Name On the left of the equal sign is the name we wish to give our executable, and in this case, the name is client . Location Of The File On the right of the equal sign is a dotted notation of where the source file resides. This is followed by a function within the file to be called to start the program. Line 20 specifies the file location as \"ecs.echo_cmdline_client\". The first part is the name of the package, \"ecs.\" That is the directory that contains the source files. The second part is the file name within this directory, \"echo_cmdline_client.\" Startup Function If we look at line 125 of the source code for the client , we see the function called \"echo_cmdline_client.\" This is the function we specify to start the component when we invoke \"client\" as a command-line command. Installing With pip To install our files as executables, we first go to the directory that contains the ecs directory, for example, python_banyan/python_banyan/examples . We then type: pip install ./ecs to install using our local copy of the ecs package. If we did not specify \" ./ecs \" and just used ecs , pip would try to access and install the package from pypi on the internet. Now, after starting the backplane, you can start the server by simply typing \"server\" in a command window, and either \"client\" or \"gui\" in another command window to start a client. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 7  - Installing Components As Executable Modules"},{"location":"example7/#installing-your-components-as-executable-modules","text":"There are times when it is more convenient to start a Banyan component using the command-line without having to invoke the Python interpreter explicitly. For example, instead of starting the server with: python simple_echo_server.py You might wish to start it by simply typing: server Fortunately, the Python setuptools provide a reasonably simple way to install a Python script as a command-line executable. The setuptools can perform the installation in a platform-independent way. So no matter if you are running Windows, Mac, or Linux, no code changes are necessary, and installation is performed consistently across all platforms.","title":"Installing Your Components As Executable Modules"},{"location":"example7/#creating-a-package-directory-structure","text":"The first thing you need to do is to set up a directory structure for setuptools to use. Setuptools expects a specific directory structure. Here is a directory structure for an example project called ecs . ecs \u251c\u2500\u2500 ecs \u2502 \u251c\u2500\u2500 echo_cmdline_client.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 simple_echo_server.py \u2502 \u2514\u2500\u2500 tk_echo_client.py \u2514\u2500\u2500 setup.py You can find a copy of this directory and all of its files on GitHub. We start with a top-level directory called ecs. The ecs directory contains the setup.py file, in addition to a directory with the package name. The package name is also ecs . This second directory holds the package's source files, as well as __init__.py . Even though this file is empty, it identifies the directory as a python package for setuptools. The setup.py file will be configured to install the three Python source files as executables called server , client, and gui . To perform the installation, we will use the pip facility.","title":"Creating A Package Directory Structure"},{"location":"example7/#setuppy","text":"Let's start by looking at the setup.py file shown below. 1 from setuptools import setup 2 3 setup( 4 name='ecs', 5 version='1.0', 6 packages=[ 7 'ecs', 8 ], 9 install_requires=[ 10 'pyzmq', 11 'u-msgpack-python', 12 'msgpack-python', 13 'numpy>=1.9', 14 'msgpack-numpy', 15 'psutil' 16 ], 17 18 entry_points={ 19 'console_scripts': [ 20 'client = ecs.echo_cmdline_client:echo_cmdline_client', 21 'server = ecs.simple_echo_server:echo_server', 22 'gui = ecs.tk_echo_client:gui_client' 23 ] 24 }, 25 ) Line 1 imports setup from setuptools. Lines 3 through 25 define the setup function required by setuptools. Line 4 is the name parameter that specifies the name we wish to give to our package. Line 5 is the version number. We can change the version as we make changes. Line 6 is a list of packages that make up our package. A package can be comprised of a set of packages, and therefore it is expressed as a list. For our purposes, we only have one package. Lines 9 through 16 is a list of packages our package requires to run. Lines 18 through 24 defines a dictionary called entry_points that contains a single key called console_scripts , with a list of 3 strings as its value. For each of the three entries, the string to the left of the equals sign specifies the script command-line name. The string between the equals sign and the colon defines the python script's location, and the string after the colon defines the name of the function that will be called within the script to start it. Let's look at the format for the first executable, 'client.'","title":"setup.py"},{"location":"example7/#executable-name","text":"On the left of the equal sign is the name we wish to give our executable, and in this case, the name is client .","title":"Executable Name"},{"location":"example7/#location-of-the-file","text":"On the right of the equal sign is a dotted notation of where the source file resides. This is followed by a function within the file to be called to start the program. Line 20 specifies the file location as \"ecs.echo_cmdline_client\". The first part is the name of the package, \"ecs.\" That is the directory that contains the source files. The second part is the file name within this directory, \"echo_cmdline_client.\"","title":"Location Of The File"},{"location":"example7/#startup-function","text":"If we look at line 125 of the source code for the client , we see the function called \"echo_cmdline_client.\" This is the function we specify to start the component when we invoke \"client\" as a command-line command.","title":"Startup Function"},{"location":"example7/#installing-with-pip","text":"To install our files as executables, we first go to the directory that contains the ecs directory, for example, python_banyan/python_banyan/examples . We then type: pip install ./ecs to install using our local copy of the ecs package. If we did not specify \" ./ecs \" and just used ecs , pip would try to access and install the package from pypi on the internet. Now, after starting the backplane, you can start the server by simply typing \"server\" in a command window, and either \"client\" or \"gui\" in another command window to start a client. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Installing With pip"},{"location":"example8/","text":"The Python Banyan Launcher Launching a Banyan application often involves launching multiple individual Banyan components. The Python Banyan launcher simplifies the launch process by allowing you to start all the components from a single console command. This source code for the Banyan launcher may be found on GitHub. NOTE: For Linux, Mac, and Raspberry PI users, the launcher requires xterm to be installed on your system. Xterm is not required for Windows, so Windows users can skip to Launching Components. Testing For Xterm To determine if xterm is installed on your computer, simply open a terminal window and type: xterm You should see an xterm window similar to the one below appear. If an xterm window does not appear, then you will need to install xterm. Installing Xterm For Raspberry Pi or Debian Based Linux In a terminal window type: sudo apt-get install xterm Installing Xterm For Mac Please refer to these instructions. Launching Components To demonstrate the launcher's use, we will launch the monitor , the simple echo server , and command-line echo client . All three were installed as executable components in a previous section of this document. Launch instructions are specified by creating a comma delimited text file called the launch descriptor file . Let's examine the launch descriptor file in detail. The Launch Descriptor File For each Python Banyan component we wish to launch, a corresponding launch description entry is placed in the launch descriptor file . Let's look at the contents of launch.csv , the comma delimited text file we will use to launch our components. command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,yes,local,no,yes,0 client,yes,local,no,no,0 The first line of the file contains the descriptor for each of the entry fields. command_string,spawn,topic,append_bp_address,auto_restart,wait command_string - this field is the command-line command used to execute the component. For this example, the launcher will start the monitor, the server, and client installed as executable modules, as described earlier . Note that the launcher will execute any command string we enter, so for example, if the file simple_echo_server.py is in the /home/bob_files/demo directory, we could specify the command as python /home/bob_files/demo/simple_echo_server.py,yes,local,no,yes,0 spawn - this field determines if the command will be executed in its own terminal window. If yes , a new window will be opened, and all component console output will appear in this window. If this field is set to no , the component will be spawned within the common launcher terminal window, and all console output will be placed in that window. There are screenshots below to demonstrate both cases. topic - if a component is to be run on the local machine, the topic must be set to local . If you wish to launch a component on a remote computer, then the topic must be set to something other than local . Note that the topic mentioned here is for the launcher's purposes and does not affect the application. Remote launching will be demonstrated in the Banyan Launch Client section . append_bp_address - this field is used mainly when launching components on a remote computer. If set to yes , the backplane IP address is appended to the command string with a -b option . The address is the IP address of the local computer. For example, if the backplane IP address is used is 192.168.1.100, the descriptor entry for the client component was set as follows: client,yes,remote1,yes,no,0 The command string sent to the remote computer would be: client -b 192.168.1.100 When the component is launched on the remote computer, it will automatically connect to the backplane. The -b option is used, assuming that the component was built using command-line options . auto_restart - if this field is set to yes , and the component crashes, it will automatically be restarted. wait - this is the time in seconds to wait before executing the next line in the script. The Banyan Launch Server The Banyan Launch Server ( bls ) is the name of the Banyan application that reads the Launch Descriptor file and launches the components specified by that file. The Banyan Launch Server is automatically installed as an executable when you installed Python Banyan. When invoking bls, if no launch descriptor file is specified using the -f command-line option, then bls will assume that a file called launch.csv is being used. Make sure you have a copy of launch.csv in your current working directory. Let's execute bls: We see a standard Banyan header, followed by a list of the components launched with their process IDs(PID). The launch server first checks to see if a backplane is currently running and, if not, will launch one before proceeding. It then launches each of the components specified in the launch descriptor file. Because we specified spawn for each component, a terminal window is invoked for each component. If we modify launcher.csv to set the server's spawn parameter to no , then the server's output is displayed in the bls console window. command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,no,local,no,yes,0 client,yes,local,no,no,0 The Auto-Restart Feature We specified auto-restart for the server in the launch descriptor file. Let's close the server window opened by bls and see what happens. When bls detects that the server process died, it indicates this in the bls console and then relaunches the server. A new PID is generated for the relaunch. If we kill the client, which does not have auto restart enabled, then we see the \"DIED\" notification. The Log File Anytime a process dies, it is not only noted on the screen, but an entry is placed in the banyan log file. The log file, called banyan_launcher.log, is automatically generated and placed in the user's home directory. The Banyan Launch Client The Banyan Launch Client ( blc ) is invoked on the remote computer to launch components on the remote computer with a command on the local computer. To demonstrate how to launch components remotely, we will distribute the components, as shown below: The Ubuntu computer will run bls and the backplane. Its IP address is 192.168.2.190 The Windows 10 computer will run blc and the client. Its IP address is 192.168.2.180 The Raspberry Pi computer will run blc and the server. Its IP address is 192.168.2.189 All we need to do is install the components on their respective computers and modify the launch configuration file. Then we start bls, in the case of this example, on the Ubuntu computer and blc on the remote computers, Windows 10, and the Raspberry Pi. NOTE: The configuration file only resides on the computer that runs bls . It will send all the launch information to the remote computers. The remote computers will then manage the applications, including auto-restart if specified. Modified Launch Descriptor For Remote Launching command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,yes,rpi_launch,yes,yes,0 client,yes,windows_launch,yes,no,0 The lines for the server and client have been modified to set the append_bp_address field to yes. Also, a unique topic string is created for each remote computer. For the echo server that will run on the Raspberry Pi, the topic string rpi_launch was chosen, and for the Windows machine running the echo client, windows_launch was chosen. Invoking The Banyan Launch Client Ensure that you have installed Python Banyan on your computer, which will automatically install the Banyan launcher programs. The blc application requires 2 command-line arguments to be supplied on the command-line. If the required arguments are not supplied, then blc will exit with an error message. The first required command-line argument is the application's backplane IP address. The second required field is the topic string that the remote computer subscribes to receive its launch instructions. For the Windows machine, blc is started with the following command: blc -b 192.168.2.190 -t windows_launch And for the Raspberry Pi: blc -b 192.168.2.190 -t rpi_launch You may start bls and the blc instances in any order. When bls starts, it will publish Banyan messages with the topics specified in the Launch Configuration File. The payload will contain the details of the launch for the component. Using the monitor, we can capture the messages being sent by bls, as shown below. After starting bls, we see the following: The backplane and monitor have been started on the local computer. We next start blc on the Raspberry Pi computer and see the following: The Raspberry Pi is awaiting the launch message from bls . When we start blc on the Windows computer, we see a similar screen: When the launch messages are received on the remote computers, we see the following: After blc launches a program on the remote computer, the program's name and process ID (PID), assigned by the remote machine, are displayed. The local instance of bls reflects the handshake between the local and remote computers: The PIDs used by the remote computers are shown on the screen. Killing The Application The Banyan Launch Kill ( blk ) utility allows you to kill all the local and remote components by issuing a command on the local computer. The blk utility is installed automatically when python-banyan. To use blk, open a terminal or command window and type: blk When we do this, we see the following on the local computer and remote computers, showing that all processes were killed successfully. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 8  - Using the Banyan Launcher"},{"location":"example8/#the-python-banyan-launcher","text":"Launching a Banyan application often involves launching multiple individual Banyan components. The Python Banyan launcher simplifies the launch process by allowing you to start all the components from a single console command. This source code for the Banyan launcher may be found on GitHub. NOTE: For Linux, Mac, and Raspberry PI users, the launcher requires xterm to be installed on your system. Xterm is not required for Windows, so Windows users can skip to Launching Components.","title":"The Python Banyan Launcher"},{"location":"example8/#testing-for-xterm","text":"To determine if xterm is installed on your computer, simply open a terminal window and type: xterm You should see an xterm window similar to the one below appear. If an xterm window does not appear, then you will need to install xterm.","title":"Testing For Xterm"},{"location":"example8/#installing-xterm-for-raspberry-pi-or-debian-based-linux","text":"In a terminal window type: sudo apt-get install xterm","title":"Installing Xterm For Raspberry Pi or Debian Based Linux"},{"location":"example8/#installing-xterm-for-mac","text":"Please refer to these instructions.","title":"Installing Xterm For Mac"},{"location":"example8/#launching-components","text":"To demonstrate the launcher's use, we will launch the monitor , the simple echo server , and command-line echo client . All three were installed as executable components in a previous section of this document. Launch instructions are specified by creating a comma delimited text file called the launch descriptor file . Let's examine the launch descriptor file in detail.","title":"Launching Components"},{"location":"example8/#the-launch-descriptor-file","text":"For each Python Banyan component we wish to launch, a corresponding launch description entry is placed in the launch descriptor file . Let's look at the contents of launch.csv , the comma delimited text file we will use to launch our components. command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,yes,local,no,yes,0 client,yes,local,no,no,0 The first line of the file contains the descriptor for each of the entry fields. command_string,spawn,topic,append_bp_address,auto_restart,wait command_string - this field is the command-line command used to execute the component. For this example, the launcher will start the monitor, the server, and client installed as executable modules, as described earlier . Note that the launcher will execute any command string we enter, so for example, if the file simple_echo_server.py is in the /home/bob_files/demo directory, we could specify the command as python /home/bob_files/demo/simple_echo_server.py,yes,local,no,yes,0 spawn - this field determines if the command will be executed in its own terminal window. If yes , a new window will be opened, and all component console output will appear in this window. If this field is set to no , the component will be spawned within the common launcher terminal window, and all console output will be placed in that window. There are screenshots below to demonstrate both cases. topic - if a component is to be run on the local machine, the topic must be set to local . If you wish to launch a component on a remote computer, then the topic must be set to something other than local . Note that the topic mentioned here is for the launcher's purposes and does not affect the application. Remote launching will be demonstrated in the Banyan Launch Client section . append_bp_address - this field is used mainly when launching components on a remote computer. If set to yes , the backplane IP address is appended to the command string with a -b option . The address is the IP address of the local computer. For example, if the backplane IP address is used is 192.168.1.100, the descriptor entry for the client component was set as follows: client,yes,remote1,yes,no,0 The command string sent to the remote computer would be: client -b 192.168.1.100 When the component is launched on the remote computer, it will automatically connect to the backplane. The -b option is used, assuming that the component was built using command-line options . auto_restart - if this field is set to yes , and the component crashes, it will automatically be restarted. wait - this is the time in seconds to wait before executing the next line in the script.","title":"The Launch Descriptor File"},{"location":"example8/#the-banyan-launch-server","text":"The Banyan Launch Server ( bls ) is the name of the Banyan application that reads the Launch Descriptor file and launches the components specified by that file. The Banyan Launch Server is automatically installed as an executable when you installed Python Banyan. When invoking bls, if no launch descriptor file is specified using the -f command-line option, then bls will assume that a file called launch.csv is being used. Make sure you have a copy of launch.csv in your current working directory. Let's execute bls: We see a standard Banyan header, followed by a list of the components launched with their process IDs(PID). The launch server first checks to see if a backplane is currently running and, if not, will launch one before proceeding. It then launches each of the components specified in the launch descriptor file. Because we specified spawn for each component, a terminal window is invoked for each component. If we modify launcher.csv to set the server's spawn parameter to no , then the server's output is displayed in the bls console window. command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,no,local,no,yes,0 client,yes,local,no,no,0","title":"The Banyan Launch Server"},{"location":"example8/#the-auto-restart-feature","text":"We specified auto-restart for the server in the launch descriptor file. Let's close the server window opened by bls and see what happens. When bls detects that the server process died, it indicates this in the bls console and then relaunches the server. A new PID is generated for the relaunch. If we kill the client, which does not have auto restart enabled, then we see the \"DIED\" notification.","title":"The Auto-Restart Feature"},{"location":"example8/#the-log-file","text":"Anytime a process dies, it is not only noted on the screen, but an entry is placed in the banyan log file. The log file, called banyan_launcher.log, is automatically generated and placed in the user's home directory.","title":"The Log File"},{"location":"example8/#the-banyan-launch-client","text":"The Banyan Launch Client ( blc ) is invoked on the remote computer to launch components on the remote computer with a command on the local computer. To demonstrate how to launch components remotely, we will distribute the components, as shown below: The Ubuntu computer will run bls and the backplane. Its IP address is 192.168.2.190 The Windows 10 computer will run blc and the client. Its IP address is 192.168.2.180 The Raspberry Pi computer will run blc and the server. Its IP address is 192.168.2.189 All we need to do is install the components on their respective computers and modify the launch configuration file. Then we start bls, in the case of this example, on the Ubuntu computer and blc on the remote computers, Windows 10, and the Raspberry Pi. NOTE: The configuration file only resides on the computer that runs bls . It will send all the launch information to the remote computers. The remote computers will then manage the applications, including auto-restart if specified.","title":"The Banyan Launch Client"},{"location":"example8/#modified-launch-descriptor-for-remote-launching","text":"command_string,spawn,topic,append_bp_address,auto_restart,wait monitor,yes,local,no,no,0 server,yes,rpi_launch,yes,yes,0 client,yes,windows_launch,yes,no,0 The lines for the server and client have been modified to set the append_bp_address field to yes. Also, a unique topic string is created for each remote computer. For the echo server that will run on the Raspberry Pi, the topic string rpi_launch was chosen, and for the Windows machine running the echo client, windows_launch was chosen.","title":"Modified Launch Descriptor For Remote Launching"},{"location":"example8/#invoking-the-banyan-launch-client","text":"Ensure that you have installed Python Banyan on your computer, which will automatically install the Banyan launcher programs. The blc application requires 2 command-line arguments to be supplied on the command-line. If the required arguments are not supplied, then blc will exit with an error message. The first required command-line argument is the application's backplane IP address. The second required field is the topic string that the remote computer subscribes to receive its launch instructions. For the Windows machine, blc is started with the following command: blc -b 192.168.2.190 -t windows_launch And for the Raspberry Pi: blc -b 192.168.2.190 -t rpi_launch You may start bls and the blc instances in any order. When bls starts, it will publish Banyan messages with the topics specified in the Launch Configuration File. The payload will contain the details of the launch for the component. Using the monitor, we can capture the messages being sent by bls, as shown below. After starting bls, we see the following: The backplane and monitor have been started on the local computer. We next start blc on the Raspberry Pi computer and see the following: The Raspberry Pi is awaiting the launch message from bls . When we start blc on the Windows computer, we see a similar screen: When the launch messages are received on the remote computers, we see the following: After blc launches a program on the remote computer, the program's name and process ID (PID), assigned by the remote machine, are displayed. The local instance of bls reflects the handshake between the local and remote computers: The PIDs used by the remote computers are shown on the screen.","title":"Invoking The Banyan Launch Client"},{"location":"example8/#killing-the-application","text":"The Banyan Launch Kill ( blk ) utility allows you to kill all the local and remote components by issuing a command on the local computer. The blk utility is installed automatically when python-banyan. To use blk, open a terminal or command window and type: blk When we do this, we see the following on the local computer and remote computers, showing that all processes were killed successfully. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Killing The Application"},{"location":"example9/","text":"Multi-Backplane Applications For the vast majority of Banyan applications, a single backplane is all that is needed to handle all the application's messaging needs. When using a single backplane configuration, there is no need to manually perform message routing, since all components automatically connect to a common backplane. However, there are occasions where you might like to design your component so that it can communicate with more than one backplane. Some possible scenarios for this configuration would be to provide message load balancing or a better separation of operational concerns. To support these types of configurations, a new base class, BanyanBaseMulti , is required. The Banyan Base Multi Base Class In many ways, the BanyanBaseMulti base class is similar to the BanyanBase class, but there is one significant difference. A BanyanBaseMulti component requires that a backplane routing table be provided at initialization. This table is known as the routing specification file . Note: BanyanBase and BanyanBaseMulti components may communicate with each other without restriction. No coding changes or message format changes are required. The Routing Specification File For BanyanBaseMulti Every BanyanBaseMulti component requires access to a unique comma-delimited routing specification file. The name and path of this file is a required component input parameter. Let's explore the format of the specification file. The header and first line of a routing specification file is: backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port The backplane_name field is a unique ID string given to each of the connected backplanes. The IDs are used to de-reference publisher and subscriber connections. The ip_address field is the IP address of the given backplane. Backplanes that share a single IP address are differentiated by having unique subscriber and publisher ports. The subscriber_port specifies the subscriber port for the given backplane. The subscriber_topic is an optional Python list of subscriber topics established at the instantiation of the component. If a single topic is to be specified, it still must be entered as a Python list. IMPORTANT NOTE: Even though the topics are strings, the individual topic strings must not be enclosed in quotes. Instead, the whole list, including the brackets, is enclosed in quotes. Also, there must not be any spaces after the commas. For example, if the topics are start , and finish , the subscriber_topic field is specified as: \"[start,finish]\" The publisher_port specifies the publisher port for the given backplane. Here is sample of a routing specification file for a component that connects to 5 backplanes. backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port BP1,192.168.2.194,43127,\"[reply]\",43126 BP2,192.168.2.194,43125,\"[reply]\",43124 BP3,192.168.2.177,43125,\"[]\",43124 BP4,192.168.2.199,43125,\"[run_motors,light_leds]\", BP5,192.168.2.133,,\"[run_motors,light_leds]\",43124 Let's launch a sample BanyanBaseMulti component called MultiDriver . When the component initializes, it will read the routing specification file, and print out its interpretation of that file as its console header. Let's look at that console header. Using Backplane Descriptor File: multi_driver_spec.csv ************************************************************ MultiDriver using BP1 Black plane at IP Address: 192.168.2.194 Subscriber Port = 43127 Subscribed to topic: reply Publisher Port = 43126 MultiDriver using BP2 Black plane at IP Address: 192.168.2.194 Subscriber Port = 43125 Subscribed to topic: reply Publisher Port = 43124 MultiDriver using BP3 Black plane at IP Address: 192.168.2.177 Subscriber Port = 43125 Subscribed to topic: Publisher Port = 43124 MultiDriver using BP4 Black plane at IP Address: 192.168.2.199 Subscriber Port = 43125 Subscribed to topic: run_motors Subscribed to topic: light_leds Publisher Port = None Specified MultiDriver using BP5 Black plane at IP Address: 192.168.2.133 Subscriber Port = None Specified Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Notice that for BP1 and BP2, all fields are specified. Since they share a common IP address, their ports have different values. For BP3, no topic list was specified, and therefore the \"Subscribed to topic\" for BPI3 shows no topics. BP4 specifies multiple subscriber topics and a subscriber port, but no publisher port. This is a valid case when the component does not publish any messages. BP5 has no subscriber port specified and no topics specified. Because there is no subscriber port, topics are not listed. For BP5, this component acts only as a publisher. A simple working example is discussed below if you would like to try using BanyanBaseMulti. The Python Banyan Multi Base Class Code In Detail Lines 1 through 66 should seem very similar to those for the BanyanBase base class. 1 \"\"\" 2 banyan_base_multi.py 3 4 Copyright (c) 2016 - 2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 from __future__ import unicode_literals 21 22 # Use argparse and signal if you wish to implement the argparse 23 # code located at the bottom of this file 24 # import argparse 25 # import signal 26 27 import csv 28 import sys 29 import time 30 import itertools 31 import msgpack 32 import msgpack_numpy as m 33 import umsgpack 34 import zmq 35 import os 36 37 38 # noinspection PyMethodMayBeStatic 39 class BanyanBaseMulti(object): 40 \"\"\" 41 42 This is the base class for Python Banyan components that wish to connect to multiple back planes. 43 It requires the user to create a .csv descriptor file to describe the back planes and their 44 addresses/ports and subscription topics. 45 46 The .csv file has the following format. This line must be the first line in the file: 47 48 backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port 49 50 backplane_name: a unique identifier string for backplane - for informational purposes only 51 ip_address: IP address of the computer that the backplane is running on 52 subscriber_port: port number assigned to the backplane's subscriber port 53 subscriber_topic: this is an optional list of subscription topics 54 publisher_port: port number assigned to the backplane's publisher port 55 56 57 There should be an entry in this file for each backplane that the component needs to connect to. 58 59 This class encapsulates zeromq and message pack functionality. Its methods should be overridden by the user 60 in the derived class to meet the needs of the component. 61 62 To import into the derived class use: 63 64 from python_banyan.banyan_base_multi import BanyanBaseMulti 65 66 \"\"\" __init__ The __init__ method requires the name and path to a routing specification file. Similar to a BanyanBase component, it accepts a process name, a loop_time, and a flag to process numpy data. Lines 87 and 88 establish \"constants\" for the socket types. This is used in the find_socket method discussed below. Lines 94 and 95 verify that a routing specification file can be found. Lines 100 through 108 establish instance variables used by the class. Lines 118 through 173, read and validate the routing specification file and print out the component's \"header\" data to the console. 68 def __init__(self, back_plane_csv_file=None, process_name='None', 69 loop_time=.1, numpy=False, connect_time=0.3): 70 \"\"\" 71 The __init__ method sets up all the ZeroMQ \"plumbing\" 72 73 :param back_plane_csv_file: full path to .csv file with backplane descriptors 74 75 :param process_name: identifier for your component printed at startup on the console 76 77 :param loop_time: receive loop sleep time 78 79 :param numpy: Set true if you wish to include numpy matrices in your messages 80 81 :param connect_time: a short delay to allow the component to connect to the Backplane 82 83 :return: 84 \"\"\" 85 86 # socket type - used for calls to find_socket 87 self.SUB_SOCK = 0 88 self.PUB_SOCK = 1 89 90 if back_plane_csv_file is None: 91 raise ValueError('You must specify a valid .csv backplane descriptor file') 92 93 # file specified, make sure it exists 94 if not os.path.isfile(back_plane_csv_file): 95 raise ValueError(\"Can't find backplane configuration file\") 96 97 if process_name == 'None': 98 print('Warning: No Process Name Was Specified') 99 100 self.numpy = numpy 101 102 self.connect_time = connect_time 103 104 # if using numpy apply the msgpack_numpy monkey patch 105 if numpy: 106 m.patch() 107 108 self.loop_time = loop_time 109 110 # get a zeromq context 111 self.my_context = zmq.Context() 112 113 # a list of dictionaries describing connections to the back planes 114 self.backplane_table = [] 115 116 print(\"\\nUsing Backplane Descriptor File: \", back_plane_csv_file) 117 118 with open(back_plane_csv_file) as csvfile: 119 reader = csv.DictReader(csvfile) 120 print('\\n************************************************************\\n') 121 for row in reader: 122 # make sure backplane name is unique 123 if any(d['backplane_name'] == row['backplane_name'] for d in self.backplane_table): 124 raise RuntimeError('Duplicate Back Plane Name - check your .csv file') 125 126 print(process_name + ' using ' + row['backplane_name'] + ' Black plane at IP Address: ' + 127 row['ip_address']) 128 129 # setup a publisher and subscriber for each backplane 130 subscriber = None 131 if row['subscriber_port']: 132 subscriber = self.my_context.socket(zmq.SUB) 133 connect_string = \"tcp://\" + row['ip_address'] + ':' + row['subscriber_port'] 134 subscriber.connect(connect_string) 135 136 publisher = None 137 if row['publisher_port']: 138 publisher = self.my_context.socket(zmq.PUB) 139 connect_string = \"tcp://\" + row['ip_address'] + ':' + row['publisher_port'] 140 publisher.connect(connect_string) 141 142 # get topics and subscribe to them 143 # test that topic string has a leading and trailing [] 144 if row['subscriber_port']: 145 print(' Subscriber Port = ' + row['subscriber_port']) 146 topic_list = row['subscriber_topic'] 147 if '[' not in topic_list: 148 raise RuntimeError('Topic field must begin with \"[\" and end with \"]\" ') 149 if ']' not in topic_list: 150 raise RuntimeError('Topic field must begin with \"[\" and end with \"]\" ') 151 152 # make sure that the topic string does not contain a space character 153 if ' ' in topic_list: 154 raise RuntimeError('Topics may not contain a space character') 155 156 topic_list = topic_list[1:-1].split(',') 157 158 # subscribe to topics in list 159 for t in topic_list: 160 print(' Subscribed to topic: ' + t) 161 self.set_subscriber_topic(t, subscriber) 162 else: 163 print(' Subscriber Port = None Specified') 164 165 if row['publisher_port']: 166 print(' Publisher Port = ' + row['publisher_port']) 167 else: 168 print(' Publisher Port = None Specified') 169 170 # update backplane table with new entry 171 self.backplane_table.append( 172 {'backplane_name': row['backplane_name'], 'subscriber': subscriber, 173 'publisher': publisher}) 174 175 # wait for the last Backplane TCP connection 176 time.sleep(self.connect_time) 177 178 print() 179 print('Loop Time = ' + str(loop_time) + ' seconds\\n') 180 print('************************************************************') find_socket The find_socket method accepts a backplane name specified in the routing specification table and a socket type (publisher or subscriber) as input parameters. It returns a socket connection for publishing messages to or receiving messages from the specified backplane. 182 def find_socket(self, backplane, socket_type): 183 \"\"\" 184 Find a publisher or subscriber in the backplane table and return a ZMQ socket reference 185 186 :param backplane: backplane name entry in table 187 188 :param socket_type: publisher or subscriber 189 190 :return: socket reference or None 191 \"\"\" 192 valid_socket_types = [self.PUB_SOCK, self.SUB_SOCK] 193 194 if socket_type in valid_socket_types: 195 try: 196 entry = next(item for item in self.backplane_table if item.get(\"backplane_name\") == backplane) 197 if socket_type == self.PUB_SOCK: 198 rval = entry['publisher'] 199 else: 200 rval = entry['subscriber'] 201 return rval 202 203 except StopIteration: 204 raise StopIteration(backplane + ' not found in table.') 205 else: 206 raise ValueError(socket_type + ' is an illegal socket_type') set_subscriber_topic The set_subscriber_topic method associates a subscription topic with the given subscriber_socket connection. 208 def set_subscriber_topic(self, topic, subscriber_socket): 209 \"\"\" 210 This method sets a subscriber topic. 211 212 You can subscribe to multiple topics by calling this method for 213 each topic. 214 215 :param topic: A topic string 216 217 :param subscriber_socket: subscriber socket 218 219 :return: 220 \"\"\" 221 if sys.version_info[0] < 3: 222 try: 223 topic = topic.encode() 224 except AttributeError: 225 raise TypeError('Publish topic must be python_banyan string', 'topic') 226 if not type(topic) is str: 227 raise TypeError('Subscriber topic must be python_banyan string') 228 229 if subscriber_socket: 230 subscriber_socket.setsockopt(zmq.SUBSCRIBE, topic.encode()) 231 232 else: 233 raise ValueError('set_subscriber_topic: socket is None') 234 unsubscribe_topic The unsubscribe_topic method allows one to unsubscribe from a topic for a backplane subscriber socket connection. 235 def unsubscribe_topic(self, topic, subscriber_socket): 236 \"\"\" 237 This method un-subscribes from a topic. 238 239 :param topic: A topic string 240 241 :param subscriber_socket: subscriber socket 242 243 :return: 244 \"\"\" 245 if sys.version_info[0] < 3: 246 try: 247 topic = topic.encode() 248 except AttributeError: 249 raise TypeError('Publish topic must be python_banyan string', 'topic') 250 if not type(topic) is str: 251 raise TypeError('Subscriber topic must be python_banyan string') 252 253 if subscriber_socket: 254 subscriber_socket.unsubscribe(topic.encode()) 255 256 else: 257 raise ValueError('set_subscriber_topic: socket is None') publish_payload The publish_payload method is very similar to that for BanyanBase. IMPORTANT NOTE: If the topic string is \"BROADCAST,\" then the message is published to all backplanes containing publisher ports specified in the routing specification file. 259 def publish_payload(self, payload, publisher_socket, topic=''): 260 \"\"\" 261 This method will publish a python_banyan payload and its associated topic 262 263 :param payload: Protocol message to be published 264 265 :param publisher_socket: Publisher socket - handle to socket or \"BROADCAST\" to send to 266 all connected publisher sockets 267 268 :param topic: A string value for message topic 269 270 :return: 271 \"\"\" 272 if sys.version_info[0] < 3: 273 try: 274 topic = topic.encode() 275 except AttributeError: 276 raise TypeError('Publish topic must be python_banyan string', 'topic') 277 if not type(topic) is str: 278 raise TypeError('Publish topic must be python_banyan string', 'topic') 279 280 # create python_banyan message pack payload 281 if self.numpy: 282 message = msgpack.packb(payload, default=m.encode) 283 else: 284 message = umsgpack.packb(payload) 285 286 pub_envelope = topic.encode() 287 if publisher_socket == \"BROADCAST\": 288 for element in self.backplane_table: 289 if element['publisher']: 290 element['publisher'].send_multipart([pub_envelope, message]) 291 else: 292 293 if publisher_socket: 294 publisher_socket.send_multipart([pub_envelope, message]) 295 else: 296 raise ValueError('Invalid publisher socket') receive_loop The receive_loop cycles through all of the backplane subscriber sockets to see if any messages need to be processed. If so, it calls the incoming_message_processing method. 298 def receive_loop(self): 299 \"\"\" 300 This is the receive loop for zmq messages. 301 302 This method may be overwritten to meet the needs 303 of the application before handling received messages. 304 305 :return: 306 \"\"\" 307 for element in itertools.cycle(self.backplane_table): 308 if element['subscriber']: 309 try: 310 data = element['subscriber'].recv_multipart(zmq.NOBLOCK) 311 if self.numpy: 312 payload = msgpack.unpackb(data[1], object_hook=m.decode) 313 self.incoming_message_processing(data[0].decode(), payload) 314 else: 315 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 316 except zmq.error.Again: 317 try: 318 time.sleep(self.loop_time) 319 except KeyboardInterrupt: 320 self.clean_up() 321 sys.exit(0) 322 except AttributeError: 323 raise 324 incoming_message_processing This method needs to be overridden to handle the incoming messages. 325 def incoming_message_processing(self, topic, payload): 326 \"\"\" 327 Override this method with a custom python_banyan message processor for subscribed messages 328 329 :param topic: Message Topic string 330 331 :param payload: Message Data 332 333 :return: 334 \"\"\" 335 print('this method should be overwritten in the child class', topic, payload) clean_up The clean_up method iterates through all the backplanes and closes their connections. 337 def clean_up(self): 338 \"\"\" 339 Clean up before exiting - override if additional cleanup is necessary 340 341 :return: 342 \"\"\" 343 for element in self.backplane_table: 344 if element['publisher']: 345 element['publisher'].close() 346 if element['subscriber']: 347 element['subscriber'].close() 348 self.my_context.term() A Simple Working Example This section provides a simple demonstration of a Banyan application that makes use of the BanyanBaseMulti base class. For this example, 2 backplanes are invoked, each on a different computer. The example can be easily modified to run both backplanes on a single computer by adjusting the routing specification file's values. In addition to the two backplanes, the application consists of three Banyan components. The first component is a reuse of echo_cmdline_client.py , and it resides on computer1. The second component, multi_echo_server.py derived from BanyanBaseMulti The third component, notifier.py , derived from BanyanBase, resides on computer2. Backplane1 resides on computer1, and backplane2 resides on computer2. The client publishes messages to backplane1, and the server echoes these messages back within backplane1. As each message is received by the server, it tests to see if the message number is 0. Message number 0 signals that this is the final message. If the message number is 0, the server then publishes a \"notifier\" message routed to backplane2. The Notifier The code for the Notifier is extremely simple. It registers to receive messages with a 'notice' topic and when a message is received, prints 'Notification Received': 1 \"\"\" 2 notifier.py 3 4 Copyright (c) 2018 - 2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 import time 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class Notifier(BanyanBase): 27 \"\"\" 28 This class is a simple Banyan echo server 29 30 \"\"\" 31 32 def __init__(self, ): 33 34 # initialize the parent 35 super(Notifier, self).__init__(process_name='Notifier') 36 37 # allow time for base class to initialize publisher/subscriber connections 38 time.sleep(.3) 39 40 # subscribe to receive 'echo' messages from the client 41 self.set_subscriber_topic('notice') 42 43 # wait for messages to arrive 44 try: 45 self.receive_loop() 46 except KeyboardInterrupt: 47 self.clean_up() 48 sys.exit(0) 49 50 def incoming_message_processing(self, topic, payload): 51 \"\"\" 52 Process incoming messages from the client 53 :param topic: message topic 54 :param payload: message payload 55 :return: 56 \"\"\" 57 print('Notification Received!') 58 59 60 def notifier(): 61 Notifier() 62 63 64 if __name__ == '__main__': 65 notifier() The Echo Client We are reusing the echo_cmdline_client unmodified. The MultiEchoServer The server is derived from BanyanBaseMulti. Let us begin by examining its associated routing specification file . Routing Specification File backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port BP1,192.168.2.190,43125,\"[echo]\",43124 BP2,192.168.2.180,43125,\"[]\",43124 BP1 is the backplane that is running on 192.168.2.190 and the server subscribes to the echo topic on backplane1. BP2 is the backplane that is running 192.168.2.180, and the server publishes notifier messages to backplane2. The MultiEchoServer Code Lines 39 and 42 establish the sockets for each of the backplanes. It uses the find_socket method to retrieve the publisher sockets for the backplanes. It uses the names of the backplanes from the routing specification file to retrieve the sockets. Line 59 echoes the incoming messages from the client. If the message number is 0, then line 62 publishes a notice message to backplane2. 1 \"\"\" 2 multi_echo_server.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 import time 22 23 from python_banyan.banyan_base_multi import BanyanBaseMulti 24 25 26 class MultiEchoServer(BanyanBaseMulti): 27 \"\"\" 28 This class is a simple Banyan echo server 29 30 \"\"\" 31 32 def __init__(self, ): 33 34 # initialize the parent 35 super(MultiEchoServer, self).__init__(back_plane_csv_file='spec.csv', process_name='MultiDriver') 36 37 # find the sockets in the table for the 2 backplanes 38 # socket a is to reply to messages from the client 39 self.socket_a = self.find_socket(\"BP1\", self.PUB_SOCK) 40 41 # socket b is to send the notification messages 42 self.socket_b = self.find_socket(\"BP2\", self.PUB_SOCK) 43 44 # wait for messages to arrive 45 try: 46 self.receive_loop() 47 except KeyboardInterrupt: 48 self.clean_up() 49 sys.exit(0) 50 51 def incoming_message_processing(self, topic, payload): 52 \"\"\" 53 Process incoming messages from the client 54 :param topic: message topic 55 :param payload: message payload 56 :return: 57 \"\"\" 58 if topic == 'echo': 59 self.publish_payload(payload, self.socket_a, 'reply') 60 print('Message number:', payload['message_number']) 61 if payload['message_number'] == 0: 62 self.publish_payload({'message': 'got it', 'id': 'b'}, 63 self.socket_b, 'notice') 64 65 66 def multi_echo_server(): 67 MultiEchoServer() 68 69 70 if __name__ == '__main__': 71 multi_echo_server() Running The Example First, we start a backplane, a monitor and multi_echo_server.py on 192.168.2.190. The next step is to start a backplane notifier.py on 192.168.2.180. Finally, we start the echo client on 192.168.2.190. It sends its 10 messages. When the server receives message number 0, it sends its notification message. Looking at the monitor on 192.168.2.190, we see: And the monitor on 192.168.2.180 shows: Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Tutorial 9  - Connecting To Multiple Backplanes"},{"location":"example9/#multi-backplane-applications","text":"For the vast majority of Banyan applications, a single backplane is all that is needed to handle all the application's messaging needs. When using a single backplane configuration, there is no need to manually perform message routing, since all components automatically connect to a common backplane. However, there are occasions where you might like to design your component so that it can communicate with more than one backplane. Some possible scenarios for this configuration would be to provide message load balancing or a better separation of operational concerns. To support these types of configurations, a new base class, BanyanBaseMulti , is required.","title":"Multi-Backplane Applications"},{"location":"example9/#the-banyan-base-multi-base-class","text":"In many ways, the BanyanBaseMulti base class is similar to the BanyanBase class, but there is one significant difference. A BanyanBaseMulti component requires that a backplane routing table be provided at initialization. This table is known as the routing specification file . Note: BanyanBase and BanyanBaseMulti components may communicate with each other without restriction. No coding changes or message format changes are required.","title":"The Banyan Base Multi Base Class"},{"location":"example9/#the-routing-specification-file-for-banyanbasemulti","text":"Every BanyanBaseMulti component requires access to a unique comma-delimited routing specification file. The name and path of this file is a required component input parameter. Let's explore the format of the specification file. The header and first line of a routing specification file is: backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port The backplane_name field is a unique ID string given to each of the connected backplanes. The IDs are used to de-reference publisher and subscriber connections. The ip_address field is the IP address of the given backplane. Backplanes that share a single IP address are differentiated by having unique subscriber and publisher ports. The subscriber_port specifies the subscriber port for the given backplane. The subscriber_topic is an optional Python list of subscriber topics established at the instantiation of the component. If a single topic is to be specified, it still must be entered as a Python list. IMPORTANT NOTE: Even though the topics are strings, the individual topic strings must not be enclosed in quotes. Instead, the whole list, including the brackets, is enclosed in quotes. Also, there must not be any spaces after the commas. For example, if the topics are start , and finish , the subscriber_topic field is specified as: \"[start,finish]\" The publisher_port specifies the publisher port for the given backplane. Here is sample of a routing specification file for a component that connects to 5 backplanes. backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port BP1,192.168.2.194,43127,\"[reply]\",43126 BP2,192.168.2.194,43125,\"[reply]\",43124 BP3,192.168.2.177,43125,\"[]\",43124 BP4,192.168.2.199,43125,\"[run_motors,light_leds]\", BP5,192.168.2.133,,\"[run_motors,light_leds]\",43124 Let's launch a sample BanyanBaseMulti component called MultiDriver . When the component initializes, it will read the routing specification file, and print out its interpretation of that file as its console header. Let's look at that console header. Using Backplane Descriptor File: multi_driver_spec.csv ************************************************************ MultiDriver using BP1 Black plane at IP Address: 192.168.2.194 Subscriber Port = 43127 Subscribed to topic: reply Publisher Port = 43126 MultiDriver using BP2 Black plane at IP Address: 192.168.2.194 Subscriber Port = 43125 Subscribed to topic: reply Publisher Port = 43124 MultiDriver using BP3 Black plane at IP Address: 192.168.2.177 Subscriber Port = 43125 Subscribed to topic: Publisher Port = 43124 MultiDriver using BP4 Black plane at IP Address: 192.168.2.199 Subscriber Port = 43125 Subscribed to topic: run_motors Subscribed to topic: light_leds Publisher Port = None Specified MultiDriver using BP5 Black plane at IP Address: 192.168.2.133 Subscriber Port = None Specified Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ Notice that for BP1 and BP2, all fields are specified. Since they share a common IP address, their ports have different values. For BP3, no topic list was specified, and therefore the \"Subscribed to topic\" for BPI3 shows no topics. BP4 specifies multiple subscriber topics and a subscriber port, but no publisher port. This is a valid case when the component does not publish any messages. BP5 has no subscriber port specified and no topics specified. Because there is no subscriber port, topics are not listed. For BP5, this component acts only as a publisher. A simple working example is discussed below if you would like to try using BanyanBaseMulti.","title":"The Routing Specification File For BanyanBaseMulti"},{"location":"example9/#the-python-banyan-multi-base-class-code-in-detail","text":"Lines 1 through 66 should seem very similar to those for the BanyanBase base class. 1 \"\"\" 2 banyan_base_multi.py 3 4 Copyright (c) 2016 - 2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 from __future__ import unicode_literals 21 22 # Use argparse and signal if you wish to implement the argparse 23 # code located at the bottom of this file 24 # import argparse 25 # import signal 26 27 import csv 28 import sys 29 import time 30 import itertools 31 import msgpack 32 import msgpack_numpy as m 33 import umsgpack 34 import zmq 35 import os 36 37 38 # noinspection PyMethodMayBeStatic 39 class BanyanBaseMulti(object): 40 \"\"\" 41 42 This is the base class for Python Banyan components that wish to connect to multiple back planes. 43 It requires the user to create a .csv descriptor file to describe the back planes and their 44 addresses/ports and subscription topics. 45 46 The .csv file has the following format. This line must be the first line in the file: 47 48 backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port 49 50 backplane_name: a unique identifier string for backplane - for informational purposes only 51 ip_address: IP address of the computer that the backplane is running on 52 subscriber_port: port number assigned to the backplane's subscriber port 53 subscriber_topic: this is an optional list of subscription topics 54 publisher_port: port number assigned to the backplane's publisher port 55 56 57 There should be an entry in this file for each backplane that the component needs to connect to. 58 59 This class encapsulates zeromq and message pack functionality. Its methods should be overridden by the user 60 in the derived class to meet the needs of the component. 61 62 To import into the derived class use: 63 64 from python_banyan.banyan_base_multi import BanyanBaseMulti 65 66 \"\"\"","title":"The Python Banyan Multi Base Class Code In Detail"},{"location":"example9/#__init__","text":"The __init__ method requires the name and path to a routing specification file. Similar to a BanyanBase component, it accepts a process name, a loop_time, and a flag to process numpy data. Lines 87 and 88 establish \"constants\" for the socket types. This is used in the find_socket method discussed below. Lines 94 and 95 verify that a routing specification file can be found. Lines 100 through 108 establish instance variables used by the class. Lines 118 through 173, read and validate the routing specification file and print out the component's \"header\" data to the console. 68 def __init__(self, back_plane_csv_file=None, process_name='None', 69 loop_time=.1, numpy=False, connect_time=0.3): 70 \"\"\" 71 The __init__ method sets up all the ZeroMQ \"plumbing\" 72 73 :param back_plane_csv_file: full path to .csv file with backplane descriptors 74 75 :param process_name: identifier for your component printed at startup on the console 76 77 :param loop_time: receive loop sleep time 78 79 :param numpy: Set true if you wish to include numpy matrices in your messages 80 81 :param connect_time: a short delay to allow the component to connect to the Backplane 82 83 :return: 84 \"\"\" 85 86 # socket type - used for calls to find_socket 87 self.SUB_SOCK = 0 88 self.PUB_SOCK = 1 89 90 if back_plane_csv_file is None: 91 raise ValueError('You must specify a valid .csv backplane descriptor file') 92 93 # file specified, make sure it exists 94 if not os.path.isfile(back_plane_csv_file): 95 raise ValueError(\"Can't find backplane configuration file\") 96 97 if process_name == 'None': 98 print('Warning: No Process Name Was Specified') 99 100 self.numpy = numpy 101 102 self.connect_time = connect_time 103 104 # if using numpy apply the msgpack_numpy monkey patch 105 if numpy: 106 m.patch() 107 108 self.loop_time = loop_time 109 110 # get a zeromq context 111 self.my_context = zmq.Context() 112 113 # a list of dictionaries describing connections to the back planes 114 self.backplane_table = [] 115 116 print(\"\\nUsing Backplane Descriptor File: \", back_plane_csv_file) 117 118 with open(back_plane_csv_file) as csvfile: 119 reader = csv.DictReader(csvfile) 120 print('\\n************************************************************\\n') 121 for row in reader: 122 # make sure backplane name is unique 123 if any(d['backplane_name'] == row['backplane_name'] for d in self.backplane_table): 124 raise RuntimeError('Duplicate Back Plane Name - check your .csv file') 125 126 print(process_name + ' using ' + row['backplane_name'] + ' Black plane at IP Address: ' + 127 row['ip_address']) 128 129 # setup a publisher and subscriber for each backplane 130 subscriber = None 131 if row['subscriber_port']: 132 subscriber = self.my_context.socket(zmq.SUB) 133 connect_string = \"tcp://\" + row['ip_address'] + ':' + row['subscriber_port'] 134 subscriber.connect(connect_string) 135 136 publisher = None 137 if row['publisher_port']: 138 publisher = self.my_context.socket(zmq.PUB) 139 connect_string = \"tcp://\" + row['ip_address'] + ':' + row['publisher_port'] 140 publisher.connect(connect_string) 141 142 # get topics and subscribe to them 143 # test that topic string has a leading and trailing [] 144 if row['subscriber_port']: 145 print(' Subscriber Port = ' + row['subscriber_port']) 146 topic_list = row['subscriber_topic'] 147 if '[' not in topic_list: 148 raise RuntimeError('Topic field must begin with \"[\" and end with \"]\" ') 149 if ']' not in topic_list: 150 raise RuntimeError('Topic field must begin with \"[\" and end with \"]\" ') 151 152 # make sure that the topic string does not contain a space character 153 if ' ' in topic_list: 154 raise RuntimeError('Topics may not contain a space character') 155 156 topic_list = topic_list[1:-1].split(',') 157 158 # subscribe to topics in list 159 for t in topic_list: 160 print(' Subscribed to topic: ' + t) 161 self.set_subscriber_topic(t, subscriber) 162 else: 163 print(' Subscriber Port = None Specified') 164 165 if row['publisher_port']: 166 print(' Publisher Port = ' + row['publisher_port']) 167 else: 168 print(' Publisher Port = None Specified') 169 170 # update backplane table with new entry 171 self.backplane_table.append( 172 {'backplane_name': row['backplane_name'], 'subscriber': subscriber, 173 'publisher': publisher}) 174 175 # wait for the last Backplane TCP connection 176 time.sleep(self.connect_time) 177 178 print() 179 print('Loop Time = ' + str(loop_time) + ' seconds\\n') 180 print('************************************************************')","title":"__init__"},{"location":"example9/#find_socket","text":"The find_socket method accepts a backplane name specified in the routing specification table and a socket type (publisher or subscriber) as input parameters. It returns a socket connection for publishing messages to or receiving messages from the specified backplane. 182 def find_socket(self, backplane, socket_type): 183 \"\"\" 184 Find a publisher or subscriber in the backplane table and return a ZMQ socket reference 185 186 :param backplane: backplane name entry in table 187 188 :param socket_type: publisher or subscriber 189 190 :return: socket reference or None 191 \"\"\" 192 valid_socket_types = [self.PUB_SOCK, self.SUB_SOCK] 193 194 if socket_type in valid_socket_types: 195 try: 196 entry = next(item for item in self.backplane_table if item.get(\"backplane_name\") == backplane) 197 if socket_type == self.PUB_SOCK: 198 rval = entry['publisher'] 199 else: 200 rval = entry['subscriber'] 201 return rval 202 203 except StopIteration: 204 raise StopIteration(backplane + ' not found in table.') 205 else: 206 raise ValueError(socket_type + ' is an illegal socket_type')","title":"find_socket"},{"location":"example9/#set_subscriber_topic","text":"The set_subscriber_topic method associates a subscription topic with the given subscriber_socket connection. 208 def set_subscriber_topic(self, topic, subscriber_socket): 209 \"\"\" 210 This method sets a subscriber topic. 211 212 You can subscribe to multiple topics by calling this method for 213 each topic. 214 215 :param topic: A topic string 216 217 :param subscriber_socket: subscriber socket 218 219 :return: 220 \"\"\" 221 if sys.version_info[0] < 3: 222 try: 223 topic = topic.encode() 224 except AttributeError: 225 raise TypeError('Publish topic must be python_banyan string', 'topic') 226 if not type(topic) is str: 227 raise TypeError('Subscriber topic must be python_banyan string') 228 229 if subscriber_socket: 230 subscriber_socket.setsockopt(zmq.SUBSCRIBE, topic.encode()) 231 232 else: 233 raise ValueError('set_subscriber_topic: socket is None') 234","title":"set_subscriber_topic"},{"location":"example9/#unsubscribe_topic","text":"The unsubscribe_topic method allows one to unsubscribe from a topic for a backplane subscriber socket connection. 235 def unsubscribe_topic(self, topic, subscriber_socket): 236 \"\"\" 237 This method un-subscribes from a topic. 238 239 :param topic: A topic string 240 241 :param subscriber_socket: subscriber socket 242 243 :return: 244 \"\"\" 245 if sys.version_info[0] < 3: 246 try: 247 topic = topic.encode() 248 except AttributeError: 249 raise TypeError('Publish topic must be python_banyan string', 'topic') 250 if not type(topic) is str: 251 raise TypeError('Subscriber topic must be python_banyan string') 252 253 if subscriber_socket: 254 subscriber_socket.unsubscribe(topic.encode()) 255 256 else: 257 raise ValueError('set_subscriber_topic: socket is None')","title":"unsubscribe_topic"},{"location":"example9/#publish_payload","text":"The publish_payload method is very similar to that for BanyanBase. IMPORTANT NOTE: If the topic string is \"BROADCAST,\" then the message is published to all backplanes containing publisher ports specified in the routing specification file. 259 def publish_payload(self, payload, publisher_socket, topic=''): 260 \"\"\" 261 This method will publish a python_banyan payload and its associated topic 262 263 :param payload: Protocol message to be published 264 265 :param publisher_socket: Publisher socket - handle to socket or \"BROADCAST\" to send to 266 all connected publisher sockets 267 268 :param topic: A string value for message topic 269 270 :return: 271 \"\"\" 272 if sys.version_info[0] < 3: 273 try: 274 topic = topic.encode() 275 except AttributeError: 276 raise TypeError('Publish topic must be python_banyan string', 'topic') 277 if not type(topic) is str: 278 raise TypeError('Publish topic must be python_banyan string', 'topic') 279 280 # create python_banyan message pack payload 281 if self.numpy: 282 message = msgpack.packb(payload, default=m.encode) 283 else: 284 message = umsgpack.packb(payload) 285 286 pub_envelope = topic.encode() 287 if publisher_socket == \"BROADCAST\": 288 for element in self.backplane_table: 289 if element['publisher']: 290 element['publisher'].send_multipart([pub_envelope, message]) 291 else: 292 293 if publisher_socket: 294 publisher_socket.send_multipart([pub_envelope, message]) 295 else: 296 raise ValueError('Invalid publisher socket')","title":"publish_payload"},{"location":"example9/#receive_loop","text":"The receive_loop cycles through all of the backplane subscriber sockets to see if any messages need to be processed. If so, it calls the incoming_message_processing method. 298 def receive_loop(self): 299 \"\"\" 300 This is the receive loop for zmq messages. 301 302 This method may be overwritten to meet the needs 303 of the application before handling received messages. 304 305 :return: 306 \"\"\" 307 for element in itertools.cycle(self.backplane_table): 308 if element['subscriber']: 309 try: 310 data = element['subscriber'].recv_multipart(zmq.NOBLOCK) 311 if self.numpy: 312 payload = msgpack.unpackb(data[1], object_hook=m.decode) 313 self.incoming_message_processing(data[0].decode(), payload) 314 else: 315 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 316 except zmq.error.Again: 317 try: 318 time.sleep(self.loop_time) 319 except KeyboardInterrupt: 320 self.clean_up() 321 sys.exit(0) 322 except AttributeError: 323 raise 324","title":"receive_loop"},{"location":"example9/#incoming_message_processing","text":"This method needs to be overridden to handle the incoming messages. 325 def incoming_message_processing(self, topic, payload): 326 \"\"\" 327 Override this method with a custom python_banyan message processor for subscribed messages 328 329 :param topic: Message Topic string 330 331 :param payload: Message Data 332 333 :return: 334 \"\"\" 335 print('this method should be overwritten in the child class', topic, payload)","title":"incoming_message_processing"},{"location":"example9/#clean_up","text":"The clean_up method iterates through all the backplanes and closes their connections. 337 def clean_up(self): 338 \"\"\" 339 Clean up before exiting - override if additional cleanup is necessary 340 341 :return: 342 \"\"\" 343 for element in self.backplane_table: 344 if element['publisher']: 345 element['publisher'].close() 346 if element['subscriber']: 347 element['subscriber'].close() 348 self.my_context.term()","title":"clean_up"},{"location":"example9/#a-simple-working-example","text":"This section provides a simple demonstration of a Banyan application that makes use of the BanyanBaseMulti base class. For this example, 2 backplanes are invoked, each on a different computer. The example can be easily modified to run both backplanes on a single computer by adjusting the routing specification file's values. In addition to the two backplanes, the application consists of three Banyan components. The first component is a reuse of echo_cmdline_client.py , and it resides on computer1. The second component, multi_echo_server.py derived from BanyanBaseMulti The third component, notifier.py , derived from BanyanBase, resides on computer2. Backplane1 resides on computer1, and backplane2 resides on computer2. The client publishes messages to backplane1, and the server echoes these messages back within backplane1. As each message is received by the server, it tests to see if the message number is 0. Message number 0 signals that this is the final message. If the message number is 0, the server then publishes a \"notifier\" message routed to backplane2.","title":"A Simple Working Example"},{"location":"example9/#the-notifier","text":"The code for the Notifier is extremely simple. It registers to receive messages with a 'notice' topic and when a message is received, prints 'Notification Received': 1 \"\"\" 2 notifier.py 3 4 Copyright (c) 2018 - 2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 import time 22 23 from python_banyan.banyan_base import BanyanBase 24 25 26 class Notifier(BanyanBase): 27 \"\"\" 28 This class is a simple Banyan echo server 29 30 \"\"\" 31 32 def __init__(self, ): 33 34 # initialize the parent 35 super(Notifier, self).__init__(process_name='Notifier') 36 37 # allow time for base class to initialize publisher/subscriber connections 38 time.sleep(.3) 39 40 # subscribe to receive 'echo' messages from the client 41 self.set_subscriber_topic('notice') 42 43 # wait for messages to arrive 44 try: 45 self.receive_loop() 46 except KeyboardInterrupt: 47 self.clean_up() 48 sys.exit(0) 49 50 def incoming_message_processing(self, topic, payload): 51 \"\"\" 52 Process incoming messages from the client 53 :param topic: message topic 54 :param payload: message payload 55 :return: 56 \"\"\" 57 print('Notification Received!') 58 59 60 def notifier(): 61 Notifier() 62 63 64 if __name__ == '__main__': 65 notifier()","title":"The Notifier"},{"location":"example9/#the-echo-client","text":"We are reusing the echo_cmdline_client unmodified.","title":"The Echo Client"},{"location":"example9/#the-multiechoserver","text":"The server is derived from BanyanBaseMulti. Let us begin by examining its associated routing specification file .","title":"The MultiEchoServer"},{"location":"example9/#routing-specification-file","text":"backplane_name,ip_address,subscriber_port,subscriber_topic,publisher_port BP1,192.168.2.190,43125,\"[echo]\",43124 BP2,192.168.2.180,43125,\"[]\",43124 BP1 is the backplane that is running on 192.168.2.190 and the server subscribes to the echo topic on backplane1. BP2 is the backplane that is running 192.168.2.180, and the server publishes notifier messages to backplane2.","title":"Routing Specification File"},{"location":"example9/#the-multiechoserver-code","text":"Lines 39 and 42 establish the sockets for each of the backplanes. It uses the find_socket method to retrieve the publisher sockets for the backplanes. It uses the names of the backplanes from the routing specification file to retrieve the sockets. Line 59 echoes the incoming messages from the client. If the message number is 0, then line 62 publishes a notice message to backplane2. 1 \"\"\" 2 multi_echo_server.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" 20 import sys 21 import time 22 23 from python_banyan.banyan_base_multi import BanyanBaseMulti 24 25 26 class MultiEchoServer(BanyanBaseMulti): 27 \"\"\" 28 This class is a simple Banyan echo server 29 30 \"\"\" 31 32 def __init__(self, ): 33 34 # initialize the parent 35 super(MultiEchoServer, self).__init__(back_plane_csv_file='spec.csv', process_name='MultiDriver') 36 37 # find the sockets in the table for the 2 backplanes 38 # socket a is to reply to messages from the client 39 self.socket_a = self.find_socket(\"BP1\", self.PUB_SOCK) 40 41 # socket b is to send the notification messages 42 self.socket_b = self.find_socket(\"BP2\", self.PUB_SOCK) 43 44 # wait for messages to arrive 45 try: 46 self.receive_loop() 47 except KeyboardInterrupt: 48 self.clean_up() 49 sys.exit(0) 50 51 def incoming_message_processing(self, topic, payload): 52 \"\"\" 53 Process incoming messages from the client 54 :param topic: message topic 55 :param payload: message payload 56 :return: 57 \"\"\" 58 if topic == 'echo': 59 self.publish_payload(payload, self.socket_a, 'reply') 60 print('Message number:', payload['message_number']) 61 if payload['message_number'] == 0: 62 self.publish_payload({'message': 'got it', 'id': 'b'}, 63 self.socket_b, 'notice') 64 65 66 def multi_echo_server(): 67 MultiEchoServer() 68 69 70 if __name__ == '__main__': 71 multi_echo_server()","title":"The MultiEchoServer Code"},{"location":"example9/#running-the-example","text":"First, we start a backplane, a monitor and multi_echo_server.py on 192.168.2.190. The next step is to start a backplane notifier.py on 192.168.2.180. Finally, we start the echo client on 192.168.2.190. It sends its 10 messages. When the server receives message number 0, it sends its notification message. Looking at the monitor on 192.168.2.190, we see: And the monitor on 192.168.2.180 shows: Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Running The Example"},{"location":"examples_intro/","text":"Learning By Example The tutorials included with this guide provide samples of simple working applications. The tutorials help demonstrate Python Banyan's features and the set of utilities that are part of the python-banyan package. The Key Elements of Python Banyan There are two key components of the Banyan Framework, the backplane that acts as a communication hub, and the Banyan Components where you implement your design. This section will discuss these two elements. The Banyan Backplane When you install Python Banyan, an executable file called backplane is automatically installed on your computer. The backplane is implemented as a ZeroMQ device called a Forwarder . When connecting to the backplane, all components utilize common, well-known IP addresses and port numbers. As a result, routing is greatly simplified, and in most cases, eliminates the need for maintaining a routing table. Because a Banyan component automatically attempts to \"plug\" itself into the backplane when first invoked, the backplane must be started before starting any other components. If you forget to first start the backplane, the component will raise a RunTimeError exception. In general, a Banyan application uses a single instance of the backplane. However, it is possible to have multiple backplanes running in a single application. Using multiple backplanes will be covered in a later section . Since the backplane is not usually modified by the user, its code will not be discussed here, but if you wish, you may view the backplane source code here . Starting the Backplane To start the backplane, open a command or terminal window and type: backplane After starting the backplane, you will see a standard Python Banyan header for the Backplane. The backplane name is displayed. The default is \"Backplane,\" and usually, this default is accepted. You may change it using a command-line option described below The backplane always uses the computer's IP address on which it is run and is not user-configurable. This address is auto-discovered. The Subscriber and Publisher Ports are also displayed. For applications that will run on a single computer, the default ports should be accepted. These values are user-configurable, in case you need to modify them. The Loop Time sets the iteration time for the backplane's idle loop. Usually, the default should be accepted, but it can be altered to fine-tune the application's CPU utilization. The Backplane's Command-Line Options To see the command-line options for the backplane type: backplane -h To specify a command-line option, provide the option and its parameter value. Multiple options may be set if desired. backplane -n MyBackplane -p 12345 -s 54321 -t .01 The parameters consisting of backplane name, the publisher port, the subscriber port, and loop time have all been customized in the example above. Always Start The Backplane First A Python Banyan component expects the backplane to be running when it is instantiated. If you forget to start the backplane, the component will raise a RunTimeException. Python Banyan Base Class And Its Methods Most Python Banyan components need only to connect to a single Backplane and are built by inheriting from the banyan_base base class, banyan_base.py . If you need to create your application using multiple backplanes (a rare occurrence), please refer to this section for a discussion of the banyan_base_multi class. There is also a Python asyncio version of the base class called banyan_base_aio.py. The BanyanBase Class Methods The methods of the BanyanBase class are discussed in detail below. An \"executive summary\" of the methods follows: _ init_ - This method initializes the class. A derived class often overrides this method to add additional initialization parameters as well as being a convenient place to add subscription topics. The Banyan event loop, called receive_loop , may be started within this method. If you choose to start the receive_loop within __init__, it should be called as the last line of the overridden method, since a call to receive_loop will not return. set_subscriber_topic - This method is usually not overridden and is used as-is. This method is called for each subscription topic. publish_payload - This method is usually not overridden and used as-is. This method will format the message and send it to the backplane. receive_loop - This method is usually not overridden and used as-is. This method waits to receive messages that have topics that have been subscribed to. When a message is received, it calls the incoming_message_processing method. incoming_message_processing - This method must be overridden to handle incoming messages. clean_up - This method may be overridden to add any additional clean-up for terminating a component. To better understand the base class, let's look at the code line by line. You can skip this section and move on to the examples and return later if you need a more detailed explanation of the base class. Lines 1 through 19 displays the license information. 1 \"\"\" 2 banyan_base.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" Lines 20 through 36 lists the packages required by banyan_base.py. All required packages are automatically installed when the Python Banyan distribution is first installed. Note that lines 25 through 27 are commented out. A template for creating command-line options for your component is provided at the bottom of the file. This is totally optional, but if you wish to use the template, you will need to uncomment outlines 25 through 27. The template will be discussed at the end of this discussion . 20 from __future__ import unicode_literals 21 22 # Use argparse and signal if you wish to implement the argparse 23 # code located at the bottom of this file. 24 25 # import argparse 26 # import signal 27 # import sys 28 29 import socket 30 import time 31 import umsgpack 32 import msgpack 33 import msgpack_numpy as m 34 import zmq 35 import psutil 36 Line 38 declares the BanyanBase class. It inherits from object to keep the class Python 2 compatible. Lines 41 through 49 provide a brief description of the class. Line 53 shows the import line used to import this class into your component. The examples will demonstrate how to import BanyanBase. 37 38 class BanyanBase(object): 39 \"\"\" 40 41 This is the base class for all Python Banyan components, 42 encapsulating and acting as an abstraction layer for zeromq and message pack 43 functionality. 44 45 Banyan components are derived by inheriting from this class and 46 overriding its methods as necessary. 47 48 Banyan components have the capability to both publish and subscribe to user 49 defined messages using the Banyan backplane. 50 51 To import into the derived class use: 52 53 from python_banyan.banyan_base import BanyanBase 54 55 \"\"\" The base class consists of 6 methods, and the following is a discussion of each of the methods. __init__ The __init__ method is overwritten as needed. A subscription to specific topics is often established in this method by calling set_subscriber_topic for each topic. 57 def __init__(self, back_plane_ip_address=None, subscriber_port='43125', 58 publisher_port='43124', process_name='None', loop_time=.1, numpy=False, 59 external_message_processor=None, receive_loop_idle_addition=None, 60 connect_time=0.3): 61 \"\"\" 62 The __init__ method sets up all the ZeroMQ \"plumbing\" Line 57 through 59 constitutes the parameter list for the __init__ method. Notice that all of the parameters contain default values. In most cases accepting the defaults is all that you need. Lines 64 through 85 documents each the parameters and are discussed below, back_plane_ip_address The default for this parameter is None . The component will discover the local computer's IP address and assume that the backplane is also running on this computer. If the component is running on a computer other than the one that the backplane is running on. In that case, this parameter will need to match the IP address of the running backplane. 64 :param back_plane_ip_address: banyan_base back_planeIP Address - 65 if not specified, it will be set to the 66 local computer. subscriber and publisher ports These are default IP ports dictated by those set for the backplane. Usually, the defaults are accepted. However, they may be modified if there are any port conflicts, or if you are running in a system that has more than one backplane running on a computer. 68 :param subscriber_port: banyan_base back plane subscriber port. 69 This must match that of the banyan_base backplane 70 71 :param publisher_port: banyan_base back plane publisher port. 72 This must match that of the banyan_base backplane. 73 process_name This sets the name shown in the component's console header for identification purposes. If not specified, the name of the component will be 'None'. 74 :param process_name: Component identifier in banner at component startup. 75 loop_time A Banyan component continuously checks for any incoming messages. If no messages are available, then the component will sleep for the specified loop time. The smaller the number, the greater the CPU utilization for the component. 76 :param loop_time: Receive loop sleep time. 77 numpy If the component requires Numpy data handling, then set this parameter to True to efficiently serialize the data. 78 :param numpy: Set true if you wish to include numpy matrices in your messages. 79 external_message_processor Typically all incoming messages are handled within the Banyan component itself. If specified, message processing will be done outside of the component and act similarly to a callback. 80 :param external_message_processor: external method to process messages 81 receive_loop_idle_addition Usually, the receive idle loop is executed when no messages are present. If you wish to perform some additional processing during idle time, set this parameter to the function or method you would like to call. The function or method should be non-blocking. 82 :param receive_loop_idle_addition: an external method called in the idle section 83 of the receive loop 84 \"\"\" connect_time This parameter allows for the connection between the component and backplane to complete. It prevents a race condition from occurring when trying to publish a message before the connection to the backplane has been established. 85 :param connect_time: a short delay to allow the component to connect to the backplane The actual class code for the method follows the parameter documentation strings. Line 89 allows for the possibility of multiple inheritances. An example might be the need to import the threading module in addition to BanyanBase. 88 # call to super allows this class to be used in multiple inheritance scenarios when needed 89 super(BanyanBase, self).__init__() 90 Line 91 declares a flag which is set when the check for a running backplane takes place. Lines 93 through 97 assign the input parameters to instance variables. 91 self.backplane_exists = False 92 93 self.back_plane_ip_address = None 94 self.numpy = numpy 95 self.external_message_processor = external_message_processor 96 self.receive_loop_idle_addition = receive_loop_idle_addition 97 self.connect_time = connect_time Lines 99 through 101 are used to enable the numpy version of messagepack if the numpy parameter was set to True. 99 # if using numpy apply the msgpack_numpy monkey patch 100 if numpy: 101 m.patch() Lines 103 through 105 set the IP address for the backplane if one was specified. If no backplane IP address was specified, Lines 107 through 121 checks to see if a backplane is currently running. If a backplane is running, the self.backplane_exists flag is set to True. NOTE: When the backplane is running on a remote computer, the local component cannot detect the remote backplane's presence. Therefore, it is the user's responsibility to check for a running remote backplane in this case. 103 # If no back plane address was specified, determine the IP address of the local machine 104 if back_plane_ip_address: 105 self.back_plane_ip_address = back_plane_ip_address 106 else: 107 # check for a running backplane 108 for pid in psutil.pids(): 109 p = psutil.Process(pid) 110 try: 111 p_command = p.cmdline() 112 except psutil.AccessDenied: 113 # occurs in Windows - ignore 114 continue 115 try: 116 if any('backplane' in s for s in p_command): 117 self.backplane_exists = True 118 else: 119 continue 120 except UnicodeDecodeError: 121 continue Lines 123 through 124 checks to see if a local backplane was found. If not, a RunTimeError is raised. If a backplane was detected as running, lines 125 through 129 retrieve the local computer's IP address and then sets the backplane_ip_address to that address. Lines 131 through 134 continue setting instance variables from input parameters received by the __init__ method. 123 if not self.backplane_exists: 124 raise RuntimeError('Backplane is not running - please start it.') 125 # determine this computer's IP address 126 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 127 # use the google dns 128 s.connect(('8.8.8.8', 0)) 129 self.back_plane_ip_address = s.getsockname()[0] 130 131 self.subscriber_port = subscriber_port 132 self.publisher_port = publisher_port 133 134 self.loop_time = loop_time Lines 136 through 141 print out the standard Python Banyan console heading. It includes the process_name , backplane_ip_address , subscriber_port , publisher_port , and loop_time . 136 print('\\n************************************************************') 137 print(process_name + ' using Back Plane IP address: ' + self.back_plane_ip_address) 138 print('Subscriber Port = ' + self.subscriber_port) 139 print('Publisher Port = ' + self.publisher_port) 140 print('Loop Time = ' + str(loop_time) + ' seconds') 141 print('************************************************************') 142 Lines 143 through 151 establish ZeroMQ publish and subscribe connections to the backplane. Line 154 calls time.sleep to wait for the duration of the connect_time value. This allows for enough time for both the publisher and subscriber connections to be established. 143 # establish the zeromq sub and pub sockets and connect to the backplane 144 self.my_context = zmq.Context() 145 self.subscriber = self.my_context.socket(zmq.SUB) 146 connect_string = \"tcp://\" + self.back_plane_ip_address + ':' + self.subscriber_port 147 self.subscriber.connect(connect_string) 148 149 self.publisher = self.my_context.socket(zmq.PUB) 150 connect_string = \"tcp://\" + self.back_plane_ip_address + ':' + self.publisher_port 151 self.publisher.connect(connect_string) 152 153 # Allow enough time for the TCP connection to the Backplane complete. 154 time.sleep(self.connect_time) 155 set_subscriber_topic This method is not typically overridden. Line 156 defines the set_subscriber_topic method that requires a topic string parameter. This method must be called for each subscribed topic. Lines 166 through 167 validate that the topic is a string. If the topic is not a string, then a TypeError is raised. Line 169 encodes the topic and registers it with ZeroMQ. 156 def set_subscriber_topic(self, topic): 157 \"\"\" 158 This method sets a subscriber topic. 159 160 You can subscribe to multiple topics by calling this method for 161 each topic. 162 163 :param topic: A topic string 164 \"\"\" 165 166 if not type(topic) is str: 167 raise TypeError('Subscriber topic must be python_banyan string') 168 169 self.subscriber.setsockopt(zmq.SUBSCRIBE, topic.encode()) publish_payload This method is typically not overridden. Line 171 defines the publish_payload method. It accepts two parameters, a message payload that by convention is in the form of a Python dictionary. The dictionary may contain one or more key/value pairs. The second parameter is a message topic that must be in the form of a valid string. Lines 181 through 182 validate that the topic is a string. If the topic is not of string type, then a TypeError exception is raised. Lines 185 through 188 select the messagepack version to use to encode the payload for transmission across the network. If the numpy parameter was set, then messagepack_numpy is selected for use. Otherwise, standard messagepack is selected. Line 190 encodes the topic for transmission across the network. Line 191 publishes the message by calling ZeroMQ send_multipart . 171 def publish_payload(self, payload, topic=''): 172 \"\"\" 173 This method will publish a python_banyan payload and its associated topic 174 175 :param payload: Protocol message to be published 176 177 :param topic: A string value 178 \"\"\" 179 180 # make sure the topic is a string 181 if not type(topic) is str: 182 raise TypeError('Publish topic must be python_banyan string', 'topic') 183 184 # create python_banyan message pack payload 185 if self.numpy: 186 message = msgpack.packb(payload, default=m.encode) 187 else: 188 message = umsgpack.packb(payload) 189 190 pub_envelope = topic.encode() 191 self.publisher.send_multipart([pub_envelope, message]) receive_loop 193 def receive_loop(self): 194 \"\"\" 195 This is the receive loop for Banyan messages. 196 197 This method may be overwritten to meet the needs 198 of the application before handling received messages. 199 200 \"\"\" 201 while True: 202 try: 203 data = self.subscriber.recv_multipart(zmq.NOBLOCK) 204 if self.numpy: 205 payload2 = {} 206 payload = msgpack.unpackb(data[1], object_hook=m.decode) 207 # convert keys to strings 208 # this compensates for the breaking change in msgpack-numpy 0.4.1 to 0.4.2 209 for key, value in payload.items(): 210 if not type(key) == str: 211 key = key.decode('utf-8') 212 payload2[key] = value 213 214 if payload2: 215 payload = payload2 216 self.incoming_message_processing(data[0].decode(), payload) 217 else: 218 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 219 # if no messages are available, zmq throws this exception 220 except zmq.error.Again: 221 try: 222 if self.receive_loop_idle_addition: 223 self.receive_loop_idle_addition() 224 time.sleep(self.loop_time) 225 except KeyboardInterrupt: 226 self.clean_up() 227 raise KeyboardInterrupt This method is the Python Banyan event loop and it is typically not overridden. Line 201 is the beginning of a forever loop. To retrieve the next available message on the subscription queue, line 203 calls the ZeroMQ recv_multipart method with the non-blocking flag set. When A Message Is Available If a message is available, it is assigned to the data variable on line 203. Line 204 checks to see if the numpy flag was set, and if it were, lines 205 through 216 are executed to handle the numpy data. This code exists because a breaking change was added to the messagepack_numpy package by its author. This code is required to handle the latest and earlier versions of messagepack_numpy. The decoded topic string and payload are then passed to the incoming_message_processing method to process the message. Line 216 handles the case for numpy data, and 218 for non-numpy data. When No Messages Are Available When the ZeroMQ recv_mutlipart method is called, and no data is available on the subscription queue, ZeroMQ raises a zmq.error.Again exception. The exception handler constitutes the idle portion of the Python Banyan event loop. During idle time, the receive_loop_idle_addition variable is checked, and if set, the method assigned to receive_loop_idle_addition is called. Within the idle loop, a sleep is performed for the loop_time duration. This relinquishes control of the CPU to allow other components to run. If the user presses Control-C during the idle loop, a KeyboardInterrupt exception is raised. incoming_message_processing This method must be overridden to process the incoming messages. The decoded topic, in the form of a string, and decoded payload, typically in the form of a dictionary, are passed in as input parameters. The message is typically processed within this method. Still, it may be handled by an external function or method specified by the external_message_processor parameter. 229 def incoming_message_processing(self, topic, payload): 230 \"\"\" 231 Override this method with a custom Banyan message processor for subscribed messages. 232 233 :param topic: Message Topic string. 234 235 :param payload: Message Data. 236 \"\"\" 237 if self.external_message_processor: 238 self.external_message_processor(topic, payload) 239 else: 240 print('this method should be overwritten in the child class', topic, payload) clean_up This method may be overridden. It is typically called before terminating the component. Both the publisher and subscriber close their respective connections and terminate the ZeroMQ session for the component. You may add any additional clean-up that your component may require. 242 def clean_up(self): 243 \"\"\" 244 Clean up before exiting - override if additional cleanup is necessary 245 246 \"\"\" 247 self.publisher.close() 248 self.subscriber.close() 249 self.my_context.term() A Template For Component Command-Line Options If you would like to provide the facility to specify command-line options for a component, the following is a template to do so. This will be explained in detail in a later section . 251 # When creating a derived component, replicate the code below and replace 252 # banyan_base with a name of your choice. 253 254 # def banyan_base(): 255 # # Allow user to bypass the IP address auto-discovery. 256 # # This is necessary if the component resides on a computer 257 # # other than the computing running the backplane. 258 # 259 # parser = argparse.ArgumentParser() 260 # parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 261 # help=\"None or IP address used by Back Plane\") 262 # 263 # # allow the user to specify a name for the component and have it shown on the console banner. 264 # # modify the default process name to one you wish to see on the banner. 265 # # change the default in the derived class to set the name 266 # parser.add_argument(\"-n\", dest=\"process_name\", default=\"YOUR PROCESS NAME\", help=\"Set process name in banner\") 267 # 268 # parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\") 269 # 270 # args = parser.parse_args() 271 # kw_options = {} 272 # 273 # if args.back_plane_ip_address != 'None': 274 # kw_options['back_plane_ip_address'] = args.back_plane_ip_address 275 # 276 # kw_options['process_name'] = args.process_name 277 # 278 # kw_options['loop_time'] = float(args.loop_time) 279 # 280 # # replace with the name of your class 281 # app = BanyanBase(**kw_options) 282 # 283 # # optionally add any subscriber topics here 284 # app.set_subscriber_topic('python_banyan') 285 # 286 # # optionally start the receive loop here or start it in your __init__ 287 # try: 288 # app.receive_loop() 289 # except KeyboardInterrupt: 290 # sys.exit() 291 # 292 # # signal handler function called when Control-C occurs 293 # # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal 294 # def signal_handler(signal, frame): 295 # print(\"Control-C detected. See you soon.\") 296 # app.clean_up() 297 # sys.exit(0) 298 # 299 # # listen for SIGINT 300 # signal.signal(signal.SIGINT, signal_handler) 301 # signal.signal(signal.SIGTERM, signal_handler) 302 # 303 # 304 # if __name__ == '__main__': 305 # # replace with name of function you defined above 306 # banyan_base() The Examples In the next section, we will begin using the hands-on demos to understand how to build and use Python Banyan components. Where To Find The Example Source Code The code for all the examples may be found on GitHub . Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Introduction To The Tutorials"},{"location":"examples_intro/#learning-by-example","text":"The tutorials included with this guide provide samples of simple working applications. The tutorials help demonstrate Python Banyan's features and the set of utilities that are part of the python-banyan package.","title":"Learning By Example"},{"location":"examples_intro/#the-key-elements-of-python-banyan","text":"There are two key components of the Banyan Framework, the backplane that acts as a communication hub, and the Banyan Components where you implement your design. This section will discuss these two elements.","title":"The Key Elements of Python Banyan"},{"location":"examples_intro/#the-banyan-backplane","text":"When you install Python Banyan, an executable file called backplane is automatically installed on your computer. The backplane is implemented as a ZeroMQ device called a Forwarder . When connecting to the backplane, all components utilize common, well-known IP addresses and port numbers. As a result, routing is greatly simplified, and in most cases, eliminates the need for maintaining a routing table. Because a Banyan component automatically attempts to \"plug\" itself into the backplane when first invoked, the backplane must be started before starting any other components. If you forget to first start the backplane, the component will raise a RunTimeError exception. In general, a Banyan application uses a single instance of the backplane. However, it is possible to have multiple backplanes running in a single application. Using multiple backplanes will be covered in a later section . Since the backplane is not usually modified by the user, its code will not be discussed here, but if you wish, you may view the backplane source code here .","title":"The Banyan Backplane"},{"location":"examples_intro/#starting-the-backplane","text":"To start the backplane, open a command or terminal window and type: backplane After starting the backplane, you will see a standard Python Banyan header for the Backplane. The backplane name is displayed. The default is \"Backplane,\" and usually, this default is accepted. You may change it using a command-line option described below The backplane always uses the computer's IP address on which it is run and is not user-configurable. This address is auto-discovered. The Subscriber and Publisher Ports are also displayed. For applications that will run on a single computer, the default ports should be accepted. These values are user-configurable, in case you need to modify them. The Loop Time sets the iteration time for the backplane's idle loop. Usually, the default should be accepted, but it can be altered to fine-tune the application's CPU utilization.","title":"Starting the Backplane"},{"location":"examples_intro/#the-backplanes-command-line-options","text":"To see the command-line options for the backplane type: backplane -h To specify a command-line option, provide the option and its parameter value. Multiple options may be set if desired. backplane -n MyBackplane -p 12345 -s 54321 -t .01 The parameters consisting of backplane name, the publisher port, the subscriber port, and loop time have all been customized in the example above.","title":"The Backplane's Command-Line Options"},{"location":"examples_intro/#always-start-the-backplane-first","text":"A Python Banyan component expects the backplane to be running when it is instantiated. If you forget to start the backplane, the component will raise a RunTimeException.","title":"Always Start The Backplane First"},{"location":"examples_intro/#python-banyan-base-class-and-its-methods","text":"Most Python Banyan components need only to connect to a single Backplane and are built by inheriting from the banyan_base base class, banyan_base.py . If you need to create your application using multiple backplanes (a rare occurrence), please refer to this section for a discussion of the banyan_base_multi class. There is also a Python asyncio version of the base class called banyan_base_aio.py.","title":"Python Banyan Base Class And Its Methods"},{"location":"examples_intro/#the-banyanbase-class-methods","text":"The methods of the BanyanBase class are discussed in detail below. An \"executive summary\" of the methods follows: _ init_ - This method initializes the class. A derived class often overrides this method to add additional initialization parameters as well as being a convenient place to add subscription topics. The Banyan event loop, called receive_loop , may be started within this method. If you choose to start the receive_loop within __init__, it should be called as the last line of the overridden method, since a call to receive_loop will not return. set_subscriber_topic - This method is usually not overridden and is used as-is. This method is called for each subscription topic. publish_payload - This method is usually not overridden and used as-is. This method will format the message and send it to the backplane. receive_loop - This method is usually not overridden and used as-is. This method waits to receive messages that have topics that have been subscribed to. When a message is received, it calls the incoming_message_processing method. incoming_message_processing - This method must be overridden to handle incoming messages. clean_up - This method may be overridden to add any additional clean-up for terminating a component. To better understand the base class, let's look at the code line by line. You can skip this section and move on to the examples and return later if you need a more detailed explanation of the base class. Lines 1 through 19 displays the license information. 1 \"\"\" 2 banyan_base.py 3 4 Copyright (c) 2016-2019 Alan Yorinks All right reserved. 5 6 Python Banyan is free software; you can redistribute it and/or 7 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE 8 Version 3 as published by the Free Software Foundation; either 9 or (at your option) any later version. 10 This library is distributed in the hope that it will be useful, 11 but WITHOUT ANY WARRANTY; without even the implied warranty of 12 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 13 General Public License for more details. 14 15 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE 16 along with this library; if not, write to the Free Software 17 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 18 19 \"\"\" Lines 20 through 36 lists the packages required by banyan_base.py. All required packages are automatically installed when the Python Banyan distribution is first installed. Note that lines 25 through 27 are commented out. A template for creating command-line options for your component is provided at the bottom of the file. This is totally optional, but if you wish to use the template, you will need to uncomment outlines 25 through 27. The template will be discussed at the end of this discussion . 20 from __future__ import unicode_literals 21 22 # Use argparse and signal if you wish to implement the argparse 23 # code located at the bottom of this file. 24 25 # import argparse 26 # import signal 27 # import sys 28 29 import socket 30 import time 31 import umsgpack 32 import msgpack 33 import msgpack_numpy as m 34 import zmq 35 import psutil 36 Line 38 declares the BanyanBase class. It inherits from object to keep the class Python 2 compatible. Lines 41 through 49 provide a brief description of the class. Line 53 shows the import line used to import this class into your component. The examples will demonstrate how to import BanyanBase. 37 38 class BanyanBase(object): 39 \"\"\" 40 41 This is the base class for all Python Banyan components, 42 encapsulating and acting as an abstraction layer for zeromq and message pack 43 functionality. 44 45 Banyan components are derived by inheriting from this class and 46 overriding its methods as necessary. 47 48 Banyan components have the capability to both publish and subscribe to user 49 defined messages using the Banyan backplane. 50 51 To import into the derived class use: 52 53 from python_banyan.banyan_base import BanyanBase 54 55 \"\"\" The base class consists of 6 methods, and the following is a discussion of each of the methods.","title":"The BanyanBase Class Methods"},{"location":"examples_intro/#__init__","text":"The __init__ method is overwritten as needed. A subscription to specific topics is often established in this method by calling set_subscriber_topic for each topic. 57 def __init__(self, back_plane_ip_address=None, subscriber_port='43125', 58 publisher_port='43124', process_name='None', loop_time=.1, numpy=False, 59 external_message_processor=None, receive_loop_idle_addition=None, 60 connect_time=0.3): 61 \"\"\" 62 The __init__ method sets up all the ZeroMQ \"plumbing\" Line 57 through 59 constitutes the parameter list for the __init__ method. Notice that all of the parameters contain default values. In most cases accepting the defaults is all that you need. Lines 64 through 85 documents each the parameters and are discussed below,","title":"__init__"},{"location":"examples_intro/#back_plane_ip_address","text":"The default for this parameter is None . The component will discover the local computer's IP address and assume that the backplane is also running on this computer. If the component is running on a computer other than the one that the backplane is running on. In that case, this parameter will need to match the IP address of the running backplane. 64 :param back_plane_ip_address: banyan_base back_planeIP Address - 65 if not specified, it will be set to the 66 local computer.","title":"back_plane_ip_address"},{"location":"examples_intro/#subscriber-and-publisher-ports","text":"These are default IP ports dictated by those set for the backplane. Usually, the defaults are accepted. However, they may be modified if there are any port conflicts, or if you are running in a system that has more than one backplane running on a computer. 68 :param subscriber_port: banyan_base back plane subscriber port. 69 This must match that of the banyan_base backplane 70 71 :param publisher_port: banyan_base back plane publisher port. 72 This must match that of the banyan_base backplane. 73","title":"subscriber and publisher ports"},{"location":"examples_intro/#process_name","text":"This sets the name shown in the component's console header for identification purposes. If not specified, the name of the component will be 'None'. 74 :param process_name: Component identifier in banner at component startup. 75","title":"process_name"},{"location":"examples_intro/#loop_time","text":"A Banyan component continuously checks for any incoming messages. If no messages are available, then the component will sleep for the specified loop time. The smaller the number, the greater the CPU utilization for the component. 76 :param loop_time: Receive loop sleep time. 77","title":"loop_time"},{"location":"examples_intro/#numpy","text":"If the component requires Numpy data handling, then set this parameter to True to efficiently serialize the data. 78 :param numpy: Set true if you wish to include numpy matrices in your messages. 79","title":"numpy"},{"location":"examples_intro/#external_message_processor","text":"Typically all incoming messages are handled within the Banyan component itself. If specified, message processing will be done outside of the component and act similarly to a callback. 80 :param external_message_processor: external method to process messages 81","title":"external_message_processor"},{"location":"examples_intro/#receive_loop_idle_addition","text":"Usually, the receive idle loop is executed when no messages are present. If you wish to perform some additional processing during idle time, set this parameter to the function or method you would like to call. The function or method should be non-blocking. 82 :param receive_loop_idle_addition: an external method called in the idle section 83 of the receive loop 84 \"\"\"","title":"receive_loop_idle_addition"},{"location":"examples_intro/#connect_time","text":"This parameter allows for the connection between the component and backplane to complete. It prevents a race condition from occurring when trying to publish a message before the connection to the backplane has been established. 85 :param connect_time: a short delay to allow the component to connect to the backplane The actual class code for the method follows the parameter documentation strings. Line 89 allows for the possibility of multiple inheritances. An example might be the need to import the threading module in addition to BanyanBase. 88 # call to super allows this class to be used in multiple inheritance scenarios when needed 89 super(BanyanBase, self).__init__() 90 Line 91 declares a flag which is set when the check for a running backplane takes place. Lines 93 through 97 assign the input parameters to instance variables. 91 self.backplane_exists = False 92 93 self.back_plane_ip_address = None 94 self.numpy = numpy 95 self.external_message_processor = external_message_processor 96 self.receive_loop_idle_addition = receive_loop_idle_addition 97 self.connect_time = connect_time Lines 99 through 101 are used to enable the numpy version of messagepack if the numpy parameter was set to True. 99 # if using numpy apply the msgpack_numpy monkey patch 100 if numpy: 101 m.patch() Lines 103 through 105 set the IP address for the backplane if one was specified. If no backplane IP address was specified, Lines 107 through 121 checks to see if a backplane is currently running. If a backplane is running, the self.backplane_exists flag is set to True. NOTE: When the backplane is running on a remote computer, the local component cannot detect the remote backplane's presence. Therefore, it is the user's responsibility to check for a running remote backplane in this case. 103 # If no back plane address was specified, determine the IP address of the local machine 104 if back_plane_ip_address: 105 self.back_plane_ip_address = back_plane_ip_address 106 else: 107 # check for a running backplane 108 for pid in psutil.pids(): 109 p = psutil.Process(pid) 110 try: 111 p_command = p.cmdline() 112 except psutil.AccessDenied: 113 # occurs in Windows - ignore 114 continue 115 try: 116 if any('backplane' in s for s in p_command): 117 self.backplane_exists = True 118 else: 119 continue 120 except UnicodeDecodeError: 121 continue Lines 123 through 124 checks to see if a local backplane was found. If not, a RunTimeError is raised. If a backplane was detected as running, lines 125 through 129 retrieve the local computer's IP address and then sets the backplane_ip_address to that address. Lines 131 through 134 continue setting instance variables from input parameters received by the __init__ method. 123 if not self.backplane_exists: 124 raise RuntimeError('Backplane is not running - please start it.') 125 # determine this computer's IP address 126 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 127 # use the google dns 128 s.connect(('8.8.8.8', 0)) 129 self.back_plane_ip_address = s.getsockname()[0] 130 131 self.subscriber_port = subscriber_port 132 self.publisher_port = publisher_port 133 134 self.loop_time = loop_time Lines 136 through 141 print out the standard Python Banyan console heading. It includes the process_name , backplane_ip_address , subscriber_port , publisher_port , and loop_time . 136 print('\\n************************************************************') 137 print(process_name + ' using Back Plane IP address: ' + self.back_plane_ip_address) 138 print('Subscriber Port = ' + self.subscriber_port) 139 print('Publisher Port = ' + self.publisher_port) 140 print('Loop Time = ' + str(loop_time) + ' seconds') 141 print('************************************************************') 142 Lines 143 through 151 establish ZeroMQ publish and subscribe connections to the backplane. Line 154 calls time.sleep to wait for the duration of the connect_time value. This allows for enough time for both the publisher and subscriber connections to be established. 143 # establish the zeromq sub and pub sockets and connect to the backplane 144 self.my_context = zmq.Context() 145 self.subscriber = self.my_context.socket(zmq.SUB) 146 connect_string = \"tcp://\" + self.back_plane_ip_address + ':' + self.subscriber_port 147 self.subscriber.connect(connect_string) 148 149 self.publisher = self.my_context.socket(zmq.PUB) 150 connect_string = \"tcp://\" + self.back_plane_ip_address + ':' + self.publisher_port 151 self.publisher.connect(connect_string) 152 153 # Allow enough time for the TCP connection to the Backplane complete. 154 time.sleep(self.connect_time) 155","title":"connect_time"},{"location":"examples_intro/#set_subscriber_topic","text":"This method is not typically overridden. Line 156 defines the set_subscriber_topic method that requires a topic string parameter. This method must be called for each subscribed topic. Lines 166 through 167 validate that the topic is a string. If the topic is not a string, then a TypeError is raised. Line 169 encodes the topic and registers it with ZeroMQ. 156 def set_subscriber_topic(self, topic): 157 \"\"\" 158 This method sets a subscriber topic. 159 160 You can subscribe to multiple topics by calling this method for 161 each topic. 162 163 :param topic: A topic string 164 \"\"\" 165 166 if not type(topic) is str: 167 raise TypeError('Subscriber topic must be python_banyan string') 168 169 self.subscriber.setsockopt(zmq.SUBSCRIBE, topic.encode())","title":"set_subscriber_topic"},{"location":"examples_intro/#publish_payload","text":"This method is typically not overridden. Line 171 defines the publish_payload method. It accepts two parameters, a message payload that by convention is in the form of a Python dictionary. The dictionary may contain one or more key/value pairs. The second parameter is a message topic that must be in the form of a valid string. Lines 181 through 182 validate that the topic is a string. If the topic is not of string type, then a TypeError exception is raised. Lines 185 through 188 select the messagepack version to use to encode the payload for transmission across the network. If the numpy parameter was set, then messagepack_numpy is selected for use. Otherwise, standard messagepack is selected. Line 190 encodes the topic for transmission across the network. Line 191 publishes the message by calling ZeroMQ send_multipart . 171 def publish_payload(self, payload, topic=''): 172 \"\"\" 173 This method will publish a python_banyan payload and its associated topic 174 175 :param payload: Protocol message to be published 176 177 :param topic: A string value 178 \"\"\" 179 180 # make sure the topic is a string 181 if not type(topic) is str: 182 raise TypeError('Publish topic must be python_banyan string', 'topic') 183 184 # create python_banyan message pack payload 185 if self.numpy: 186 message = msgpack.packb(payload, default=m.encode) 187 else: 188 message = umsgpack.packb(payload) 189 190 pub_envelope = topic.encode() 191 self.publisher.send_multipart([pub_envelope, message])","title":"publish_payload"},{"location":"examples_intro/#receive_loop","text":"193 def receive_loop(self): 194 \"\"\" 195 This is the receive loop for Banyan messages. 196 197 This method may be overwritten to meet the needs 198 of the application before handling received messages. 199 200 \"\"\" 201 while True: 202 try: 203 data = self.subscriber.recv_multipart(zmq.NOBLOCK) 204 if self.numpy: 205 payload2 = {} 206 payload = msgpack.unpackb(data[1], object_hook=m.decode) 207 # convert keys to strings 208 # this compensates for the breaking change in msgpack-numpy 0.4.1 to 0.4.2 209 for key, value in payload.items(): 210 if not type(key) == str: 211 key = key.decode('utf-8') 212 payload2[key] = value 213 214 if payload2: 215 payload = payload2 216 self.incoming_message_processing(data[0].decode(), payload) 217 else: 218 self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1])) 219 # if no messages are available, zmq throws this exception 220 except zmq.error.Again: 221 try: 222 if self.receive_loop_idle_addition: 223 self.receive_loop_idle_addition() 224 time.sleep(self.loop_time) 225 except KeyboardInterrupt: 226 self.clean_up() 227 raise KeyboardInterrupt This method is the Python Banyan event loop and it is typically not overridden. Line 201 is the beginning of a forever loop. To retrieve the next available message on the subscription queue, line 203 calls the ZeroMQ recv_multipart method with the non-blocking flag set.","title":"receive_loop"},{"location":"examples_intro/#when-a-message-is-available","text":"If a message is available, it is assigned to the data variable on line 203. Line 204 checks to see if the numpy flag was set, and if it were, lines 205 through 216 are executed to handle the numpy data. This code exists because a breaking change was added to the messagepack_numpy package by its author. This code is required to handle the latest and earlier versions of messagepack_numpy. The decoded topic string and payload are then passed to the incoming_message_processing method to process the message. Line 216 handles the case for numpy data, and 218 for non-numpy data.","title":"When A Message Is Available"},{"location":"examples_intro/#when-no-messages-are-available","text":"When the ZeroMQ recv_mutlipart method is called, and no data is available on the subscription queue, ZeroMQ raises a zmq.error.Again exception. The exception handler constitutes the idle portion of the Python Banyan event loop. During idle time, the receive_loop_idle_addition variable is checked, and if set, the method assigned to receive_loop_idle_addition is called. Within the idle loop, a sleep is performed for the loop_time duration. This relinquishes control of the CPU to allow other components to run. If the user presses Control-C during the idle loop, a KeyboardInterrupt exception is raised.","title":"When No Messages Are Available"},{"location":"examples_intro/#incoming_message_processing","text":"This method must be overridden to process the incoming messages. The decoded topic, in the form of a string, and decoded payload, typically in the form of a dictionary, are passed in as input parameters. The message is typically processed within this method. Still, it may be handled by an external function or method specified by the external_message_processor parameter. 229 def incoming_message_processing(self, topic, payload): 230 \"\"\" 231 Override this method with a custom Banyan message processor for subscribed messages. 232 233 :param topic: Message Topic string. 234 235 :param payload: Message Data. 236 \"\"\" 237 if self.external_message_processor: 238 self.external_message_processor(topic, payload) 239 else: 240 print('this method should be overwritten in the child class', topic, payload)","title":"incoming_message_processing"},{"location":"examples_intro/#clean_up","text":"This method may be overridden. It is typically called before terminating the component. Both the publisher and subscriber close their respective connections and terminate the ZeroMQ session for the component. You may add any additional clean-up that your component may require. 242 def clean_up(self): 243 \"\"\" 244 Clean up before exiting - override if additional cleanup is necessary 245 246 \"\"\" 247 self.publisher.close() 248 self.subscriber.close() 249 self.my_context.term()","title":"clean_up"},{"location":"examples_intro/#a-template-for-component-command-line-options","text":"If you would like to provide the facility to specify command-line options for a component, the following is a template to do so. This will be explained in detail in a later section . 251 # When creating a derived component, replicate the code below and replace 252 # banyan_base with a name of your choice. 253 254 # def banyan_base(): 255 # # Allow user to bypass the IP address auto-discovery. 256 # # This is necessary if the component resides on a computer 257 # # other than the computing running the backplane. 258 # 259 # parser = argparse.ArgumentParser() 260 # parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\", 261 # help=\"None or IP address used by Back Plane\") 262 # 263 # # allow the user to specify a name for the component and have it shown on the console banner. 264 # # modify the default process name to one you wish to see on the banner. 265 # # change the default in the derived class to set the name 266 # parser.add_argument(\"-n\", dest=\"process_name\", default=\"YOUR PROCESS NAME\", help=\"Set process name in banner\") 267 # 268 # parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\") 269 # 270 # args = parser.parse_args() 271 # kw_options = {} 272 # 273 # if args.back_plane_ip_address != 'None': 274 # kw_options['back_plane_ip_address'] = args.back_plane_ip_address 275 # 276 # kw_options['process_name'] = args.process_name 277 # 278 # kw_options['loop_time'] = float(args.loop_time) 279 # 280 # # replace with the name of your class 281 # app = BanyanBase(**kw_options) 282 # 283 # # optionally add any subscriber topics here 284 # app.set_subscriber_topic('python_banyan') 285 # 286 # # optionally start the receive loop here or start it in your __init__ 287 # try: 288 # app.receive_loop() 289 # except KeyboardInterrupt: 290 # sys.exit() 291 # 292 # # signal handler function called when Control-C occurs 293 # # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal 294 # def signal_handler(signal, frame): 295 # print(\"Control-C detected. See you soon.\") 296 # app.clean_up() 297 # sys.exit(0) 298 # 299 # # listen for SIGINT 300 # signal.signal(signal.SIGINT, signal_handler) 301 # signal.signal(signal.SIGTERM, signal_handler) 302 # 303 # 304 # if __name__ == '__main__': 305 # # replace with name of function you defined above 306 # banyan_base()","title":"A Template For Component Command-Line Options"},{"location":"examples_intro/#the-examples","text":"In the next section, we will begin using the hands-on demos to understand how to build and use Python Banyan components.","title":"The Examples"},{"location":"examples_intro/#where-to-find-the-example-source-code","text":"The code for all the examples may be found on GitHub . Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Where To Find The Example Source Code"},{"location":"gpio_intro/","text":"OneGPIO is a generalized GPIO specification and framework that will allow you to construct GPIO based projects quickly. OneGPIO projects are both target hardware and computer language independent. This independence is accomplished by taking advantage of the abstract nature of the OneGPIO message set and the Python Banyan Framework. A OneGPIO project is typically comprised of 2 main elements - a single OneGPIO Application Component and one or more OneGPIO Gateways. The application component is unique for each project. The Gateways are reusable components that need no modification when going from one project to another. The Application Component contains all the GPIO control logic for your application, as well as the logic to process report messages sent from the target hardware. A OneGPIO component is responsible for assembling and publishing OneGPIO control messages. Also, it subscribes to receive OneGPIO report messages that are sent from the OneGPIO Hardware Gateways, connected to target hardware. A working OneGPIO project designed for a specific target hardware set is easily converted to run on different target hardware by merely enabling the OneGPIO hardware-specific gateway. No code changes are needed. Included with this distribution are several demonstration applications that use a single OneGPIO application component (or a variation of that component) to control Arduino, ESP-8266, and Raspberry Pi targets. For those in a hurry to see OneGPIO in action, you can skip to this document's demonstration section of this document. \"Standard\" Function Call GPIO API Libraries GPIO API libraries, such as pigpio and Gpiozero (supporting the Raspberry Pi), and pymata-express (supporting the Arduino), all provide software abstractions for GPIO control. All of these libraries are written in Python and use function or method calls to implement the API. Using any of these libraries essentially result in the same electrical outcomes, but they have widely differing syntax structures. For example, suppose we wish to take advantage of PWM functionality to set an LED's illumination level or a motor's speed. In that case, we might utilize a specific GPIO API library. The table below illustrates the PWM API interface for the three libraries mentioned above. GPIO Operation pigpio Gpiozero pymata-express Set Pin To PWM Mode pi.set_mode(PIN, pigpio.OUTPUT) led = PWMLED(PIN) set_pin_mode_pwm(PIN) Set PWM Pin Value To 50% pi.set_PWM_dutycycle(PIN, 128) led.value = 0.5 analog_write(PIN, 128) As you can plainly see, each library has its own unique way of expressing GPIO operations. Because of the syntax differences, it makes porting a hardware project from one hardware platform to another a laborious and tedious process, not to mention being error-prone and time-consuming. It also severely hampers the possibility of code reuse for future projects. The Banyan OneGPIO API OneGPIO takes advantage of the portable nature of Banyan protocol messages to provide a unified GPIO API. In addition to the OneGPIO GPIO message specification, the OneGPIO concept specifies a framework for building specialized Banyan components, called Banyan GPIO Gateways. These specialized components translate OneGPIO messages to and from a specific hardware platform. The OneGPIO project includes fully functional Banyan Gateways for the Arduino, ESP-8266, and Raspberry Pi. A single OneGPIO control component can control a single hardware target or multiple targets simultaneously without any code changes. All OneGPIO Gateways are derived from a Gateway Base class, making it easy to create new Banyan Gateways. You may use the included OneGPIO Gateways as is, or you may easily customize them to meet your specific needs. In the following sections, we will: Discuss the OneGPIO messaging protocol Discuss Banyan OneGPIO Gateway internals Discuss the included demonstration programs Demonstrate a single OneGPIO Application Component that can blink an LED on an Arduino, ESP-8266, or Raspberry Pi Demonstrate how a single OneGPIO Tkinter Application Component can control a Raspberry Pi, Arduino, and ESP-8266 Demonstrate a Banyan WebSocket gateway that allows an HTML web page to control any of the 3 hardware platforms Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Introducing OneGPIO"},{"location":"gpio_intro/#standard-function-call-gpio-api-libraries","text":"GPIO API libraries, such as pigpio and Gpiozero (supporting the Raspberry Pi), and pymata-express (supporting the Arduino), all provide software abstractions for GPIO control. All of these libraries are written in Python and use function or method calls to implement the API. Using any of these libraries essentially result in the same electrical outcomes, but they have widely differing syntax structures. For example, suppose we wish to take advantage of PWM functionality to set an LED's illumination level or a motor's speed. In that case, we might utilize a specific GPIO API library. The table below illustrates the PWM API interface for the three libraries mentioned above. GPIO Operation pigpio Gpiozero pymata-express Set Pin To PWM Mode pi.set_mode(PIN, pigpio.OUTPUT) led = PWMLED(PIN) set_pin_mode_pwm(PIN) Set PWM Pin Value To 50% pi.set_PWM_dutycycle(PIN, 128) led.value = 0.5 analog_write(PIN, 128) As you can plainly see, each library has its own unique way of expressing GPIO operations. Because of the syntax differences, it makes porting a hardware project from one hardware platform to another a laborious and tedious process, not to mention being error-prone and time-consuming. It also severely hampers the possibility of code reuse for future projects.","title":"\"Standard\" Function Call GPIO API Libraries"},{"location":"gpio_intro/#the-banyan-onegpio-api","text":"OneGPIO takes advantage of the portable nature of Banyan protocol messages to provide a unified GPIO API. In addition to the OneGPIO GPIO message specification, the OneGPIO concept specifies a framework for building specialized Banyan components, called Banyan GPIO Gateways. These specialized components translate OneGPIO messages to and from a specific hardware platform. The OneGPIO project includes fully functional Banyan Gateways for the Arduino, ESP-8266, and Raspberry Pi. A single OneGPIO control component can control a single hardware target or multiple targets simultaneously without any code changes. All OneGPIO Gateways are derived from a Gateway Base class, making it easy to create new Banyan Gateways. You may use the included OneGPIO Gateways as is, or you may easily customize them to meet your specific needs. In the following sections, we will: Discuss the OneGPIO messaging protocol Discuss Banyan OneGPIO Gateway internals Discuss the included demonstration programs Demonstrate a single OneGPIO Application Component that can blink an LED on an Arduino, ESP-8266, or Raspberry Pi Demonstrate how a single OneGPIO Tkinter Application Component can control a Raspberry Pi, Arduino, and ESP-8266 Demonstrate a Banyan WebSocket gateway that allows an HTML web page to control any of the 3 hardware platforms Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"The Banyan OneGPIO API"},{"location":"install/","text":"Installing Python Banyan Checking For An Existing Python Installation The first step in installing Python Banyan is to make sure you have Python installed on your computer. Python Banyan is both Python 2 and Python3 compatible. If either version is installed on your computer, you are ready to start using Python Banyan. If you need to install Python on your system, then Python 3 is recommended. To check to see if you already have Python installed on your computer, open a command window and type: python -V or python3 -V You should see something similar to this screenshot: Installing Python 3 If you need to install Python3 on your computer, use the latest version of Python 3 available. As of this writing, that version is 3.7.2. If you have an earlier version already installed, upgrading to Python 3.7.2 is not necessary. Windows Users To install Python 3.7.2 or later, go to the Python home page, and download the 3.7.2 (or later) distribution for your operating system. If you have Python 2.7 installed, you do not need to remove it. If there is a checkbox to add Python 3.7 to your path during the installation process, make sure it is checked before proceeding with the installation. Debian Based Linux Distribution Users To build the latest version of Python (version 3.8.1 at the time of this writing) for Debian based Linux releases, such as Ubuntu, Raspbian, etc., use the following build instructions: sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade sudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus sudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-dev sudo apt-get install zlib1g-dev libsqlite3-dev tk-dev sudo apt-get install libssl-dev openssl sudo apt-get install libffi-dev cd ~ mkdir build cd build wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz tar -zxvf Python-3.7.2.tgz cd Python-3.7.2 ./configure make sudo make install Install pip For Debian based distributions: sudo apt-get install pip3-python Non-Debian Based Linux Distribution Users Check with your distribution provider for the latest versions of Python. Mac Users Install Python 3.7.2 from https://www.python.org/downloads/ or via homebrew Download get-pip.py from https://bootstrap.pypa.io/get-pip.py and install (this should already be installed if Python was installed from python.org or homebrew): curl -O https://bootstrap.pypa.io/get-pip.py sudo python3 get-pip.py Verify The Python Installation Refer to \"Checking To See If Python Is Installed,\" above. Installing Python Banyan To install Python Banyan on Linux and Mac computers, open a terminal window and type: sudo pip3 install python-banyan NOTE For Raspberry Pi Users : When initially installing Python Banyan, it may take approximately 10 minutes to install. The installation requires some compilation. For Windows users, type: pip install python-banyan The code for Python Banyan can be found on GitHub . Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Installation"},{"location":"install/#installing-python-banyan","text":"","title":"Installing Python Banyan"},{"location":"install/#checking-for-an-existing-python-installation","text":"The first step in installing Python Banyan is to make sure you have Python installed on your computer. Python Banyan is both Python 2 and Python3 compatible. If either version is installed on your computer, you are ready to start using Python Banyan. If you need to install Python on your system, then Python 3 is recommended. To check to see if you already have Python installed on your computer, open a command window and type: python -V or python3 -V You should see something similar to this screenshot:","title":"Checking For An Existing Python Installation"},{"location":"install/#installing-python-3","text":"If you need to install Python3 on your computer, use the latest version of Python 3 available. As of this writing, that version is 3.7.2. If you have an earlier version already installed, upgrading to Python 3.7.2 is not necessary.","title":"Installing Python 3"},{"location":"install/#windows-users","text":"To install Python 3.7.2 or later, go to the Python home page, and download the 3.7.2 (or later) distribution for your operating system. If you have Python 2.7 installed, you do not need to remove it. If there is a checkbox to add Python 3.7 to your path during the installation process, make sure it is checked before proceeding with the installation.","title":"Windows Users"},{"location":"install/#debian-based-linux-distribution-users","text":"To build the latest version of Python (version 3.8.1 at the time of this writing) for Debian based Linux releases, such as Ubuntu, Raspbian, etc., use the following build instructions: sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade sudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus sudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-dev sudo apt-get install zlib1g-dev libsqlite3-dev tk-dev sudo apt-get install libssl-dev openssl sudo apt-get install libffi-dev cd ~ mkdir build cd build wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz tar -zxvf Python-3.7.2.tgz cd Python-3.7.2 ./configure make sudo make install Install pip For Debian based distributions: sudo apt-get install pip3-python","title":"Debian Based Linux Distribution Users"},{"location":"install/#non-debian-based-linux-distribution-users","text":"Check with your distribution provider for the latest versions of Python.","title":"Non-Debian Based Linux Distribution Users"},{"location":"install/#mac-users","text":"Install Python 3.7.2 from https://www.python.org/downloads/ or via homebrew Download get-pip.py from https://bootstrap.pypa.io/get-pip.py and install (this should already be installed if Python was installed from python.org or homebrew): curl -O https://bootstrap.pypa.io/get-pip.py sudo python3 get-pip.py","title":"Mac Users"},{"location":"install/#verify-the-python-installation","text":"Refer to \"Checking To See If Python Is Installed,\" above.","title":"Verify The Python Installation"},{"location":"install/#installing-python-banyan_1","text":"To install Python Banyan on Linux and Mac computers, open a terminal window and type: sudo pip3 install python-banyan NOTE For Raspberry Pi Users : When initially installing Python Banyan, it may take approximately 10 minutes to install. The installation requires some compilation. For Windows users, type: pip install python-banyan The code for Python Banyan can be found on GitHub . Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Installing Python Banyan"},{"location":"one_gpio_demos/","text":"Introduction To The Demos This section will introduce three demonstration programs that control the Arduino, ESP-8266, and Raspberry Pi hardware targets, using common OneGPIO Application Components. The demo programs included are: An LED blink program. A Tkinter GPIO Demonstration Station. A Web-based GPIO Demonstration Station. A single OneGPIO Application Component is provided for the blink demo and one for the Tkinter demo, each containing the GPIO control logic to run their respective demos. For the Web Demonstration stations, the logic is coded in JavaScript within the Web page. The Web page connects to the Banyan network through the WebSocket Gateway. OneGPIO formatted messages are JSON encoded on the Webpage and then sent to the WebSocket Gateway. Prerequisites All Hardware Platforms Make sure that you have the newest version of python-banyan on your computer. You can upgrade to the latest version using the pip --upgrade option. In addition to installing Python Banyan, you will need to download the latest python-banyan distribution files to your computer to run the demos. To download, go to the Python Banyan Github Web page and click on the green download button and unzip to any directory. All of the demos may be launched manually, that is, bringing up each component individually. However, it is much simpler to use the Banyan Launcher, and therefore we will use it to launch each demo. To review the information about the launcher, click on this link. The Banyan launcher is automatically installed as an executable when you install the python-banyan distribution. The launcher requires a command-line option to load a Launcher specification file. Launcher specification files have been provided for each demo and for each platform. Modifications that you may need to be made to these files will be covered in each demo section. Python 3.7 Both the Arduino Gateway and WebSocket Gateway requires the use of Python 3.7 or higher. You may install and manage multiple versions of Python by using pyenv. With pyenv, you can set a specific directory to use the latest version of Python by using the pyenv local command. You may also create a virtual environment for a given directory using pyenv virtualenv . Again, this will all be accomplished via the Banyan launcher and will be covered in the Web Demonstration Station section of this document for the Raspberry Pi. Since the Windows Operating System is not dependent upon Python, it is probably easiest to install the latest version of Python3 on your computer from python.org . Arduino The Arduino Gateway was implemented using the python-express GPIO library. Install python-express on your computer and firmata-express on your Arduino. ESP-8266 A NodeMCU ESP-8266 development module was used to test the demo programs. AA custom MicroPython script was developed to work with the ESP-8266 Gateway, and this script must be installed on the ESP-8266. It and may be found here. This script is a \"minified\" version to allow it to fit on the device. A fully commented file is provided here. It is assumed that you already know how to flash a program onto the ESP-8266. If you need some information on flashing the ESP-8266, the program I use to manage ESP-8266 image files is Adafruit Ampy. The Ampy Web page says that only CircuitPython is supported. But you can ignore that warning and use it to install the OneGPIO MicroPython script. The ampy command-line I use is: ampy -p /dev/ttyUSB0 put esp_8266.py You will need to re-power the board after flashing. The red LED should flash and then stay lit. It will extinguish when the board successfully connects to the ESP-8266 OneGPIO Gateway. NOTE: You will need to know the TCP/IP address of your ESP-8266 and present that as a command-line argument to the ESP-8266 Gateway. Raspberry Pi The Raspberry Pi has no additional requirements unless you wish to install Python 3.7. The demos were tested with \"Raspbian Stretch with desktop and recommended software,\" with a release date of 2019-04-08. If you are running the demos within a pyenv Python 3.7 or higher virtual environment, the Raspberry Pi Gateway may not be able to import pigpio. To test this out, when in the virtual environment, start-up Python and type import pigpio. pi@RPi3:~ $ cd 37* (python-banyan) pi@RPi3:~/37stuff $ python Python 3.7.3 (default, Apr 26 2019, 09:58:44) [GCC 6.3.0 20170516] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import pigpio >>> If no errors are reported, you are good to go. If you see an import error, you will need to manually move a copy of pigpio.py to the virtual environment. If you are using the version of pigpio included with the Raspbian distribution, you can find pipgio.py in the /usr/lib/python3/dist-packages/ directory. If you rebuilt pigpio to use the latest version, then you can find the pigpio.py file in the PIGPIO directory that was created during the build process. The pigpio.py file needs to be copied to a directory in the ~/.pyenv directory. For my pyenv virtual environment, I used Python 3.7.3 and named the virtual environment python_banyan. I needed to copy the file to: ~/.pyenv/versions/3.7.3/python-banyan/lib/python3.7/site-packages/ Here is the general template for this path: ~/.pyenv/versions/PYTHON VERSION/VIRTUAL ENVIRONMENT NAME/lib/PYTHON VERSION WITHOUT LAST NUMBER/site-packages/ The Demo Examples All of the demos are launched using the Banyan Launcher. The launcher specification files utilize a relative path to access the components for the applications. As a result, you must maintain the directory structure of the python-banyan distribution. If you haven't downloaded the distribution yet, you may do so by clicking on the green download button found on this link and then unzip the files. The launcher files may be found in the projects/OneGPIO/launch_scripts directory or the projects/OneGPIO/launch_scripts_for_windows directory. You will find the Banyan Launcher specification files used for each demonstration and for each hardware target in those directories. The difference between the Windows and non-Windows specifications files is that the command to invoke python is different. Windows uses python , while the other platforms use python3. The specification files are csv (comma-separated value) files. They may need to be modified for your specific environment. Those modifications will be discussed within the discussions for each specific demonstration. Blink Demo You can view the source code for the blink demo here. Running The Blink Demo On The Arduino To run this demo for the Arduino, you must use Python 3.7 or higher, as mentioned above. Let's look at the b_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,5 python3 ../shared/blinker.py -g 10,no,local,no,no,0 The default hardware target for blinker.py is the Arduino, and therefore we do not need to specify it here. The only change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 10 - modify this value to meet your needs. To run this demo: Plug the Arduino into your computer. Go into the launch_scripts directory and type: bls -f b_a.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_a.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink. Running The Blink Demo On The ESP-8266 Let's look at the b_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.183,no,local,no,no,0 python3 ../shared/blinker.py -d esp8266 -g 13,no,local,no,no,0 There are 2 changes you may need to make for this file. The first is the IP address of the computer that the esp8266_gateway is running on. This is specified with the -i option on the second line. For my environment, that address is 192.168.2.183, but yours is likely to be different. The second change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 13 - modify this value to meet your needs. The blinker.py script also needs to have the target hardware type defined using the -d option. To run this demo: Power up the ESP-8266. Go into the launch_scripts directory and type: bls -f b_e.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_e.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink. Running The Blink Demo On The Raspberry Pi The Raspberry Pi Gateway utilizes the pigpio API library. When the Raspberry Pi Gateway is invoked, it will check to see if the pigpio daemon is currently running. If not, it will automatically start it. The pigpio library may report an error, as shown in this screenshot. It can safely be ignored since the gateway will automatically start the daemon. The daemon will continue running even after the gateway is closed. Let's look at the b_r.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,local,no,no,0 python3 ../shared/blinker.py -d rpi -g 4,no,local,no,no,0 The only change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 4 - modify this value to meet your needs. To run this demo: Power up the Raspberry Pi. Go into the launch_scripts directory and type: bls -f b_r.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_r.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink. Tkinter Demo Station The Tkinter Demo Station is a GUI application that will allow you to remotely interact with the target hardware. A common python script, banyan_tkinter_demo.py, is used for all three targets and is a OneGPIO Application Component. The target type is supplied as a command-line parameter when invoking banyan_tkinter_demo. This is provided in each of the launcher specification files. Tkinter Demo Station Functions The Tkinter Demo Station for the Arduino is shown above. No matter the target hardware, the Tkinter Demo Station for all target hardware types share common capabilities. Digital Output Control The Tkinter Demo Station allows you to set the state of a digital output pin. To use this feature, you first select the pin number, then the pin's output value, and finally, you set the state by pressing the Set Output State button. PWM Output Control To set a PWM output pin, first, select the pin number and then use the slider to set its output value. Buzzer Tone Control Select the pin, then set the frequency in HZ and duration in milliseconds for the tone. Press the Play Tone button to generate the tone. Digital Input Select and enable digital input for a pin by clicking on the white box to the left of the pin number. The box to the pin number's right will be black if the pin value is zero and red if it is a one. If a pin is enabled for digital input, its current state will be shown in real-time. Running The Tkinter Demonstration Station For Arduino Let's look at the tk_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,4 python3 ../shared/banyan_tkinter_demo.py -d arduino,no,local,no,no,0 You should not have to make any changes to this specification file. To run this demo: Connect the Arduino to your computer. Go into the launch_scripts directory and type: bls -f tk_a.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_a.csv specification file. You should see a Tkinter window for the Arduino appear. Running The Tkinter Demonstration Station For The ESP-8266 Let's look at the tk_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.185,no,local,no,no,0 python3 ../shared/banyan_tkinter_demo.py -d esp8266,no,local,no,no,0 You most likely will have to specify the IP address of the computer that is running the esp8266 gateway. This is done on line 2 of the file with the -i option. To run this demo: Power the ESP-8266 Go into the launch_scripts directory and type: bls -f tk_e.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_e.csv specification file. You should see a Tkinter window for the ESP-8266 appear. Running The Tkinter Demonstration Station For Raspberry Pi Let's look at the tk_r.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,local,no,no,0 python3 ../shared/banyan_tkinter_demo.py -d rpi,no,local,no,no,0 You should not have to make any changes to this specification file. To run this demo: Power the Raspberry Pi. Go into the launch_scripts directory and type: bls -f tk_r.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_r.csv specification file. You should see a Tkinter window for the Raspberry Pi appear. Banyan Demonstration Station Web Pages Once again, the Banyan launcher will be used to run Web page demos. The launcher will start the Backplane, the Gateway for the hardware target, the WebSocket Gateway. It will also start your Web browser with the correct HTML page loaded. By clicking on the following links, you may view the HTML pages for the Arduino , ESP-8266 , and Raspberry Pi. The pages of the Demonstration Station may vary slightly between hardware targets. But all use the OneGPIO messaging specification, allowing the target hardware gateway to handle the messaging. There is a common set of functions, selected by tab, for all of the targets: Digital Input Digital Output Including PWM Analog Input Servo Motor Control I2C Read and Write Piezo Buzzer Tone Generation Monitoring of an HC-SR04 Sonar Distance Sensor Stepper Motor Control Note Analog Input is supported for the Raspberry Pi by using a PCF8591 A/D i2c converter. The digital and analog tabs will display a timestamp for the last change to an enabled pin, and the pin's value: Running The Web Demo Station For The Arduino Let's look at the h_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,5 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py,no,local,no,no,5 You should not need to make any modifications to this file. To run this demo: Plug the Arduino into your computer Go into the launch_scripts directory and type: bls -f h_a.csv Running The Web Demo Station For The ESP-8266 Let's look at the h_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.185,no,local,no,no,4 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py esp8266,no,local,no,no,5 You will most likely need to modify the IP address in line 2 following the -i option. To run this demo: Power the ESP-8266 Go into the launch_scripts directory and type: bls -f h_e.csv Running The Web Demo Station For The Raspberry Pi Without Python 3.7 Installed If you do not have Python 3.7 or higher installed on your Raspberry Pi, you may still run this demo. Because Banyan allows us to distribute Banyan components across computers, we run the Web server and WebSocket Gateway on our PC and the Raspberry Pi Gateway on the Raspberry Pi. The launcher was designed to handle these situations. First, we need to start the Banyan Launcher Client (blc) on the Raspberry Pi using a command-line similar to this one: blc -t rpi_remote -b 192.168.2.186 The -t option is a topic that will be used when the Banyan Launcher Server (bls) publishes its launcher messages. The -b option is the IP address of the PC, where we will launch bls. You will most likely have to modify the IP address when executing this command. The topic may be any string as long as both bls and blc use the same string. Here is what you will see on the Raspberry Pi after starting blc: Now, let's look at the h_r_dist.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,rpi_remote,yes,no,5 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py rpi,no,local,no,no,1 You should not need to make any modifications to this file. Note that the topic field, in line 2, was set to rpi_remote, and the append_bp_address field, in line 2, was to yes. Now, let's start bls on our PC: $ bls -f h_r_dist.csv ************************************************************ Banyan Launch Server using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ backplane PID = 15856 python3 ../shared/ws_gateway.py PID = 15881 ************************************************************ WebSocket Gateway using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 ************************************************************ python3 ../shared/open_browser.py rpi PID = 15885 ACKrpi_remote ACKrpi_remote: python3 ../raspberry_pi/rpi_gateway.py -b 192.168.2.186 PID = 6216 The Web browser will be launched on the PC. We then check the Raspberry Pi and see that the Raspberry Pi Gateway was started: We may now start using the Web page on our PC to control the Raspberry Pi remotely. Killing All The Processes To kill all the computers' processes, open another terminal window on your pc and type blk (the Banyan Launch Killer): $ blk ************************************************************ Launcher Killer using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ If we check the terminal window where we invoked bls, we now see: $ bls -f h_r_dist.csv ************************************************************ Banyan Launch Server using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ backplane PID = 10887 python3 ../shared/ws_gateway.py PID = 10912 ************************************************************ WebSocket Gateway using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 ************************************************************ python3 ../shared/open_browser.py rpi PID = 10916 ACKrpi_remote ACKrpi_remote: python3 ../raspberry_pi/rpi_gateway.py -b 192.168.2.186 PID = 2938 killall backplane PID = 10887 KILLED python3 ../shared/ws_gateway.py PID = 10912 KILLED python3 ../shared/open_browser.py rpi PID = 10916 KILLED And now, if we look at the terminal window on the Rasbpberry Pi where we invoked blc, we see: Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"OneGPIO Demos"},{"location":"one_gpio_demos/#introduction-to-the-demos","text":"This section will introduce three demonstration programs that control the Arduino, ESP-8266, and Raspberry Pi hardware targets, using common OneGPIO Application Components. The demo programs included are: An LED blink program. A Tkinter GPIO Demonstration Station. A Web-based GPIO Demonstration Station. A single OneGPIO Application Component is provided for the blink demo and one for the Tkinter demo, each containing the GPIO control logic to run their respective demos. For the Web Demonstration stations, the logic is coded in JavaScript within the Web page. The Web page connects to the Banyan network through the WebSocket Gateway. OneGPIO formatted messages are JSON encoded on the Webpage and then sent to the WebSocket Gateway.","title":"Introduction To The Demos"},{"location":"one_gpio_demos/#prerequisites","text":"","title":"Prerequisites"},{"location":"one_gpio_demos/#all-hardware-platforms","text":"Make sure that you have the newest version of python-banyan on your computer. You can upgrade to the latest version using the pip --upgrade option. In addition to installing Python Banyan, you will need to download the latest python-banyan distribution files to your computer to run the demos. To download, go to the Python Banyan Github Web page and click on the green download button and unzip to any directory. All of the demos may be launched manually, that is, bringing up each component individually. However, it is much simpler to use the Banyan Launcher, and therefore we will use it to launch each demo. To review the information about the launcher, click on this link. The Banyan launcher is automatically installed as an executable when you install the python-banyan distribution. The launcher requires a command-line option to load a Launcher specification file. Launcher specification files have been provided for each demo and for each platform. Modifications that you may need to be made to these files will be covered in each demo section.","title":"All Hardware Platforms"},{"location":"one_gpio_demos/#python-37","text":"Both the Arduino Gateway and WebSocket Gateway requires the use of Python 3.7 or higher. You may install and manage multiple versions of Python by using pyenv. With pyenv, you can set a specific directory to use the latest version of Python by using the pyenv local command. You may also create a virtual environment for a given directory using pyenv virtualenv . Again, this will all be accomplished via the Banyan launcher and will be covered in the Web Demonstration Station section of this document for the Raspberry Pi. Since the Windows Operating System is not dependent upon Python, it is probably easiest to install the latest version of Python3 on your computer from python.org .","title":"Python 3.7"},{"location":"one_gpio_demos/#arduino","text":"The Arduino Gateway was implemented using the python-express GPIO library. Install python-express on your computer and firmata-express on your Arduino.","title":"Arduino"},{"location":"one_gpio_demos/#esp-8266","text":"A NodeMCU ESP-8266 development module was used to test the demo programs. AA custom MicroPython script was developed to work with the ESP-8266 Gateway, and this script must be installed on the ESP-8266. It and may be found here. This script is a \"minified\" version to allow it to fit on the device. A fully commented file is provided here. It is assumed that you already know how to flash a program onto the ESP-8266. If you need some information on flashing the ESP-8266, the program I use to manage ESP-8266 image files is Adafruit Ampy. The Ampy Web page says that only CircuitPython is supported. But you can ignore that warning and use it to install the OneGPIO MicroPython script. The ampy command-line I use is: ampy -p /dev/ttyUSB0 put esp_8266.py You will need to re-power the board after flashing. The red LED should flash and then stay lit. It will extinguish when the board successfully connects to the ESP-8266 OneGPIO Gateway. NOTE: You will need to know the TCP/IP address of your ESP-8266 and present that as a command-line argument to the ESP-8266 Gateway.","title":"ESP-8266"},{"location":"one_gpio_demos/#raspberry-pi","text":"The Raspberry Pi has no additional requirements unless you wish to install Python 3.7. The demos were tested with \"Raspbian Stretch with desktop and recommended software,\" with a release date of 2019-04-08. If you are running the demos within a pyenv Python 3.7 or higher virtual environment, the Raspberry Pi Gateway may not be able to import pigpio. To test this out, when in the virtual environment, start-up Python and type import pigpio. pi@RPi3:~ $ cd 37* (python-banyan) pi@RPi3:~/37stuff $ python Python 3.7.3 (default, Apr 26 2019, 09:58:44) [GCC 6.3.0 20170516] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import pigpio >>> If no errors are reported, you are good to go. If you see an import error, you will need to manually move a copy of pigpio.py to the virtual environment. If you are using the version of pigpio included with the Raspbian distribution, you can find pipgio.py in the /usr/lib/python3/dist-packages/ directory. If you rebuilt pigpio to use the latest version, then you can find the pigpio.py file in the PIGPIO directory that was created during the build process. The pigpio.py file needs to be copied to a directory in the ~/.pyenv directory. For my pyenv virtual environment, I used Python 3.7.3 and named the virtual environment python_banyan. I needed to copy the file to: ~/.pyenv/versions/3.7.3/python-banyan/lib/python3.7/site-packages/ Here is the general template for this path: ~/.pyenv/versions/PYTHON VERSION/VIRTUAL ENVIRONMENT NAME/lib/PYTHON VERSION WITHOUT LAST NUMBER/site-packages/","title":"Raspberry Pi"},{"location":"one_gpio_demos/#the-demo-examples","text":"All of the demos are launched using the Banyan Launcher. The launcher specification files utilize a relative path to access the components for the applications. As a result, you must maintain the directory structure of the python-banyan distribution. If you haven't downloaded the distribution yet, you may do so by clicking on the green download button found on this link and then unzip the files. The launcher files may be found in the projects/OneGPIO/launch_scripts directory or the projects/OneGPIO/launch_scripts_for_windows directory. You will find the Banyan Launcher specification files used for each demonstration and for each hardware target in those directories. The difference between the Windows and non-Windows specifications files is that the command to invoke python is different. Windows uses python , while the other platforms use python3. The specification files are csv (comma-separated value) files. They may need to be modified for your specific environment. Those modifications will be discussed within the discussions for each specific demonstration.","title":"The Demo Examples"},{"location":"one_gpio_demos/#blink-demo","text":"You can view the source code for the blink demo here.","title":"Blink Demo"},{"location":"one_gpio_demos/#running-the-blink-demo-on-the-arduino","text":"To run this demo for the Arduino, you must use Python 3.7 or higher, as mentioned above. Let's look at the b_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,5 python3 ../shared/blinker.py -g 10,no,local,no,no,0 The default hardware target for blinker.py is the Arduino, and therefore we do not need to specify it here. The only change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 10 - modify this value to meet your needs. To run this demo: Plug the Arduino into your computer. Go into the launch_scripts directory and type: bls -f b_a.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_a.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink.","title":"Running The Blink Demo On The Arduino"},{"location":"one_gpio_demos/#running-the-blink-demo-on-the-esp-8266","text":"Let's look at the b_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.183,no,local,no,no,0 python3 ../shared/blinker.py -d esp8266 -g 13,no,local,no,no,0 There are 2 changes you may need to make for this file. The first is the IP address of the computer that the esp8266_gateway is running on. This is specified with the -i option on the second line. For my environment, that address is 192.168.2.183, but yours is likely to be different. The second change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 13 - modify this value to meet your needs. The blinker.py script also needs to have the target hardware type defined using the -d option. To run this demo: Power up the ESP-8266. Go into the launch_scripts directory and type: bls -f b_e.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_e.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink.","title":"Running The Blink Demo On The ESP-8266"},{"location":"one_gpio_demos/#running-the-blink-demo-on-the-raspberry-pi","text":"The Raspberry Pi Gateway utilizes the pigpio API library. When the Raspberry Pi Gateway is invoked, it will check to see if the pigpio daemon is currently running. If not, it will automatically start it. The pigpio library may report an error, as shown in this screenshot. It can safely be ignored since the gateway will automatically start the daemon. The daemon will continue running even after the gateway is closed. Let's look at the b_r.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,local,no,no,0 python3 ../shared/blinker.py -d rpi -g 4,no,local,no,no,0 The only change you may need to make is on the third line, the -g option. This option sets the pin number for the connected LED. The default is set to 4 - modify this value to meet your needs. To run this demo: Power up the Raspberry Pi. Go into the launch_scripts directory and type: bls -f b_r.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the b_r.csv specification file. When you hit return, everything needed to run this demo will be loaded, and you should see the LED on the pin you specified blink.","title":"Running The Blink Demo On The Raspberry Pi"},{"location":"one_gpio_demos/#tkinter-demo-station","text":"The Tkinter Demo Station is a GUI application that will allow you to remotely interact with the target hardware. A common python script, banyan_tkinter_demo.py, is used for all three targets and is a OneGPIO Application Component. The target type is supplied as a command-line parameter when invoking banyan_tkinter_demo. This is provided in each of the launcher specification files.","title":"Tkinter Demo Station"},{"location":"one_gpio_demos/#tkinter-demo-station-functions","text":"The Tkinter Demo Station for the Arduino is shown above. No matter the target hardware, the Tkinter Demo Station for all target hardware types share common capabilities.","title":"Tkinter Demo Station Functions"},{"location":"one_gpio_demos/#digital-output-control","text":"The Tkinter Demo Station allows you to set the state of a digital output pin. To use this feature, you first select the pin number, then the pin's output value, and finally, you set the state by pressing the Set Output State button.","title":"Digital Output Control"},{"location":"one_gpio_demos/#pwm-output-control","text":"To set a PWM output pin, first, select the pin number and then use the slider to set its output value.","title":"PWM Output Control"},{"location":"one_gpio_demos/#buzzer-tone-control","text":"Select the pin, then set the frequency in HZ and duration in milliseconds for the tone. Press the Play Tone button to generate the tone.","title":"Buzzer Tone Control"},{"location":"one_gpio_demos/#digital-input","text":"Select and enable digital input for a pin by clicking on the white box to the left of the pin number. The box to the pin number's right will be black if the pin value is zero and red if it is a one. If a pin is enabled for digital input, its current state will be shown in real-time.","title":"Digital Input"},{"location":"one_gpio_demos/#running-the-tkinter-demonstration-station-for-arduino","text":"Let's look at the tk_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,4 python3 ../shared/banyan_tkinter_demo.py -d arduino,no,local,no,no,0 You should not have to make any changes to this specification file. To run this demo: Connect the Arduino to your computer. Go into the launch_scripts directory and type: bls -f tk_a.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_a.csv specification file. You should see a Tkinter window for the Arduino appear.","title":"Running The Tkinter Demonstration Station For Arduino"},{"location":"one_gpio_demos/#running-the-tkinter-demonstration-station-for-the-esp-8266","text":"Let's look at the tk_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.185,no,local,no,no,0 python3 ../shared/banyan_tkinter_demo.py -d esp8266,no,local,no,no,0 You most likely will have to specify the IP address of the computer that is running the esp8266 gateway. This is done on line 2 of the file with the -i option. To run this demo: Power the ESP-8266 Go into the launch_scripts directory and type: bls -f tk_e.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_e.csv specification file. You should see a Tkinter window for the ESP-8266 appear.","title":"Running The Tkinter Demonstration Station For The ESP-8266"},{"location":"one_gpio_demos/#running-the-tkinter-demonstration-station-for-raspberry-pi","text":"Let's look at the tk_r.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,local,no,no,0 python3 ../shared/banyan_tkinter_demo.py -d rpi,no,local,no,no,0 You should not have to make any changes to this specification file. To run this demo: Power the Raspberry Pi. Go into the launch_scripts directory and type: bls -f tk_r.csv The bls command starts the Banyan Launcher server, and the -f option instructs bls to load the tk_r.csv specification file. You should see a Tkinter window for the Raspberry Pi appear.","title":"Running The Tkinter Demonstration Station For Raspberry Pi"},{"location":"one_gpio_demos/#banyan-demonstration-station-web-pages","text":"Once again, the Banyan launcher will be used to run Web page demos. The launcher will start the Backplane, the Gateway for the hardware target, the WebSocket Gateway. It will also start your Web browser with the correct HTML page loaded. By clicking on the following links, you may view the HTML pages for the Arduino , ESP-8266 , and Raspberry Pi. The pages of the Demonstration Station may vary slightly between hardware targets. But all use the OneGPIO messaging specification, allowing the target hardware gateway to handle the messaging. There is a common set of functions, selected by tab, for all of the targets: Digital Input Digital Output Including PWM Analog Input Servo Motor Control I2C Read and Write Piezo Buzzer Tone Generation Monitoring of an HC-SR04 Sonar Distance Sensor Stepper Motor Control Note Analog Input is supported for the Raspberry Pi by using a PCF8591 A/D i2c converter. The digital and analog tabs will display a timestamp for the last change to an enabled pin, and the pin's value:","title":"Banyan Demonstration Station Web Pages"},{"location":"one_gpio_demos/#running-the-web-demo-station-for-the-arduino","text":"Let's look at the h_a.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../arduino_uno/arduino_gateway.py,no,local,no,no,5 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py,no,local,no,no,5 You should not need to make any modifications to this file. To run this demo: Plug the Arduino into your computer Go into the launch_scripts directory and type: bls -f h_a.csv","title":"Running The Web Demo Station For The Arduino"},{"location":"one_gpio_demos/#running-the-web-demo-station-for-the-esp-8266","text":"Let's look at the h_e.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../esp_8266/esp8266_gateway.py -i 192.168.2.185,no,local,no,no,4 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py esp8266,no,local,no,no,5 You will most likely need to modify the IP address in line 2 following the -i option. To run this demo: Power the ESP-8266 Go into the launch_scripts directory and type: bls -f h_e.csv","title":"Running The Web Demo Station For The ESP-8266"},{"location":"one_gpio_demos/#running-the-web-demo-station-for-the-raspberry-pi-without-python-37-installed","text":"If you do not have Python 3.7 or higher installed on your Raspberry Pi, you may still run this demo. Because Banyan allows us to distribute Banyan components across computers, we run the Web server and WebSocket Gateway on our PC and the Raspberry Pi Gateway on the Raspberry Pi. The launcher was designed to handle these situations. First, we need to start the Banyan Launcher Client (blc) on the Raspberry Pi using a command-line similar to this one: blc -t rpi_remote -b 192.168.2.186 The -t option is a topic that will be used when the Banyan Launcher Server (bls) publishes its launcher messages. The -b option is the IP address of the PC, where we will launch bls. You will most likely have to modify the IP address when executing this command. The topic may be any string as long as both bls and blc use the same string. Here is what you will see on the Raspberry Pi after starting blc: Now, let's look at the h_r_dist.csv launcher specification file in the launch_scripts directory. command_string,spawn,topic,append_bp_address,auto_restart,wait python3 ../raspberry_pi/rpi_gateway.py,no,rpi_remote,yes,no,5 python3 ../shared/ws_gateway.py,no,local,no,no,1 python3 ../shared/open_browser.py rpi,no,local,no,no,1 You should not need to make any modifications to this file. Note that the topic field, in line 2, was set to rpi_remote, and the append_bp_address field, in line 2, was to yes. Now, let's start bls on our PC: $ bls -f h_r_dist.csv ************************************************************ Banyan Launch Server using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ backplane PID = 15856 python3 ../shared/ws_gateway.py PID = 15881 ************************************************************ WebSocket Gateway using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 ************************************************************ python3 ../shared/open_browser.py rpi PID = 15885 ACKrpi_remote ACKrpi_remote: python3 ../raspberry_pi/rpi_gateway.py -b 192.168.2.186 PID = 6216 The Web browser will be launched on the PC. We then check the Raspberry Pi and see that the Raspberry Pi Gateway was started: We may now start using the Web page on our PC to control the Raspberry Pi remotely.","title":"Running The Web Demo Station For The Raspberry Pi Without Python 3.7 Installed"},{"location":"one_gpio_demos/#killing-all-the-processes","text":"To kill all the computers' processes, open another terminal window on your pc and type blk (the Banyan Launch Killer): $ blk ************************************************************ Launcher Killer using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ If we check the terminal window where we invoked bls, we now see: $ bls -f h_r_dist.csv ************************************************************ Banyan Launch Server using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 Loop Time = 0.1 seconds ************************************************************ backplane PID = 10887 python3 ../shared/ws_gateway.py PID = 10912 ************************************************************ WebSocket Gateway using Back Plane IP address: 192.168.2.186 Subscriber Port = 43125 Publisher Port = 43124 ************************************************************ python3 ../shared/open_browser.py rpi PID = 10916 ACKrpi_remote ACKrpi_remote: python3 ../raspberry_pi/rpi_gateway.py -b 192.168.2.186 PID = 2938 killall backplane PID = 10887 KILLED python3 ../shared/ws_gateway.py PID = 10912 KILLED python3 ../shared/open_browser.py rpi PID = 10916 KILLED And now, if we look at the terminal window on the Rasbpberry Pi where we invoked blc, we see: Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Killing All The Processes"},{"location":"users_guide/","text":"The Python Banyan User's Guide What is Python Banyan? Python Banyan is a lightweight, reactive framework used to create flexible , non-blocking, event-driven, asynchronous applications. It was designed primarily to aid in implementing real-time physical computing applications for devices such as the Raspberry Pi, ESP8266, and Arduino. Still, it may easily be applied to projects outside of the physical programming domain. Banyan uses a publish/subscribe model similar to MQTT but is much faster than MQTT in real-time control and data monitoring applications. A benchmark comparison of Banyan and MQTT is provided later in this guide to illustrate Banyan's efficiency. If your application requires connectivity to an MQTT broker, a Gateway is provided. Most traditional physical computing libraries or frameworks use an object-oriented model that yields a single, tightly coupled, monolithic executable image. Python Banyan uses an extension of the object-oriented model, called the component-based service-oriented architectural model. A component-based application consists of a set of independent, loosely coupled components . For python-banyan, these components communicate with one another through a set of platform-independent, user-defined protocol messages transmitted over a TCP network. A Banyan application is composed of a set of components running concurrently as separate processes. These components can be developed using a single language platform such as Python, or developed using any of the other Banyan frameworks. There are versions of Banyan available for JavaScript , Ruby , and Java . Components developed using dissimilar languages can be combined without modification to form a single, cohesive application. Banyan uses a central message distribution mechanism called the Backplane . When first starting a Banyan application, the Backplane is brought on-line, followed by the application's components. At startup, each component automatically \"plugs\" itself into the Backplane establishing a TCP/IP communication channel between itself and the Backplane. After communication is established, components may publish messages to the Backplane, receive messages from other components, or both publish and receive messages. A major feature of Python Banyan is that it can incorporate Numpy data into a protocol message seamlessly and effortlessly. Without modification, a Banyan application's components can run on a single computer or distributed across multiple computers. These configurations will be demonstrated later on in this document. A Little More Detail About Python Banyan Banyan Base Classes All Banyan components are created by inheriting from one of the supplied Banyan base classes. The base class methods are overridden as needed to support the component's specific needs. The base classes act as a wrapper for the ZeroMQ embeddable networking library that has been configured to operate in a Publish/Subscribe networking pattern. Also, the base class encodes and decodes protocol messages for efficient network transmission, using MessagePack . Banyan Protocol Messages Banyan protocol messages consist of 2 parts, a \"topic\" and a \"payload.\" The Topic String A message topic consists of a simple string. For a component to receive messages with a set of given topics, a component subscribes to receive messages for each topic. A subscribing component receives all messages published containing the desired topic. Prefix Matching When a message is received, the topic is compared to the subscribed topic. If it matches, the message is placed on the component's receive queue. Any topic that begins with the subscribed topic string is considered a match even if the received message topic contains additional text. For example, if you subscribe to the topic \"abcd,\" and a message is received with a topic of \"abcde,\" the \"abcde\" message will be placed on the receive queue. Any messages with topics that begin with the subscribed topic string are considered a match even though the topic may contain additional text. The Message Payload Message payloads consist of a Python dictionary type structure, containing one or more name/value items. By utilizing a dictionary, message data can be quickly de-referenced and processed. Because Banyan messages are not computer language-specific, components written in other computer languages, such as JavaScript, can be used within a Python Banyan application. A simple JavaScript demo is provided as one of the included examples. Where Is Python Banyan Being Used? Commercially, Python Banyan has been chosen by Palace Games in San Francisco to monitor and control their Palace Games Edison Room . The Edison room contains several hundred sensors and actuators. Banyan helps tie all the devices and their associated micro-controllers together, allowing them to communicate quickly and transparently. Banyan supports data transfers of Numpy data, which the Edison room uses to model their data efficiently. You can read about Palace Games on the Raspberry Pi Blog . Banyan is also being used in numerous physical computing projects utilizing the Raspberry Pi, Arduino, and ESP8266. An earlier version of Python Banyan, called razmq , was used to control a Raspberry Pi robot. Banyan Application Design When designing a Banyan Component, it is good practice to keep it as small as possible. By limiting a component to a small area of concern, testing is greatly simplified, and the potential for component reuse increases. Some Design Guidelines A component should subscribe to the minimal number of message topics as possible. Keep messages as short as possible. Limit the component to its task at hand. For example, if you wish to log application activity, create a specific logging component. All other components can take advantage of this logging facility in a consistent fashion. It also offloads logging I/O from the main component, promoting higher performance for the system as a whole. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"What Is Python Banyan?"},{"location":"users_guide/#what-is-python-banyan","text":"Python Banyan is a lightweight, reactive framework used to create flexible , non-blocking, event-driven, asynchronous applications. It was designed primarily to aid in implementing real-time physical computing applications for devices such as the Raspberry Pi, ESP8266, and Arduino. Still, it may easily be applied to projects outside of the physical programming domain. Banyan uses a publish/subscribe model similar to MQTT but is much faster than MQTT in real-time control and data monitoring applications. A benchmark comparison of Banyan and MQTT is provided later in this guide to illustrate Banyan's efficiency. If your application requires connectivity to an MQTT broker, a Gateway is provided. Most traditional physical computing libraries or frameworks use an object-oriented model that yields a single, tightly coupled, monolithic executable image. Python Banyan uses an extension of the object-oriented model, called the component-based service-oriented architectural model. A component-based application consists of a set of independent, loosely coupled components . For python-banyan, these components communicate with one another through a set of platform-independent, user-defined protocol messages transmitted over a TCP network. A Banyan application is composed of a set of components running concurrently as separate processes. These components can be developed using a single language platform such as Python, or developed using any of the other Banyan frameworks. There are versions of Banyan available for JavaScript , Ruby , and Java . Components developed using dissimilar languages can be combined without modification to form a single, cohesive application. Banyan uses a central message distribution mechanism called the Backplane . When first starting a Banyan application, the Backplane is brought on-line, followed by the application's components. At startup, each component automatically \"plugs\" itself into the Backplane establishing a TCP/IP communication channel between itself and the Backplane. After communication is established, components may publish messages to the Backplane, receive messages from other components, or both publish and receive messages. A major feature of Python Banyan is that it can incorporate Numpy data into a protocol message seamlessly and effortlessly. Without modification, a Banyan application's components can run on a single computer or distributed across multiple computers. These configurations will be demonstrated later on in this document.","title":"What is Python Banyan?"},{"location":"users_guide/#a-little-more-detail-about-python-banyan","text":"","title":"A Little More Detail About Python Banyan"},{"location":"users_guide/#banyan-base-classes","text":"All Banyan components are created by inheriting from one of the supplied Banyan base classes. The base class methods are overridden as needed to support the component's specific needs. The base classes act as a wrapper for the ZeroMQ embeddable networking library that has been configured to operate in a Publish/Subscribe networking pattern. Also, the base class encodes and decodes protocol messages for efficient network transmission, using MessagePack .","title":"Banyan Base Classes"},{"location":"users_guide/#banyan-protocol-messages","text":"Banyan protocol messages consist of 2 parts, a \"topic\" and a \"payload.\"","title":"Banyan Protocol Messages"},{"location":"users_guide/#the-topic-string","text":"A message topic consists of a simple string. For a component to receive messages with a set of given topics, a component subscribes to receive messages for each topic. A subscribing component receives all messages published containing the desired topic.","title":"The Topic String"},{"location":"users_guide/#prefix-matching","text":"When a message is received, the topic is compared to the subscribed topic. If it matches, the message is placed on the component's receive queue. Any topic that begins with the subscribed topic string is considered a match even if the received message topic contains additional text. For example, if you subscribe to the topic \"abcd,\" and a message is received with a topic of \"abcde,\" the \"abcde\" message will be placed on the receive queue. Any messages with topics that begin with the subscribed topic string are considered a match even though the topic may contain additional text.","title":"Prefix Matching"},{"location":"users_guide/#the-message-payload","text":"Message payloads consist of a Python dictionary type structure, containing one or more name/value items. By utilizing a dictionary, message data can be quickly de-referenced and processed. Because Banyan messages are not computer language-specific, components written in other computer languages, such as JavaScript, can be used within a Python Banyan application. A simple JavaScript demo is provided as one of the included examples.","title":"The Message Payload"},{"location":"users_guide/#where-is-python-banyan-being-used","text":"Commercially, Python Banyan has been chosen by Palace Games in San Francisco to monitor and control their Palace Games Edison Room . The Edison room contains several hundred sensors and actuators. Banyan helps tie all the devices and their associated micro-controllers together, allowing them to communicate quickly and transparently. Banyan supports data transfers of Numpy data, which the Edison room uses to model their data efficiently. You can read about Palace Games on the Raspberry Pi Blog . Banyan is also being used in numerous physical computing projects utilizing the Raspberry Pi, Arduino, and ESP8266. An earlier version of Python Banyan, called razmq , was used to control a Raspberry Pi robot.","title":"Where Is Python Banyan Being Used?"},{"location":"users_guide/#banyan-application-design","text":"When designing a Banyan Component, it is good practice to keep it as small as possible. By limiting a component to a small area of concern, testing is greatly simplified, and the potential for component reuse increases.","title":"Banyan Application Design"},{"location":"users_guide/#some-design-guidelines","text":"A component should subscribe to the minimal number of message topics as possible. Keep messages as short as possible. Limit the component to its task at hand. For example, if you wish to log application activity, create a specific logging component. All other components can take advantage of this logging facility in a consistent fashion. It also offloads logging I/O from the main component, promoting higher performance for the system as a whole. Copyright (C) 2017-2020 Alan Yorinks All Rights Reserved","title":"Some Design Guidelines"}]}