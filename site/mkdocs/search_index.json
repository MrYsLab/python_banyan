{
    "docs": [
        {
            "location": "/",
            "text": "Python Banyan\n\n\nA User's Guide\n\n\n\n\nWHAT IS PYTHON BANYAN?\n\n\nPython Banyan is a lightweight, reactive framework used to create flexible, non-blocking, event \ndriven, \nasynchronous applications. It was designed primarily to implement physical computing applications for devices such as\n the Raspberry Pi and Arduino, \nbut it is \nnot limited to just that domain, and may be used to create application in any domain.\n\n\nMost traditional physical computing libraries or frameworks use an \nobject oriented\n model that results in a single, \ntightly coupled, monolithic executable image. Python Banyan uses an extension of the object oriented model, called \nthe \ncomponent based\n model. A component based application is comprised of a set of independent, loosely \ncoupled \nmodules. Functionality is easily added to a Python Banyan application, and in fact it may be added to a fully running\n system without the need to recompile or reboot.\n\n\nBecause each module is a self contained entity, applications can be created with a set of modules that use \n different \n versions of Python, and in fact, \nyou can even add modules written in other computer languages.\n\n\nIn addition, the modules may be run on a single computer, or may be distributed across multiple computers running \n different operating systems, without having to change a single line of code.\n\n\nA Little More Detail\n\n\nThe Python Banyan Framework consists of a single, simple base class. All Banyan compatible components inherit from \nthis class. When a Banyan component is first invoked, it automatically connects to a common shared software backplane. \nAll \nof the complexity of managing connections is hidden within and handled by the base class. All Banyan modules\nexchange information with each another by sending or publishing user defined protocol messages via the backplane. All\n routing and message buffering is automatically handled by the Framework. Each \nBanyan \ncomponent can\n \"publish\" messages, \"subscribe\" to receive specific messages or both publish and subscribe messages. A Banyan \n component is not limited as to how many types of messages it may subscribe to.\n\n\nBecause Banyan messages are not computer language specific, components written in other computer Languages, such as \n JavaScript, can be used within a Python Banyan application. A simple JavaScript demo is provided in the \n examples section below.\n\n\nPython Banyan takes full advantage of the \nZeroMQ\n \n  networking library that not only provides \n connectivity, but in addition acts as a concurrency framework. All of this is handled transparently by the Python \n Banyan base class. If your application requires additional concurrency support, you are free to choose whatever \n works best for your application, such as a multi-threading or a Python asyncio approach. User defined messages are \n prepared for transport across the network by wrapping them in the \n \nMessage Pack format.\n \n\n\nThe complexities of \n MessagePack are handled transparently by the base class, both for transmitting and receiving messages.\n\n\nWhat's In This Guide\n\n\nThis is a hands-on guide. Several examples will be presented to get you acquainted with Python Banyan and its \ntechniques for use. Source code for all examples are available on Github. Links to the source code will be provided \nas each component is discussed.\n\n\nChapter 1\n is an introduction to developing with Python Banyan. An application tailored specifically for this \npurpose \nwill be presented in detail.\n\n\nIn chapter 2\n, a demonstration of, and a discussion about creating physical computing components with Python Banyan.\n\n\nTo demonstrate Python Banyan's flexibility, applications will be built from Python 2 components, Python 3 \ncomponents and even a JavaScript component, all cooperating and communicating with each other within a single \nPython Banyan application.\n\n\nPython Banyan applications may be distributed across multiple computers, all without changing a single line of code.\nUsing the components created in this guide, all of the components will first be launched to run on a Raspberry Pi, and \nthen\n then the components will be re-distributed across a Linux Ubuntu PC, a Windows PC and the Raspberry Pi without \n having to change a single line of code.\n\n\nIn \nChapter 3\n, we will add components to control an 8x8 bicolor LED matrix connected to a Raspberry Pi. A \ndemonstration of using Python Banyan to control an i2c device will be presented.\n\n\nIf you need to control multiple i2c devices sharing the same i2c pins, Python Banyan provides the concurrency support\n for you to do so.\n\n\nChapter 4\n will discuss how to use Python's setup tools to convert a \nBanyan component into an executable file and have it automatically installed on the execution path.\n\n\nBefore We Begin\n\n\nTo learn how to install Python Banyan, and all of the examples presented in this guide, please see \n\nthe Required Additional Software section in this guide\n.\n\n\nAfter following the installation instructions all of the example components are installed as \nexecutable modules.\n\n\nCHAPTER 1: \u00a0A SIMPLE 24 HOUR CLOCK\n\n\n\n\nIn this example, we will:\n\n\n\n\nLearn about the Python Banyan Backplane. \n\n\nTake a brief look at the Banyan base class, \nbanyan_base.py\n\n\nCreate the three components that make up this application\n\n\nLearn how to use the \nPython Banyan Monitor\n utility to test each component.\n\n\nCreate a Web based Python Banyan compatible GUI using the \n  \nremi\n \n  library.\n\n\nLaunching the components to form the application.\n\n\n\n\nThe Python Banyan Backplane\n\n\nThe backplane is installed as an executable module when Python Banyan is installed. The backplane \nmust be running\n \n  before the first Python Banyan application component is invoked.\n\n\nTo start the backplane, just open a command window and type:\n\n\n  backplane\n\n\n\n\nYou should see a welcome banner in the console.\n\n\n\n\nThe banner identifies the name of the program, \"Banyan Backplane\", the IP address of the computer on which the \n backplane is running, and the two IP port numbers to be used by all Python Banyan components. For \n applications\n  where all of the Python Banyan components are running on a single computer, this is purely informational. We will use\n  these values in a later example when we distribute the Banyan components across multiple computers.\n\n\nThe backplane is an implementation of a\n   \nZeroMQ forwarder device\n.\n\n\nA forwarder device collects messages from a set of publishers and forwards these messages to a set of subscribers. \n  This allows\n  all Python Banyan components to use a single IP address in conjunction with a set of well known port numbers to \n  send and receive messages.\n\n\nThis simplifies system configuration and no configuration files need to be maintained. \n\n\nThe backplane is invoked using a common coding pattern. Although not required, it is good practice to be used by \n  all Python Banyan components. This \n  pattern is used to create and install Banyan modules as an executable on the executable path. We will learn more \n  about this in \nChapter 4\n.\n\n\nFor the backplane, the bp() function near the end of the file, \n  instantiates the BackPlane class. It calls the \nrun_back_plane\n method to start the backplane, and additionally \n  attaches a \n  Control-C signal handler so \n  that the user can cleanly quit the program.\n\n\ndef bp():\n\n    \"\"\"\n    Instantiate the backplane and run it.\n    Attach a signal handler for the process to listen for user pressing Control C\n    :return:\n    \"\"\"\n\n    backplane = BackPlane()\n    backplane.run_back_plane()\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        backplane.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\nif __name__ == '__main__':\n    bp()\n\n\n\n\n\nA Brief Look At The \nThe Banyan Base Class\n\n\nEvery Python Banyan component must inherit from this class. Using a derived class called MyComponent as an example, \nhere is a pattern as to how the MyComponent class would begin.\n\n\nimport argparse\nimport signal\nimport sys\nimport time\nimport zmq\nimport umsgpack\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass MyComponent(BanyanBase):\n    \"\"\"\n    All the MyComponent class methods and overwritten BanyanBase methods would follow \n    below this point ...\n    \"\"\"\n\n\n\n\nThe banyan_base class contains 6 methods:\n\n\n1.\u00a0\u00a0__init__\n\n\n\n__init__(self, back_plane_ip_address=None, subscriber_port='43125', publisher_port='43124', \n               process_name='None', loop_time=0.1)\n\n           The __init__ method sets up all the ZeroMQ \"plumbing\"\n\n           :param back_plane_ip_address: banyan_base back_planeIP Address -\n                                         if not specified, it will be set to the\n                                         local computer\n           :param subscriber_port: banyan_base back plane subscriber port.\n                  This must match that of the banyan_base backplane\n           :param publisher_port: banyan_base back plane publisher port.\n                                  This must match that of the banyan_base backplane\n           :param process_name: Component identifier\n           :param loop_time: loop sleep time when no message is available\n           :return: No Return Value\n\n\n\n\n\nThis method establishes the connections to the Python Banyan Backplane. A derived class must initialize the parent class\nby using the super() method.\n\n\nsuper().__init__(back_plane_ip_address, subscriber_port, publisher_port, \n                         process_name=process_name, loop_time=loop_time)\n\n\n\n\nAny component specific initialization code is added as necessary.\n\n\n2.\u00a0\u00a0set_subscriber_topic\n\n\n\nset_subscriber_topic(self, topic)\n      This method registers a component to receive messages\n       containing the specified topic.\n\n       You can subscribe to multiple topics by calling this method for\n       each topic.\n\n       :param topic: A topic string\n       :return: No Return Value\n\n\n\n\n\nAll Python Banyan messages are published with an associated topic string. In order to receive messages published for a \ngiven topic, a component must register for those messages by calling \nset_subscriber_topic\n. This method is called \nfor each topic that the component wishes to receive.\n\n\nThis method encapsulates and hides the details of the ZeroMQ subscription process.\n\n\nThis method is typically not overwritten.\n\n\n3.\u00a0\u00a0publish_payload\n\n\n\n  publish_payload(self, payload, topic='')\n           This method will publish a python_banyan payload and its associated topic\n\n           :param payload: Message data, typically in the form of a Python dicationary.\n           :param topic: A string value\n           :return: No Return value\n\n\n\n\n\n\nMessages are published as \nmulti-part\n messages consisting of a topic in the form of a string, and the payload, which\nis normally represented as a Python dictionary.\n\n\nThis method publishes a message by wrapping the payload in the MessagePack transport format and presenting both the \nthe payload and topic to the low level ZeroMQ publish method.\n\n\nThis method encapsulates and hides the details of the ZeroMQ publishing process.\n\n\nThis method is typically \nnot\n overwritten.\n\n\n4.\u00a0\u00a0receive_loop\n\n\n\n  receive_loop(self)\n           This is loops wait to receive any incoming messages.\n\n           This method may be overwritten to meet the needs\n           of the application before handling received messages.\n\n           :return: This method never returns.\n\n\n\n\nSubscribed messages are received in this \nnon-blocking event loop\n. \n\n\nThe receive_loop continually checks to see if ZeroMQ has delivered a message. If no message is \navailable, ZeroMQ throws a \nzmq.error.Again\n \nexception. When this exception occurs, the exception handler sets a short sleep interval, and then checks again.\nIf a message is available, this method calls the incoming_message_processing method.\nThe default value for the sleep delay is 0.1 seconds, but this value may be changed by setting the loop_time \nparameter in __init__.\n\n\n5.\u00a0\u00a0incoming_message_processing\n\n\n\n  incoming_message_processing(self, topic, payload)\n           Override this method with a custom python_banyan message\n           processor for subscribed messages\n\n           :param topic: Message Topic string\n           :param payload: Message Data\n           :return: No Return Value\n\n\n\n\nThis method is called by the receive_loop method for each message received. The message topic and payload are passed to \nthis method for processing. \n\n\nThis method must be overwritten to \nprocess the incoming messages.\n\n\n6.\u00a0\u00a0clean_up\n\n\n\n  clean_up(self)\n           Clean up before exiting - override if additional cleanup is necessary\n\n           :return: No Return Value\n\n\n\n\nThis method attempts to cleanly shutdown a Python Banyan component. Any additional clean up for your component may be\n placed in this method.\n\n\nDesigning For Python Banyan\n\n\nThe first step in designing a Python Banyan application is to define the feature set for the application. \nAn application may contain a single feature, such as in the first example we will cover, or it may contain many \nfeatures, such as the control and monitoring of a robotic vehicle.\n\n\nFeatures are comprised of individual Python Banyan components.\n\n\nFeatures should be designed to be as independent from other features as possible, and the components that comprise \nthe feature, should implement very targeted and specific behavior.\n\n\nFor example, a robot vehicle is likely to require motor control for speed and direction, and when the \nmotors are \nturning, wheel encoder telemetry may be generated.\n\n\nOne might think to combine both the motor control and encoder processing into a single feature, but it is probably \nbest to think of these as 2 separate features. The reason being, if you keep them separate you can reuse both \nfeatures in different scenarios without having to have one component carry the baggage of the other.\n\n\nOnce deciding upon a set of features, we need to go one level further deeper in decomposition, \nand that is to define our components. \n\n\nOur initial clock demo is a rather simple one, so there is only a single feature - display the current time on a Web \npage. \n\n\nFor the clock demo, the feature can be broken down into three components. we will build three components as described \nbelow: \n\n\n\n\n\n\nA \none second \"tick\" event generator\n. This component will publish a \"tick event\" message once every second. The \nmessage is \nconsistent with all other Python Banyan messages. It would be advantageous if this component could optionally set the\n tick period to be something other than one second so that testing can be accelerated, and so that the component \n could be reused in other features.\n\n\n\n\n\n\nA \ntick processor\n. This component subscribes to the \"tick event\" messages generated by the tick generator. It \naccumulates these ticks to form the \ncurrent time in seconds, minutes, and hours. Each unit is handled as a separate entity. When a tick message is \nreceived, \na seconds accumulator is incremented and tested to see if the seconds have reached a value of 60. If so the second \naccumulator is reset to 0, the minutes accumulator is incremented and an update message for the minutes is published.\n If the accumulated seconds is less \nthan 60, only an update message for seconds is published.\nThe processing\n of hours is handled in a very similar fashion.\n\n\n\n\n\n\nThe \nclock GUI\n.\nThe GUI is a Web page display. It subscribes to and receives second_update, minute_update and hour_update messages. When\none of these messages is received, the display for that category is updated to the value in the message.\n\n\n\n\n\n\nNow that we described what each component will do, it is time to design the messaging protocol for each component.\n \nUML sequence diagrams\n \ncan be helpful to capture the \nmessaging design.\n\n\n\n\nThis diagram captures what happens when the TickCounter receives a tick message. The current time had \nbeen 14:59:59. Because each of the time units needs to be advanced, a message for each unit type is generated and \nsent to the GUI. If a unit does not need to be advanced, no message is sent for that unit. \n\n\nThe sequence diagram shows the message originator and a sample of the message contents. So for example, a message with\n a topic of \"update_minutes\" is being sent to the GUI with a payload of {\"minutes: '06'}. By using a Python dictionary \n as\n the payload, the receiving class can easily dereference the contents of the payload.\n\n\nImplementing The \nTick Generator Component\n\n\nNow that we have our component and interface design complete, we may proceed to implement the design. For this \nexample, we will be running all components on a single computer. This application has been tested on a Raspberry Pi \nrunning Raspbian, on a desktop computer running Ubuntu 16.10, and on a Windows 10 computer.\n\n\n\n# tick_generator.py\n\nfrom __future__ import absolute_import\nimport argparse\nimport signal\nimport sys\nimport time\n\ntry:\n    from python_banyan.banyan_base import BanyanBase\nexcept ImportError:\n    from python_banyan import BanyanBase\n\n\nclass TickGenerator(BanyanBase):\n    \"\"\"\n    This class will publish a \"tick\" message on a periodic basis. The period default\n    is 1 seconds, but may be set by the tick_duration_time parameter\n\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124',\n                 process_name='None', loop_time=.1, tick_duration_time=1.0, ):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        :param tick_duration_time:\n        \"\"\"\n        # initialize the base class\n        super(TickGenerator, self).__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                                            process_name=process_name,\n                                            loop_time=loop_time)\n\n        # allow time for ZeroMQ connections to form\n        time.sleep(.03)\n\n\n\ndef tick_generator():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-d\", dest=\"tick_duration_time\", default=\"1.0\",\n                        help=\"Set tick duration time\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Local Tick_Generator\", help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n    kw_options['tick_duration_time'] = float(args.tick_duration_time)\n\n    my_tick_gen = TickGenerator(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_gen.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_generator()\n\n\n\n\n\n\nThe source for the tick generation component is shown above. This component only publishes information and does not \nsubscribe\n to receive any messages. It consists of\nthe \n\nTickGenerator\n class \nthat \ncontains a \nsingle \nmethod, __init__, which overrides the __init__ method of the base class. There is also a function named, \n\ntick_generator\n that is defined outside of \nthe class.  This is an instantiation function \nthat is called by a \nstandard Python \ninvocation of:\n\n\nif __name__  == '__main__':\n\n\nLet's look at the code. \n\n\nFirst, after importing some standard Python modules, we import the Python Banyan BaseClass. We then define the \ncomponent's class inheriting BanyanBase:\n\n\n\nimport argparse\nimport signal\nimport sys\nimport time\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass TickGenerator(BanyanBase):\n\n\n\n\n\nNow let's look at the __init__ method.\n\n\nThe first thing that the __init__ method does is initialize the parent class by calling super(). \n\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124',\n                 process_name='None', loop_time=.1, tick_duration_time=1.0, ):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        :param tick_duration_time:\n        \"\"\"\n\n        # initialize the base class\n        super(TickGenerator, self).__init__(back_plane_ip_address, subscriber_port,\n                                             publisher_port, process_name=process_name,\n                                            loop_time=loop_time)\n\n        # allow time for ZeroMQ connections to form\n        time.sleep(.03)\n\n\n\n\nThe signature of this derived method is similar to the parent, and all common arguments are passed to the parent \nwhen super() is called. There is an additional parameter, tick_duration_time, and this parameter allows us to \noptionally set \nthe \nperiod of a tick at invocation time. This is useful both for testing purposes, and if we wish to reuse this \ncomponent in some other feature.\n\n\nAs we shall see, this forms a pattern for all Python Banyan components. That is, a call to super() initializes the \nparent, and then there is a short waiting time to allow all ZeroMQ connections to be succeed. Note \nthat the parent class\n handles all of the connection details of ZeroMQ and are purposefully hidden from the derived class.\n\n\nThe __init__ method is extended with the following code:\n\n\n\n        self.tick_duration_time = tick_duration_time\n\n        self.tick_topic = 'tick'\n        self.tick_payload = {'tick': True}\n\n        # This is a forever loop that publishes a tick message, once per second\n        while True:\n            try:\n                self.publish_payload(self.tick_payload, self.tick_topic)\n                time.sleep(self.tick_duration_time)\n            except KeyboardInterrupt:\n                sys.exit(0)\n\n\n\n\n\nVariables are created and initialized. These variables save the tick duration time, and hold the message topic and \npayload.  The \ncode then \nenters a \n\"forever\" loop. This loop calls the parent method, \npublish_payload\n with the topic and payload for the tick. The \nmethod sleeps for the duration_time and then repeats.\n\n\nThe function outside of the class, tick_generator(), shown below,  although not required, demonstrates a Python Banyan \npattern \nto include command line arguments for the component as well as attaching a signal handler to allow a user to kill the\n component by pressing Control C. By combining this pattern with the \nif __name__  == \n '__main__':\n \nconstruct, setup.py has the capability to  automatically install the module as an executable on the executable path. We \nwill discuss this capability in \nChapter 4\n.\n\n\nThe name of the component printed to the console is specified in this function by the default value for the process \nname.\n\n\ndef tick_generator():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-d\", dest=\"tick_duration_time\", default=\"1.0\",\n                        help=\"Set tick duration time\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Local Tick_Generator\", \n                        help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n    kw_options['tick_duration_time'] = float(args.tick_duration_time)\n\n    my_tick_gen = TickGenerator(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_gen.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_generator()\n\n\n\n\n\nTo see the available command line arguments for the component we invoke the component with a -h argument on the \ncommand line:\n\n\npython3 tick_generator.py -h\nusage: tick_generator.py [-h] [-b BACK_PLANE_IP_ADDRESS]\n                         [-d TICK_DURATION_TIME] [-n PROCESS_NAME]\n                         [-t LOOP_TIME]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -b BACK_PLANE_IP_ADDRESS\n                        None or IP address used by Back Plane\n  -d TICK_DURATION_TIME\n                        Set tick duration time\n  -n PROCESS_NAME       Set process name in banner\n  -t LOOP_TIME          Event Loop Timer in seconds\n\n\n\n\n\n\nFor the purposes of this demo, we can accept all of the defaults. \nThe BACK_PLANE_IP_ADDRESS is used when we wish to run this component on a computer different from the computer that \nis running the backplane. We will see an example of this in a later demo. \n\n\nThe TICK_DURATION_TIME option allows us to set the period of the generated tick. \n\n\nThe PROCESS_NAME is an identifier that will be printed to the console when we start the component.\n\n\nThe LOOP_TIME allows us to modify the maximum amount of time that the Python Banyan received_loop waits before checking \nfor the next message to arrive. We will accept the default for this component\n\n\nAll of the command line arguments use the \n \nPython argparse module\n \nin a standard fashion.\n\n\nExecuting The Tick Generator Component\n\n\nBefore executing the first component of a Banyan application, the backplane must already be running. When Banyan is \ninstalled, \nthe backplane is installed as an executable on the executable path. To start the backplane, open up a command window,\n and type \nbackplane\n.\n\n\n\n\nNext, open another command window and start the component. \nIf you installed the examples using \npip\n, then simply open up a command window and type tick_generator.\n\n\n\n\nOr you if you cloned or forked the \npython_banyan_examples\n repository, go to the \ndirectory that \ncontains \ntick_generator.py, and then invoke it with python3:\n\n\n\n\nNotice that backplane address and publisher and subscriber ports match between the backplane and the tick generator. \nThis happens automatically as result of inheriting the BanyanBase class.\n\n\nTesting The Tick Generator Component - Introducing \nThe Monitor\n\n\nNow that we have the backplane and the tick generator running, let's verify that the messages being published are \nwhat we designed. With the backplane and tick_generator running, start the monitor by opening a new command window \nand typing:\n\n\nmonitor\n\n\n\n\n\n\nThe monitor program is simply another Banyan component that can be plugged into or removed from the backplane at \nanytime.\n\n\nWe see that the topic and payload for each of the tick generator messages is displayed by the monitor.\n\n\nThe topic, \"tick\" is followed by the payload - {'tick': True}. \n\n\nLet's compare this to our design:\n\n\n\n\nThe message matches perfectly with what we designed, we can go on to coding the next component.\n\n\nIf you do not see any messages on the monitor, make sure that the backplane is running. Also you may need to adjust the \nconnection wait time in \nyour \ncomponent:\n\n\n\n# allow time for ZeroMQ connections to form\n        time.sleep(.03)\n\n\n\n\nBe aware that when the monitor is attached to the backplane, it may affect performance of your application \nsince printing to the console can be quite time consuming.\n\n\nImplementing \nThe Tick Counter\n Component Part 1\n\n\nThe tick processor subscribes to 'tick' messages, accumulates the ticks, processes the ticks and publishes \nupdate messages for seconds, minutes and hours.\n\n\n# tick_counter.py\n\nimport argparse\nimport signal\nimport sys\nimport time\nimport datetime\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass TickCounter(BanyanBase):\n    \"\"\"\n    This class receives subscribes for tick messages\n\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125', \n    publisher_port='43124', process_name=None, loop_time=.1):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        \"\"\"\n        # initialize the base class\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port, \n                         process_name=process_name, loop_time=loop_time)\n\n        # allow time for ZeroMQ connections\n        time.sleep(.03)                         \n\n        # event message from RPi\n        self.set_subscriber_topic('tick')\n\n        # get the current time\n        current_time = datetime.datetime.now().time()\n\n        # set up some unit accumulator variables\n        self.hours = self.prev_hour = current_time.hour\n        self.minutes = current_time.minute\n        self.seconds = current_time.second\n\n        # publish the time for all 3 accumulators\n        self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n        self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n        self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        # receive loop is defined in the base class\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, \n                                          'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, \n                                          'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\ndef tick_counter():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                         help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Tick Counter\", \n                         help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", \n                         help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n\n    my_tick_counter = TickCounter(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_counter.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_counter()\n\n\n\n\n\nIf you compare this file with the tick generator, you will notice some very similar patterns. The invoking functions \nat the end of each file are almost identical, so we won't be discussing those again.\n\n\nAs do all Python Banyan component classes, the TickCounter class inherits the BanyanBase class. The __init__ method \nalso starts out with a standard pattern. The super() method is called and then there is a short wait time to allow \nfor the component to connect with the backplane.\n\n\nLet's look at where things begin to differ in __init__:\n\n\n        # event message from RPi\n        self.set_subscriber_topic('tick')\n\n        # get the current time\n        current_time = datetime.datetime.now().time()\n\n        # set up some unit accumulator variables\n        self.hours = self.prev_hour = current_time.hour\n        self.minutes = current_time.minute\n        self.seconds = current_time.second\n\n        # publish the time for all 3 accumulators\n        self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n        self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n        self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        # receive loop is defined in the base class\n        self.receive_loop()\n\n\n\n\n\nThe parent method, set_subscriber() is called to subscribe to receive 'tick' messages.\n\n\nThen the current time is read and the time unit variables are initialized with the current time values.\n\n\nWhen the payload is constructed, the value string for each of the accumulators is zero filled so that each value is 2 \ndigits \nlong \nwith a \nleading \nzero when necessary.\n\n\nThe parent method, publish_payload is called for each of the unit accumulators and finally the receive_loop, defined \nin the parent is called, to receive incoming tick messages.\n\n\nIncrementally Testing The Tick Processor Component Part 1\n\n\nSince the __init__ method publishes some messages,  we can run the tick_counter by \nitself and \nmonitor its \noutput to \nverify the messages being sent within __init__ are what we expect. \n\n\nFirst kill the tick generator component so that we can test the the tick counter as a standalone component.\n\n\nNext restart the monitor component. Notice that we did not have to restart the backplane. You can add and remove \ncomponents at will. \n\n\nLastly, start the tick counter.\n\n\n\n\n\n\n\n\n\n\nComparing the messages with the original design, we see that they match in format. The actual payload contents \nreflect the time when the test was performed..\n\n\n\n\nNow we can go on with the rest of the coding for the class.\n\n\nWriting The Tick Counter Component Part 2\n\n\nIn the __init__ method, the parent method, \nreceive_loop\n was called. It does not need to be changed for this \nexample and the parent method is executed as is with no overwrite. \n\n\nThe \nreceive_loop\n constantly checks for the arrival of new messages. When a message has arrived, \nreceive_loop\n calls\n the \nincoming_message_processing\n method. The parent version of this method is essentially a place holder\n  so we need to overwrite this method to process the message.\n\n\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, \n                                          'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, \n                                          'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\n\n\n\nWhen a tick message is received, this method increments the seconds accumulator and tests for a value of 60. If it is\n 60, the seconds need to be reset to 0, and the minutes incremented by 1. Then the code tests if the new minute \n cascades \n into a new hour and updates the hour accumulator appropriately.\n\n\nFor each of the accumulators, if an accumulator value changes, a message is published for that accumulator.\n\n\nIncrementally Testing The Tick Processor Component Part 2\n\n\nLeaving the monitor and tick counter running, start the tick generator in a new command window.\n\n\nBecause the monitor prints all messages, we see a \ntick message\n followed by an \nupdate_seconds message\n. When the \nseconds are currently at 59 and the next tick is received, the seconds are reset to zero immediately followed by\n an \nupdate_minutes\n message. If the hour had turned, a third \nmessage \nindicating this would have been published.\n\n\n\n\nTo test the turning of an hour, you can either wait, or when you start tick_generator.py you can modify the tick period\nto be a much shorter tick period by using the -d command line option.\n\n\nIntegrating a GUI With Python Banyan\n\n\nWhen creating a GUI for your application, Python offers many GUI libraries to choose from. When choosing a GUI, you \nwill need to integrate the GUI library's event loop with the Banyan event loop. Python \nBanyan \ncompatible\n applications have been successfully integrated with the \n\ntkinter, \n \n\nkivy, \n \n\n and \nremi\n \n\n\nThe \nremi\n library, in my opinion, has an advantage over every other Python GUI library. That is, it creates a Web \nbased GUI totally written in Python. You get all the advantages of having a Web based GUI, such as portability, \nwithout having to deal with HTML/CSS/JavaScript.\n\n\nWith \nremi\n you have the choice of implementing your GUI by writing code to access the \nremi\n APIs directly or \nhave\n \nremi\n generate the code for you. Remi includes a \n\nWhat You See Is What You Get\n (WYSIWYG)\neditor. There is a \npreliminary tutorial\n \n that demonstrates how easy the graphical editor is to use. The editor not \nonly allows you \nto visually layout your GUI,  but generates the code that will both launch an HTTP server and then display your Web page\n on \nyour default browser. If you want to access your GUI from a remote device, such as a phone or tablet - no problem, \n\nremi\n allows multiple connections to the Web server.\n\n\nAnother great advantage of using \nremi\n to generate the code, is that it not only saves coding time, but testing time\n as well.\n\n\nFor this demo project, we used the WYSIWYG editor to generate the GUI. \n\n\n\n\nA more complicated GUI was designed and \nimplemented \nusing the editor and is included with code in the Python Banyan Examples repository for the \n\nrobot example\n \n\n\n\n\nIntegrating remi Generated Code With Python Banyan\n\n\nTo turn the generated code into a Banyan component, we need to perform several coding steps.  A \"before\" and \n\"after\" snapshot of the code will be displayed for each step along the way, in addition to some explanatory text.\n\n\n1.Add imports, rename the class, and add Python Banyan specific variables to the generated GUI class.\n\n\nUnmodified Generated Code\n\n\nimport remi.gui as gui\nfrom remi.gui import *\nfrom remi import start, App\n\n\nclass untitled(App):\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(untitled, self).__init__(*args, static_file_path='./res/')\n\n\n\n\n\nModified Code\n\n\nimport sys\nimport socket\nimport signal\nimport zmq\nimport umsgpack\nimport remi.gui as gui\nfrom remi.gui import *\nfrom remi import start, App\n\n\nclass GuiClock(App):\n\n    # ZeroMQ backplane address\n    back_plane_ip_address = None\n\n    #ZeroMQ backplane ports\n    subscriber_port = '43125'\n    publisher_port = '43124'\n\n    # ip address where the remi server is running\n    gui_ip_address = None\n\n    # ZeroMQ connections\n    publisher = None\n    subscriber = None\n\n    # topics that this application wishes to subscribe to\n    subscriber_topics = ['update_seconds', 'update_minutes', 'update_hours']\n\n    # The ZeroMQ context\n    context = None\n\n\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(GuiClock, self).__init__(*args, static_file_path='./res/')\n\n\n\n\n\n\nFor this step we added some additional module imports, renamed the class and added some class level variables.\nIn addition, a list of subscription topics is created.\n\n\nThe __init__ method for this example did not need to be modified.\n\n\n2. Overwrite the \nremi\n idle() method to incorporate the Python Banyan event loop functionality.\n\n\nUnmodified Generated Code\n\n\n    def idle(self):\n        #idle function called every update cycle\n        pass\n\n\n\n\nModified Code\n\n\n    def idle(self):\n        # idle function called every update cycle\n        data = None\n\n        try:\n            data = self.subscriber.recv_multipart(zmq.NOBLOCK)\n            self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1]))\n        except zmq.error.Again:\n            pass\n        except KeyboardInterrupt:\n            self.clean_up()\n\n\n\n\nThe \nidle\n method gets called at a user settable rate (more about that later). Here, we added code from the \nBanyanBase class that looks very similar and acts as the Banyan receive_loop(). When a message is received, this \nmethod will call the incoming_message_processing method, the same as is done in BanyanBase.\n\n\n3. Modify the \nremi\n main() method to connect publisher and subscriber sockets to the Python Banyan backplane.\n\n\nUnmodified Generated Code\n\n\n    def main(self):\n        return untitled.construct_ui(self)\n\n\n\n\nModified Code\n\n\n    def main(self):\n        print('\\n************************************************************')\n        print('Clock GUI using Back Plane IP address: ' + self.back_plane_ip_address)\n        print('GUI IP Address = ' + self.gui_ip_address)\n        print('Subscriber Port = ' + self.subscriber_port)\n        print('Publisher  Port = ' + self.publisher_port)\n        print('************************************************************')\n\n        self.context = zmq.Context()\n        # noinspection PyUnresolvedReferences\n        self.subscriber = self.context.socket(zmq.SUB)\n        for topic in self.subscriber_topics:\n            self.subscriber.setsockopt(zmq.SUBSCRIBE, topic.encode())\n        #\n        connect_string = \"tcp://\" + GuiClock.back_plane_ip_address + \n                         ':' + self.subscriber_port\n        self.subscriber.connect(connect_string)\n        #\n        # noinspection PyUnresolvedReferences\n        GuiClock.publisher = self.context.socket(zmq.PUB)\n        connect_string = \"tcp://\" + GuiClock.back_plane_ip_address + \n                          ':' + self.publisher_port\n        self.publisher.connect(connect_string)\n        the_gui = GuiClock.construct_ui(self)\n        # alias to help access widgets directly\n        GuiClock.the_widgets = self.clock_top_panel.children\n        return the_gui\n\n\n\n\nThis code looks and acts very similarly to the BanyanBase __init__ method. It instantiates ZeroMQ, creates the \nconnections to the backplane, and calls the generated \nconstruct_ui()\n method. This method \ninstantiates\n all of the widgets.\n\n\nIn addition, all of the topics in the list of subscriber topics are registered.\n\n\nWe also added and initialized a variable called \nthe_widgets\n that is used as a handle to gain access to and \nmanipulate the generated widgets. \n\n\n4. Add a new method to \nremi\n class to process incoming messages that have been subscribed to.\n\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n        if topic == 'update_seconds':\n            self.the_widgets['label_seconds'].set_text(payload['seconds'])\n        elif topic == 'update_minutes':\n            self.the_widgets['label_minutes'].set_text(payload['minutes'])\n        elif topic == 'update_hours':\n            self.the_widgets['label_hours'].set_text(payload['hours'])\n\n\n\n\n\nThis is the method that dereferences and processes the incoming messages that the GUI subscribed to. Here we are \nupdating the label widgets for seconds, minutes and hours.\n\n\n5. Add a new method to publish Python Banyan compatible messages.\n\n\n    def publish_payload(self, payload, topic=''):\n        \"\"\"\n        This method will publish python_banyan payload with the specified topic.\n\n        :param payload: A dictionary of items\n        :param topic: A string value\n        :return:\n        \"\"\"\n        if not type(topic) is str:\n            raise TypeError('Publish topic must be python_banyan string', 'topic')\n\n        # create python_banyan message pack payload\n        message = umsgpack.packb(payload)\n\n        pub_envelope = topic.encode()\n        self.publisher.send_multipart([pub_envelope, message])\n\n\n\n\n\nThis method prepares and publishes a message to the Banyan backplane.\n\n\n6. Add a clean_up method to cleanly take down Python Banyan connections and to close ZeroMQ\n\n\n    def clean_up(self):\n        \"\"\"\n        Clean up before exiting - override if additional cleanup is necessary\n\n        :return:\n        \"\"\"\n        self.publisher.close()\n        self.subscriber.close()\n        self.context.term()\n\n\n\n\n\nThis method closes the ZeroMQ connections and terminates the ZeroMQ instance.\n\n\n7. Create A Modified Instantiation Function\n\n\nUnmodified Generated Code\n\n\n\n\n#Configuration\nconfiguration = {'config_enable_file_cache': True, 'config_start_browser': True, 'config_address': '0.0.0.0', \n                 'config_project_name': 'untitled', 'config_port': 8081, 'config_resourcepath': './res/', \n                 'config_multiple_instance': True}\n\nif __name__ == \"__main__\":\n    # start(MyApp,address='127.0.0.1', port=8081, multiple_instance=False,enable_file_cache=True, \n                           update_interval=0.1, start_browser=True)\n\n    start(untitled, address=configuration['config_address'], port=configuration['config_port'], \n                        multiple_instance=configuration['config_multiple_instance'], \n                        enable_file_cache=configuration['config_enable_file_cache'],\n                        start_browser=configuration['config_start_browser'])\n\n\n\n\nModified Code\n\n\ndef clock_gui():\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # use the google dns\n    s.connect(('8.8.8.8', 0))\n    GuiClock.gui_ip_address = s.getsockname()[0]\n\n    # test if user wants to specify the backplane address\n    if len(sys.argv) > 1:\n        GuiClock.back_plane_ip_address = sys.argv[1]\n    # argument, so just use the local host\n    else:\n        GuiClock.back_plane_ip_address = s.getsockname()[0]\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    start(GuiClock,  debug=False, address=GuiClock.gui_ip_address,\n          update_interval=.00001)\n\n\nif __name__ == \"__main__\":\n    clock_gui()\n\n\n\n\n\n\nThis method sets the IP address of the remi HTTP server to be the IP address of the invoking machine.\n\n\nIt checks to see if there was a command line argument provided to set the backplane IP address. If not, it uses\nthe address of the local machine.\n\n\nSignal handlers are attached to detect the user terminating the component.\n\n\nThe \nremi\n start() method is called passing the name of the GUI class, turning debugs off, the address to use for the\n HTTP server and finally the update_interval for the idle loop.\n\n\nTesting the Application\n\n\nNow that we have all of our components for this application written, we can start the GUI to perform end to end testing.\n\n\nTo start the application:\n\n\n\n\nStart the backplane.\n\n\nStart the GUI.\n\n\nStart the tick processor.\n\n\nStart the tick generator.\n\n\n\n\nComponent Startup Order\n\n\nDoes the order that we start our components matter? That depends upon the application and how we designed the \napplication. For our \nexample, it turns out it does. If the GUI is started last, most likely you will only see the seconds display, that is\n until there is a turn of an hour. To fix this behavior, the GUI could publish a message, and the tick processor can \n subscribe to this message. The message would request that the full current time be published. \n\n\nThe installed example code, as well as the code published on Github, was \nmodified to do just that.\n\n\nThe __init__ method in gui_clock.py was modified to publish a message requesting the current time. The message \ncontains the topic: 'update_me' \nand a payload \nof: \n{'first':\n 'a'}. \n\n\nBecause this is in the __init__ method, this message is only published once, when the class is instantiated.\n\n\nclass GuiClock(App):\n    back_plane_ip_address = None\n    gui_ip_address = None\n    publisher = None\n    subscriber = None\n    subscriber_port = '43125'\n    publisher_port = '43124'\n    subscriber_topics = ['update_seconds', 'update_minutes', 'update_hours']\n    context = None\n    default_button_color = '#1d81f1'\n\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(GuiClock, self).__init__(*args, static_file_path='./res/')\n\n            # request for time to be updated\n            self.publish_payload({'first': 'a'}, 'update_me')\n\n\n\n\n\nThe tick_counter, was modified to subscribe to the 'update_me' topic and when it receives an 'update_me' message, it \nreturns messages for all three time units.\nThe incoming_message_processing method for tick_counter.py is shown below.\n\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        elif topic == 'update_me':\n            # current_time = datetime.datetime.now().time()\n            self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n            self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n            self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n\n\n\n\nBack to testing. Because we have tested our messaging interface all along the way, we only need to concentrate on \nverifying that the GUI is displaying the time units correctly. Using remi to generate the GUI code also made testing \nsimpler since we bypassed hand coding widget creation, instantiation and testing the results.\n\n\nYour default web browser should open and the time should be displayed, being updated every second.\n\n\n\n\nComponent Launch Strategies\n\n\nFor a small application with only a few components, it is not difficult to open a separate command or shell window for\n each component. For larger applications, this quickly becomes unmanageable. Here are some strategies that simplify \n the launching of an application using a single command.\n\n\nWindows\n\n\nFor windows, create a .bat file to launch all of the components. Here is the contents of a file named clock.bat \nthat \nwill \nlaunch all of the clock demo components in separate command windows.\n\n\nstart backplane.exe\nstart tick_generator.exe\nstart tick_counter.exe\nstart clock_gui.exe\n\n\n\n\nMac\n\n\nFor the Mac, you can create a shell script that will launch the components and when Control C is pressed, will kill \nall of the components.\n\n\nThe launching file should contain a \".sh\" extension, and you should change the files permissions to be executable.\nHere is a sample shell script to launch the clock demo named clock_demo.sh:\n\n\n#!/bin/bash\n\necho 'Press Control C to kill all of the components.'\n\nxterm -e backplane &\nxterm -e clock_gui &\nxterm -e tick_counter &\nxterm -e tick_generator\n\nfunction finish {\n   killall backplane\n   killall clock_gui\n   killall tick_counter\n   killall tic_generator\n}\n\ntrap 'kill $(jobs -p)' SIGINT\n\n\n\n\n\nTo make this file executable after it is created, use:\n\n\nchmod ugo+x clock_demo.sh\n\n\n\n\n\nThen to run the script type:\n\n\n\n./clock_demo.sh\n\n\n\n\n\nLinux\n\n\nFor Linux, you may use the same shell script shown above for the Mac, or you can use a utility called \nLunch\n. To\n install lunch on Ubuntu or the Raspberry Pi, open a command window and type:\n\n\n sudo apt-get install python-lunch\n\n\n\n\n\nThe Lunch utility uses a configuration file, called .lunchrc to launch the components. If you installed the examples\n  onto your computer using pip or setup.py, you can automatically create the .lunchrc file for the clock demo by \n  opening a command window and typing:\n\n\n  lunch_config\n\n\n\n\n\n\n\nA .lunchrc file will installed in your home directory, which is where lunch expects to find the file.\n\n\nHere is the contents of that file:\n\n\nadd_command(command=\"backplane\", env={}, identifier=\"back_plane\")\nadd_command(command=\"tick_generator\", env={}, identifier=\"tick_generator\")\nadd_command(command=\"tick_counter\", env={}, identifier=\"tick_counter\")\nadd_command(command=\"clock_gui\", env={}, identifier=\"clock_gui\")\n\n\n\n\n\n\nEach line adds a command for lunch to execute. The \"command\" parameter is the name of the executable to launch, the \n\"env\" is unused for our purposes and left as {}, and the \"identifier\" parameter allows us to pick a name of our \nchoosing.\n\n\nNote that if you execute the lunch_config program again, it will overwrite any changes you may have made to the \n.lunchrc file, so you may wish to backup this file before running lunch_config.\n\n\nLunch installs a menu item with a cherry as its icon.\n\n\n\n\nOn Raspbian, after installing lunch, you will find it under the System Tools menu on the GUI.\n\n\n\n\nWhen you invoke lunch from the GUI, you will see window that looks something like this:\n\n\n\n\nIf lunch fails to be able to start a process, it will constantly retry, until it succeeds.\n\n\nThrough the lunch gui, you can start and stop individual components, and view their console output.\n\n\nWhen you exit the lunch GUI window, all launched components will exit.\n\n\nCHAPTER 2: \u00a0PHYSICAL COMPUTING - GPIO INTERFACING\n\n\nNow that we know the basics of programming with Python Banyan, let's move on to creating a Python Banyan\napplication \nto control the digital output pins for both a Raspberry Pi and an Arduino.\n\n\nIn this chapter, the application requirements will be stated, and a typical \"use case\" will be provided. Previously, we \nused a \nsequence \ndiagram to help capture the design. A \ndescriptive text approach will be used for this chapter as a contrast with the sequence diagram approach.\n\n\nThe examples will be executed on a Raspberry Pi.\n\n\nApplication Requirements\n\n\n\n\nThe application shall allow a user to toggle one or more digital output pins (simultaneously) on the target device \n(Arduino or \nRaspberry Pi)\n\n\nThe user shall be able to set the toggle rate when the application begins.\n\n\nOther than the component that controls the board specific GPIO interface, a common, non-hardware specific code set, \nshall be implemented to \ncontrol the Arduino and Raspberry Pi, simultaneously or singularly.\n\n\n\n\nUse Case\n\n\nA potential use case is to have the ability to \ntoggle\n a light source and a video camera, on and off simultaneously.\nThe camera and light source may be attached to a single or multiple Raspberry Pi modules or a Raspberry Pi and an \nArduino.\n\n\nSimulation Application\n\n\nFor the purposes of this demo application, the camera and light source are simulated by using discrete LEDs in their \nplace.\n\n\nComponent High Level Design\n\n\nWhen designing a component, a separation of concerns should always be the goal. In this example, all the components \nare designed with a specific purpose in mind. This not only makes testing easier, but promotes component reuse for \nfuture projects.\n\n\nInstead of using a sequence diagram to capture our design, we will be using a text based approach.\n\n\nOur design will consist of three components. The first is an \nevent generator\n that is a reuse of the tick generator\ncreated in chapter 1. The second component is a \n\"toggler\"\n component that will \ninterpret the events of the tick \ngenerator and translate \nthose events into \"toggle\" messages\n. Both of these components are hardware independent. The \nthird component\n \nwill translate the \n\"toggle\" messages into actions that \ndirectly control the GPIO pins of either the Raspberry Pi or Arduino\n. There \nwill \nbe two implementation versions for this component. One for the Raspberry PI, using \n\npigpio\n library, and for the Arduino, the\n\nPyMata\n library\n\n\nHere is the design for each component.\n\n\n\n\n\n\nAn event generator component that will trigger the toggling of the pin state.\n\n\n\n\nReuse the tick_generator created for chapter 1. \n\n\nSubscribes to: \n\n\nDoes not subscribe to any messages.\n\n\n\n\n\n\nMessages Published:\n\n\ntopic: 'tick'\n\n\npayload: {'tick': True}\n\n\n\n\n\n\n\n\n\n\n\n\nA \"toggler\" component. This will keep track of the last state change and send a message to toggle to the opposite \nstate.\n\n\n\n\nA new component.\n\n\nSubscribes to:\n\n\n'tick' topic\n\n\n\n\n\n\nMessages Published:\n\n\ntopic: 'digital_output'\n\n\npayload: {'command': 'set_state', 'state': 0 or 1}\n\n\n\n\n\n\n\n\n\n\n\n\nSeparate GPIO interface components for the Arduino and for the Raspberry Pi. These components translate the \ndigital_output topic messages into GPIO library commands.\n\n\n\n\nA new component.\n\n\nSubscribes to:\n\n\n'digital_output' topic - translates the messages into low-level, board specific GPIO control methods.\n\n\n\n\n\n\nMessages Published:\n\n\nNone.\n\n\n\n\n\n\n\n\n\n\n\n\nComponent Implementation\n\n\ntick_generator\n\n\nThis component is reused from chapter 1 and \nis described \nhere\n\n\ntoggler\n\n\nThis component is very similar in form to all the other components discussed in chapter 1. The class definition is\nshown below, and the comments in the code adequately describe its contents.\n\n\nThe standard Python Banyan component instantiation scheme as discussed \nhere\n is used as \nwell.\n\n\n# toggler.py\n\nimport sys\nimport signal\nimport argparse\nimport time\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass Toggler(BanyanBase):\n    \"\"\"\n    This class is a subscriber for \"tick\" messages. When a tick message is received, \n    it will togglea state variable and then  publish a digital_output message with\n    a payload reflecting the current state.\n\n    It is independent of any specific hardware platform.\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None, loop_time=.1):\n        \"\"\"\n\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        \"\"\"\n\n        # initialize the parent\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                         process_name=process_name, loop_time=loop_time)\n\n        # allow time for zmq connections to be established\n        time.sleep(.03)\n\n        # subscribe to topics\n        self.set_subscriber_topic('tick')\n\n        # last digital output state\n        self.tick_tock = 0\n\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method will toggle the tick_tock state with each incoming tick.\n        It will then publish the new state as a digital_output topic message\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n        if topic == 'tick':\n            self.tick_tock ^= 1\n            payload = {'command': 'set_state', 'state': self.tick_tock}\n            self.publish_payload(payload, 'digital_output', )\n\n\n\n\n\nTesting toggler.py\n\n\n\n\nStart the backplane.\n\n\nstart tick_generator.\n\n\nstart the monitor.\n\n\nstart the toggler.\n\n\n\n\nAs you can see below with each tick, the toggler changes the state in the published digital_output message, and meets\n our\n design.\n\n\n\n\nrpi_digital_out\n\n\nOnce again, the familiar Python Banyan class definition patterns emerge. Let's take a look at what is new.\n\n\nimport argparse\nimport signal\nimport sys\nimport time\n\nimport pigpio\n# noinspection PyUnresolvedReferences\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass RPiDigitalOut(BanyanBase):\n    \"\"\"\n    This class is the interface class for Raspberry Pi digital\n    output control using the pigpio library.\n\n    It is used to set  BCM pins as digital outputs and to set their states.\n    \"\"\"\n\n    def __init__(self, pins, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None):\n        \"\"\"\n        Initialize the BanyanBase parent object.\n        Subscribe to topics of interest.\n        Create an instance of pigpio\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        \"\"\"\n        # initialize the base class and wait for zmq connections to complete\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                         process_name=process_name)\n\n        time.sleep(.3)\n\n        # set the subscriber topic\n        self.set_subscriber_topic('digital_output')\n\n        # create a pigpio object\n        # make sure to start the pipgio daemon before starting this component\n        self.pi = pigpio.pi()\n\n        # save the requested list of pins that need to be controlled\n        self.pins = pins\n\n        # set all the pins in the list to output pins\n        for pin in pins:\n            self.pi.set_mode(pin, pigpio.OUTPUT)\n\n        # subscribe to digital_output messages\n        self.set_subscriber_topic('digital_output')\n\n        # start the receive loop\n        self.receive_loop()\n\n\n\n\n\nThe first thing to notice in the __init__ method, is the addition of the parameter 'pins'. This parameter is a \nlist of BCM pins that we wish \nto toggle. The list is specified with the required -p option when the component is invoked. The format of the \ncommand line option is -p \nfollowed by the space delimited list of pins we wish to affect. The reason that this is a required option is, that \nunlike the Arduino, the Raspberry Pi has no built in LED.\n\n\nAfter \ninstantiating the pigpio library, we use the list of pins to set each pin in the list as an output pin.\n\n\nWe then subscribe to the 'digital_output' messages published by the toggler component, and then call the receive loop\n to wait for incoming messages.\n\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        # set the state for all the pins in the pin list\n        if payload['command'] == 'set_state':\n            for pin in self.pins:\n                self.pi.write(pin, payload['state'])\n        else:\n            raise TypeError('Unknown command received')\n\n\n\n\n\nThe incoming_message_processing method sets the state of each pin in the pin list to the state specified in the \n payload of the message.\n\n\nNext is The pi_digital_out() invocation function that uses the standard Python Banyan pattern. The only major change\n  is the \naddition of the -p option. This is a required option and at least one pin must be provided. \n\n\ndef rpi_digital_out():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"LED Back End\",\n                        help=\"Set process name in banner\")\n\n    parser.add_argument('-p', nargs='+', required=True, type=int, dest='pins',\n                        help='Required - Enter a list of space delimited pin numbers')\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n\n    my_rpi_digital_out = RPiDigitalOut(args.pins, **kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_rpi_digital_out.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    rpi_digital_out()\n\n\n\n\n\n\nTesting rpi_digital_out\n\n\nConnect an LED or LEDs to the bcm pin(s) of your choice. With the backplane,tick_generator and toggler \ncomponents running, start \nrpi_digital_out by specifying the pins you wish to toggle You \nshould see the LED or LEDs blink at 1 second rate.\n\n\nTo simplify testing, you can use a Raspberry Pi hat, such as the Pibrella, or \n\nwire one up on your own.\n\n\nUsing the  Pibrella green LED (BCM pin 4) and yellow LED (BCM pin 17)  rpi_digital_out is \ninvoked using\n the -p \noption, with the following command line:\n\n\nrpi_digital_out -p 4 17\n\n\n\n\n\nSince we are using the pigpio library, we need to first start its daemon by executing the following command:\n\n\nsudo pigpiod\n\n\n\n\n\nNext, to simplify the application start up, the .lunchrc may be updated by adding the toggler and \nrpi_digital_out components.\n\n\nadd_command(command=\"backplane\", env={}, identifier=\"back_plane\")\nadd_command(command=\"tick_generator\", env={}, identifier=\"tick_generator\")\nadd_command(command=\"tick_counter\", env={}, identifier=\"tick_counter\")\nadd_command(command=\"clock_gui\", env={}, identifier=\"clock_gui\")\nadd_command(command=\"toggler\", env={}, identifier=\"toggler\")\nadd_command(command=\"rpi_digital_out -p 4 17\", env={}, identifier=\"rpi_digial_out\")\n\n\n\n\n\nAdding An Arduino Component Into The Mix\n\n\nContinuing on with the GPIO control theme, we are going to add a component that will blink the board LED connected to\n pin 13 on an \nArduino. We will be using the PyMata control library to control pin 13 on the Arduino. This library was chosen over \nthe newer pymata-aio library, because pymata-aio requires the use of Python 3.5 or greater. Using PyMata will allow \nus to continue using Python 3.4.2 that is installed with the Raspberry Pi Raspbian distribution of 2017-01-11.\n\n\nTo install PyMata, open up a command window on the Raspberry Pi and type:\n\n\nsudo pip3 install PyMata\n\n\n\n\n\nPyMata implements the Firmata protocol. You will need to install the StandardFirmata Arduino sketch that is included \nwith the Arduino IDE, or the \nFirmataPlus sketch that comes with as part of the PyMata package. For further information on PyMata, please check out\n the \nPyMata Github page\n and the \n\nPyMata Wiki page.\n\n\nHere is the source code for \narduino_digital_out\n\n\n# arduino_digital_out.py\n\nimport time\nimport sys\nimport signal\nimport argparse\nimport zmq\nimport umsgpack\n\nfrom PyMata.pymata import PyMata\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass ArduinoDigitalOut(BanyanBase):\n    \"\"\"\n    This class is the interface class for Arduino output using the\n    PyMata library.\n\n    It is used to set a BCM pin as a digital output and to set its state.\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None, pins=[13],\n                 com_port='/dev/tty_ACM0'):\n\n        super(ArduinoDigitalOut, self).__init__(back_plane_ip_address, subscriber_port, \n                                                publisher_port, process_name=process_name)\n\n        time.sleep(.3)\n\n        # initialize pin direction\n\n        self.pins = pins\n        self.com_port = com_port\n\n        self.board = PyMata(com_port, verbose=True)\n\n        for pin in pins:\n            self.board.set_pin_mode(pin, self.board.OUTPUT, self.board.DIGITAL)\n\n        self.set_subscriber_topic('digital_output')\n\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        # set the state of the pin specified in the message.\n        if payload['command'] == 'set_state':\n            for pin in self.pins:\n                self.board.digital_write(pin, payload['state'])\n        else:\n            raise TypeError('Unknown command received')\n\n\ndef arduino_digital_out():\n    # noinspection PyShadowingNames\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-c\", dest=\"com_port\", default=\"/dev/ttyACM0\",\n                        help=\"Enter Arduino Com Port\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Arduino Digital Output\",\n                        help=\"Set process name in banner\")\n\n    parser.add_argument('-p', nargs='+', type=int, default=[13], dest='pins',\n                        help='Required - Enter a list of space delimited pin numbers')\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n\n    kw_options['com_port'] = args.com_port\n\n    ard_dig_out = ArduinoDigitalOut(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        ard_dig_out.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    arduino_digital_out()\n\n\n\n\n\n\nThe __init__ method contains a pins parameter similar to that of the rpi_digital_out component. This parameter \nhas a default value of pin 13 for the Arduino board LED. Additional pins can be enabled by using the -p option when \ninvoking arduino_digital_out. For arduino_digital_out the -p is not required as it is for the Raspberry Pi.\n\n\nAn instance of PyMata is created and the PyMata API is used to set the specified pins for digital output.\n\n\nThere is also a com_port parameter. The Arduino communicates over a serial interface, and the default is \n/dev/tty/ACMO, which is the default when we plug the Arduino USB connector into the Raspberry Pi. This value may be \noverwritten using the -c command line option.\n\n\nThe incoming_message_processing method set the state of the output pin using the PyMata API as well.\n\n\nWhen the arduino_digital_out component is invoked from a terminal window, here is its output:\n\n\n\n\n\nPyMata announces the com port it is using, the number of pins it found on the Arduino device. The component will then\n proceed to blink the Arduino LED.\n\n\nAnd Now, For Something Totally Different - Adding A JavaScript Banyan Compatible Module To The Application\n\n\nWe are about to add an additional component to our already running system. This module, however is written in \nJavaScript. It so happens that you may write a component in any language that supports both ZeroMQ and MessagePack, \nand there is a very  \nlong list of languages that do.\n \nlong list of languages that do.\nBut why would you want to do something like this? Here are some reasons:\n\n\n\n\nYou need support for a hardware device. The only support you can find is written in another language and \nporting would be difficult,\n if not \nimpossible.\n\n\nYou would like to perform a remote procedure call with a component written in something other than Python to perform \nsome task, perhaps some complicated data analysis.\n\n\n\n\nThe flexibility of Python Banyan allows you to craft components to meet your application's needs, including doing so \nin a language other than Python.\n\n\nThe following is a simple JavaScript component. When executed using node.js, it attaches itself to the backplane \nand when it receives an update_seconds messages, it prints the topic and payload to the console.\n\n\n// node_backplane_monitor.js\n\n// This is a simple JavaScript monitor compatible with Python Banyan.\n// It subscribes to all messages with the topic of \"update_seconds\"\n\n\nvar zmq = require('zmq'),\n    sock = zmq.socket('sub');\n\nvar msgpack = require(\"msgpack-lite\");\nvar data;\n\n// remember to set ip address to the same ip address that the backplane uses.\nsock.connect('tcp://192.168.2.185:43125');\n\n//sock.subscribe('update_seconds');\nsock.subscribe('update_seconds');\n\nconsole.log('Subscriber connected to port 43125');\n\nsock.on('message', function(topic, message) {\n  data = msgpack.decode(message);\n  console.log('received a message related to:', \n              topic.toString('utf-8'), 'containing message:', data);\n\n});\n\n\n\n\nThe code connects to the backplane located at 192.168.2.185:43125, which just happens to be the IP address and port for \nthe backplane that is running on my Raspberry Pi. If you would like to try this on your network, you will most likely\n need to change the IP address, but the port number may stay the same.\n\n\nThe component then subscribes to receive \"update_seconds\" \nmessages and prints the\n messages to the console. Here is some output when the component was run on an Ubuntu 16.10 computer. Since the IP \n address is hardcoded for this example, it automatically connects to the backplane and prints the messages it \n subscribed to.\n\n\n$ node node_backplane_monitor.js\nSubscriber connected to port 43125\nreceived a message related to: update_seconds containing message: { seconds: '27' }\nreceived a message related to: update_seconds containing message: { seconds: '28' }\nreceived a message related to: update_seconds containing message: { seconds: '29' }\nreceived a message related to: update_seconds containing message: { seconds: '30' }\n\n\n\n\n\nThe version of node.js that is supplied with Raspbian is old and will not work with ZeroMQ. It needs to be updated, but \ndoing\n so removes node red. So unless you are willing to put in the effort to update node.js, and willing to lose node red,\n it is probably easier to run this example on some other computer.\n\n\nDistributing Python Banyan Components Across Multiple Computers\n\n\nWe have already seen an example of running a Python Banyan component on a computer that is not running the backplane \nin the \nprevious section.\n \n\n\nTo keep things simple, the JavaScript example did not implement command line option processing, so if we want to \nconnect the component to something other than the hard-coded IP address, the code would need to be modified.\n\n\nIf you recall, for all the other examples, as a standard Python Banyan pattern, the Python argparse library was used\n to help retrieve any command line options the user wishes to use. \nThe \"-b\" option allows a user to specify the IP address for the backplane.\n\n\nHere is a component distribution map. All of the computers have had Python Banyan and the example distribution \ninstalled. The examples distribution installs all of the components as executables and we will take advantage of that.\nSee \nChapter 4\n for instructions on how to turn your \nmodules into executables.\n\n\n\n\n\n\n\n\nComponent\n\n\nComputer\n\n\nIP Address\n\n\n\n\n\n\n\n\n\n\nbackplane\n\n\nRaspberry Pi\n\n\n192.168.2.185\n\n\n\n\n\n\nmonitor\n\n\nWindows 10 (virtual box)\n\n\n192.168.2 180\n\n\n\n\n\n\ntick_generator\n\n\nUbuntu 16.10\n\n\n192.168.2.190\n\n\n\n\n\n\ntick_counter\n\n\nOBRevenge Linux (virtual box)\n\n\n192.168.2.181\n\n\n\n\n\n\ntoggler\n\n\nRaspberry Pi\n\n\n192.168.2.185\n\n\n\n\n\n\nrpi_digital_out\n\n\nRaspberry Pi\n\n\n192.168.2.185\n\n\n\n\n\n\narduino_digital_out\n\n\nUbuntu 16.10\n\n\n192.168.2.190\n\n\n\n\n\n\nclock_gui\n\n\nWindows 10 (virtual box)\n\n\n192.168.2 180\n\n\n\n\n\n\n\n\nThere are no code changes necessary to start any of the modules on any of the computers. The only thing you need to \nkeep track of is the IP address of the computer where the backplane was invoked, and then use the -b option when \ninvoking the component. For the components to be run on the \nRaspberry Pi, no command line option is needed, since they will automatically attach to the backplane. Just remember \nto start the backplane before starting any other component.\n\n\nHere are the Raspberry Pi components being started:\n\n\n\n\n\nNow let's start the tick_counter on the OBRevenge machine using the -b option:\n\n\ntick_counter -b 192.168.2.185\n\n\n\n\n\n\n\n\n\nOn to the Ubuntu computer where will start the tick_generator and the arduino_digital_out components:\n\n\n\n\n\n\nAnd finally we start the clock_gui and monitor components on the Windows 10 machine. The clock_gui does not use \nargparse and so its command line argument to set backplane address simply follows the command:\n\n\nclock_gui 192.168.2.185\n\n\n\n\n\n\n\n\n\nAnd there you have it. All the components have been distributed and are running without a single line of code needing\n to be changed.\n\n\nCHAPTER 3: \u00a0ADDING AN I2C BASED BCD TIME DISPLAY\n\n\n\n\n\n\nBefore moving on to the next topic, let's review what we have \naccomplished so far.\nWe've created an application consisting of 2 independent \nfeatures\n that execute concurrently within a single \napplication. Each feature is \nconstructed as a set of Python Banyan \ncomponents\n, and some of these components are being shared and simultaneously \nused by both \nfeatures. \n\n\nHere is a table summarizing these features and the components used to implement each one:\n\n\n\n\n\n\n\n\nFeature\n\n\nComponent\n\n\n\n\n\n\n\n\n\n\nWeb Clock\n\n\nclock_generator\n\n\n\n\n\n\n\n\ntick_counter\n\n\n\n\n\n\n\n\nclock_gui\n\n\n\n\n\n\nPin Toggler\n\n\nclock_generator\n\n\n\n\n\n\n\n\ntick_counter\n\n\n\n\n\n\n\n\ntoggler\n\n\n\n\n\n\n\n\nrpi_digital_out\n\n\n\n\n\n\n\n\narduino_digital_out\n\n\n\n\n\n\n\n\nNow, let's continue on with our \"clock\" theme by attaching an \nAdafruit Bicolor LED Square Pixel Matrix\n\nto the i2c pins of the Raspberry Pi, and using the display as a \nBCD clock display\n.\n\n\n\n\n\nThe time being displayed in the photo at the top of this chapter is 14:12:24. The green LEDs represent a \"1\" and red \nLEDs \nrepresent a \"0\".\n\n\nThe High Level Component Design\n\n\nComponent 1:  \n\u00a0\u00a0binary_clock.py\n.\n\n\nThe highest level component for the BCD clock is called binary_clock.py and it is an abstraction of the BCD \ndisplay configured as a BCD display.\n\n\nThis component subscribes to update_hours, update_minutes and update_seconds messages, and then translates those \nmessages into commands for the underlying i2c device, (HTK1633), to control the individual pixels to display the \ntime in BCD format. It publishes messages containing a topic of \"8x8_matrix\" for each pixel to be modified for the \nupdated unit. The payload for these messages is:\n\n\n\n {'command': 'set_pixel', 'x': row, 'y': column, 'value': RED | GREEN}\n\n\n\n\nWhen all of the pixels for the time unit have been published, it then publishes a message to display the updated pixels:\n\n\n\n{'command': 'output_display_buffer'}\n\n\n\n\nThe code adheres to  the standard Python Banyan patterns already covered in previous sections, and the code itself is\n well commented, so it needs no further discussion.\n\n\nComponent 2:\u00a0\u00a0 \ni2c_htk1633.py\n\n\nThis component provide an abstraction for the HTK1633 16x8 LED i2c Controller Driver. For reference, the data sheet for the HTK1633 may be found \nhere\n.\n\n\nThis component utilizes the standard Python Banyan design patterns, but introduces the use of the i2c device \ndescriptor. This section will describe that descriptor and it usage.\n\n\n\n        # i2c commands for the htk1633\n        # the values will be filled in by the methods for each command\n        self.i2c_device = {\n            \"htk1633\": {\n                \"commands\": {\n                    \"init\": [\n                        {\n                            u\"command\": u\"init\",\n                            u\"device_address\": self.device_address\n                        }\n                    ],\n                    \"set_oscillator_state\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.OSCILLATOR_OFF\n                        }\n                    ],\n\n                    \"set_blink_rate\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.HT16K33_BLINK_CMD\n                        }\n                    ],\n                    \"set_brightness\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.HT16K33_BRIGHTNESS_CMD\n\n                        }\n                    ],\n                    \"write_pixel\": [\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": 0\n                        }\n                    ]\n                }\n            }\n        }\n\n\n\n\n\n\n\nAn i2c device descriptor, as shown for the HTK1633 above, describes the operations that may be performed on \nbehalf of the i2c device. Each operation is considered to be a macro command. A macro command contains one or more i2c \ncommunication messages that will implement the macro command.\n\n\nA communication message is essentially an i2c read or write instruction with its optional parameters.\n\n\nTo understand how this works, let's look at the device initialization method:\n\n\n\n    def initialize_i2c_device(self):\n            \"\"\"\n            This method establishes the i2c address of the device on the MCU.\n            :return:\n            \"\"\"\n            msg = self.i2c_device['htk1633']['commands']['init']\n            self.publish_payload(msg, self.publisher_topic)\n\n\n\n\nA command execution method, such as initialize_i2c_device, dereferences the i2c device descriptor to retrieve \nthe message or messages\nthat will ultimately execute the command.\n\n\nFor the initialize command, the following payload is published with a topic of 'i2c_8x8_matrix':\n\n\n{\n    u\"command\": u\"init\",\n    u\"device_address\": self.device_address\n}\n\n\n\n\n\nIn addition to the HTK1633 device, there are components provided that support the \n\nPCF8591 Analog To Digital Converter\n and the\n and \n \nADXL345 Accelerometer\n.\n\n\nEach i2c device implements a unique Python Banyan component to support the device.\n\n\nThe ADXL345 component has an i2c device descriptor with an example of multiple i2c communication messages for its \ninit macro command. Here is the entire descriptor containing an init and a read macro command:\n\n\n# this is python_banyan descriptor for the i2c commands to be sent to the i2c target device\n        self.i2c_device = {\n            \"adxl345\": {\n                \"commands\": {\n                    \"init\": [\n                        {\n                            u\"command\": u\"init\",\n                            u\"device_address\": device_address\n                        },\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 45,\n                            u\"value\": 0\n                        }, {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 45,\n                            u\"value\": 8\n                        }, {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 49,\n                            u\"value\": 8\n                        },\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 49,\n                            u\"value\": 3\n                        }\n                    ],\n                    \"read\": [{\n                        u\"command\": \"read_block\",\n                        u\"device_address\": device_address,\n                        u\"num_bytes\": 6,\n                        u\"register\": 50,\n                        u\"report\": True,\n                        u\"tag\": 0\n                    }]\n                }\n            }\n        }\n\n\n\n\n\n\nComponent 3:  \n\u00a0\u00a0i2c_pigpio.py\n\n\nThis component adheres to the Python Banyan patterns covered in the past. \n\n\nThere is a single instance of i2c_pigpio that receives all 'i2c' message from the device specific i2c components. This \ncomponent \ncommunicates directly with the i2c device via the SDA/SCL pins to perform i2c reads and writes.\nA read command can optionally return a value. The reason that this is optional is that sometimes a read is used to \nincrement an internal pointer within the device and not to retrieve a data value.\n\n\nRunning The BCD Clock Display\n\n\nTo run the BCD clock, make sure the clock components of chapter 1 are already running, and then run i2c_pigpio.py, \ni2c_htk1633.py and \nbinary_clock.py\n\n\nCHAPTER 4: \u00a0INSTALLING YOUR COMPONENTS AS EXECUTABLE MODULES\n\n\nIf you would like to install your Python Banyan components as executable modules that are found on the execution pah, \nyou may \nuse a feature of the \nstandard setup.py module\n. Full documentation for setup.py may be found\n \nhere.\n \n\n\nYou would first need to add you package to the packages list in setup.py. \nNext you need to make an entry into entry_points/console scripts section.\n\n\nThe format for this section is:\n\n\n\"name_of_executable = module.with:function_to_execute\"\n\n\nfrom setuptools import setup\n\nsetup(\n    name='python-banyan-examples',\n    version='1.0',\n    packages=[\n        'python_banyan.examples.clock',\n        'python_banyan.examples.digital_toggling',\n        'python_banyan.examples.launching',\n        'python_banyan.examples.matrix',\n        'python_banyan.examples.raspberry_redbot.i2c',\n        'python_banyan.examples.raspberry_redbot.i2c.validators',\n        'python_banyan.examples.raspberry_redbot.i2c.accelerometers',\n        'python_banyan.examples.raspberry_redbot.i2c.a2d',\n        'python_banyan.examples.raspberry_redbot.encoders.validators',\n        'python_banyan.examples.raspberry_redbot.led',\n        'python_banyan.examples.raspberry_redbot.led.validators',\n        'python_banyan.examples.raspberry_redbot.buzzer.validators',\n        'python_banyan.examples.raspberry_redbot.led.validators',\n        'python_banyan.examples.raspberry_redbot.buzzer',\n        'python_banyan.examples.raspberry_redbot.buzzer.validators',\n        'python_banyan.examples.raspberry_redbot.motors',\n        'python_banyan.examples.raspberry_redbot.motors.validators',\n        'python_banyan.examples.raspberry_redbot.encoders',\n        'python_banyan.examples.raspberry_redbot.switches',\n        'python_banyan.examples.raspberry_redbot.gui',\n        'python_banyan.examples.raspberry_redbot.i2c.led_matrix',\n    ],\n    install_requires=[\n        'python_banyan',\n        'pyzmq',\n        'u-msgpack-python',\n        'PyMata'\n    ],\n\n    package_data={'python_banyan.examples.launching': ['*.txt']},\n\n    entry_points={\n        'console_scripts': [\n            'clock_gui = python_banyan.examples.clock.clock_gui:clock_gui',\n            'tick_counter = python_banyan.examples.clock.tick_counter:tick_counter',\n            'tick_generator = python_banyan.examples.clock.tick_generator:tick_generator',\n            'binary_clock = python_banyan.examples.clock.binary_clock:binary_clock',\n\n            'rpi_digital_out=python_banyan.examples.digital_toggling.rpi_digital_out:rpi_digital_out',\n            'toggler=python_banyan.examples.digital_toggling.toggler:toggler',\n            'arduino_digital_out=python_banyan.examples.digital_toggling.arduino_digital_out:arduino_digital_out',\n\n            'lunch_config=python_banyan.examples.launching.lunch_config:lunch_config',\n\n            'i2c_htk1633 = python_banyan.examples.matrix.i2c_htk1633:i2c_htk1633',\n            'i2c_pigpio = python_banyan.examples.raspberry_redbot.i2c.i2c_pigpio:i2c_pigpio',\n\n            'buzzer_pigpio = python_banyan.examples.raspberry_redbot.buzzer.buzzer_pigpio:buzzer_pigpio',\n            'encoders_pigpio = python_banyan.examples.raspberry_redbot.encoders.encoders_pigpio:encoders_pigpio',\n            'i2c_pcf8591 = python_banyan.examples.raspberry_redbot.i2c.a2d.i2c_pcf8591:i2c_pcf8591',\n            'i2c_adxl345 = python_banyan.examples.raspberry_redbot.i2c.accelerometers.i2c_adxl345:i2c_adxl345',\n            'led = python_banyan.examples.raspberry_redbot.led.led:led',\n            'led_pigpio = python_banyan.examples.raspberry_redbot.led.led_pigpio:led_pigpio',\n            'motors = python_banyan.examples.raspberry_redbot.motors.motors:motors',\n            'motors_pigpio = python_banyan.examples.raspberry_redbot.motors.motors_pigpio:motors_pigpio',\n            'switches_gpio = python_banyan.examples.raspberry_redbot.switches.switches_pigpio:switches_pigpio',\n            'redbot = python_banyan.examples.raspberry_redbot.gui.redbot_controller:redbot_gui',\n\n\n        ]\n    },\n)\n\n\n\n\n\nWhen you run pip or setup.py, your module will be placed on the executable path independent of operating system.\n\n\nSOFTWARE REQUIRED BY PYTHON BANYAN\n\n\nThe examples presented here were tested using Python 3.4.2 on a Raspberry Pi, Python 3.5.2 on Ubuntu Linux, and \nPython 3.6 on Windows. There are no known Python 3 dependencies in the Framework.\n\n\nPython Banyan runs on Windows, Linux, and Mac, however you may need to install some additional software \nto your computer to meet the needs of Python Banyan. Here is a list of items that must available for Python Banyan to\n run:\n\n\n\n\n\n\nPython 3\n\n  The examples in this manual have been tested using Python 3.4.2, Python 3.5 and Python 3.6. \u00a0Python Banyan \nis not  inherently Python 3 specific so you are free to try it with Python 2 if you wish.\n\n\n\n\n\n\nZeroMQ\n\n  ZeroMQ is a networking library that is at the heart of Python Banyan. It acts as a non-blocking asynchronous \ntransport for Python Banyan applications. It also allows a Python Banyan application to distribute its components \nacross \nmultiple computers. The examples in this manual will demonstrate how to run an application on a single computer, and \nhow to take that same application and run its components on multiple computers.\n\n  In addition, ZeroMQ allows components written in languages other than Python to interact and become part your \napplication. An example of integrating a JavaScript component will be discussed.\n\n  Also, ZeroMQ helps form a Python Banyan \"backplane\". You may plug in or remove components of your application while \nthe other components are already running. This too will be demonstrated.\n\n\n\n\n\n\nThe Python Banyan Distribution\n\n  This includes Python Banyan's base class, used to create Python Banyan compatible applications, the Python Banyan \nbackplane, an executable Python module, and a utility module called the \"monitor\", that will allow you to view \ntraffic on the backplane.\n\n\n\n\n\n\nOptional Packages\n\n\n\n\n\n\nThe Lunch Launcher\n\nThe Lunch launcher is not required, but provides a managed way to launch a Python Banyan application. Lunch is only \navailable for Linux systems. For Windows, a \nbatch script (.bat) can be created. For Mac a shell script can be created (.sh).\n\n\n\n\n\n\nThe \nremi GUI Library\n\nThis package is not required, but is used in conjunction with the \nClock\n demo described in this guide.",
            "title": "User's Guide"
        },
        {
            "location": "/#what-is-python-banyan",
            "text": "Python Banyan is a lightweight, reactive framework used to create flexible, non-blocking, event \ndriven, \nasynchronous applications. It was designed primarily to implement physical computing applications for devices such as\n the Raspberry Pi and Arduino, \nbut it is \nnot limited to just that domain, and may be used to create application in any domain.  Most traditional physical computing libraries or frameworks use an  object oriented  model that results in a single, \ntightly coupled, monolithic executable image. Python Banyan uses an extension of the object oriented model, called \nthe  component based  model. A component based application is comprised of a set of independent, loosely \ncoupled \nmodules. Functionality is easily added to a Python Banyan application, and in fact it may be added to a fully running\n system without the need to recompile or reboot.  Because each module is a self contained entity, applications can be created with a set of modules that use \n different \n versions of Python, and in fact,  you can even add modules written in other computer languages.  In addition, the modules may be run on a single computer, or may be distributed across multiple computers running \n different operating systems, without having to change a single line of code.",
            "title": "WHAT IS PYTHON BANYAN?"
        },
        {
            "location": "/#a-little-more-detail",
            "text": "The Python Banyan Framework consists of a single, simple base class. All Banyan compatible components inherit from \nthis class. When a Banyan component is first invoked, it automatically connects to a common shared software backplane. \nAll \nof the complexity of managing connections is hidden within and handled by the base class. All Banyan modules\nexchange information with each another by sending or publishing user defined protocol messages via the backplane. All\n routing and message buffering is automatically handled by the Framework. Each \nBanyan \ncomponent can\n \"publish\" messages, \"subscribe\" to receive specific messages or both publish and subscribe messages. A Banyan \n component is not limited as to how many types of messages it may subscribe to.  Because Banyan messages are not computer language specific, components written in other computer Languages, such as \n JavaScript, can be used within a Python Banyan application. A simple JavaScript demo is provided in the \n examples section below.  Python Banyan takes full advantage of the  ZeroMQ  \n  networking library that not only provides \n connectivity, but in addition acts as a concurrency framework. All of this is handled transparently by the Python \n Banyan base class. If your application requires additional concurrency support, you are free to choose whatever \n works best for your application, such as a multi-threading or a Python asyncio approach. User defined messages are \n prepared for transport across the network by wrapping them in the \n  Message Pack format.    The complexities of \n MessagePack are handled transparently by the base class, both for transmitting and receiving messages.",
            "title": "A Little More Detail"
        },
        {
            "location": "/#whats-in-this-guide",
            "text": "This is a hands-on guide. Several examples will be presented to get you acquainted with Python Banyan and its \ntechniques for use. Source code for all examples are available on Github. Links to the source code will be provided \nas each component is discussed.  Chapter 1  is an introduction to developing with Python Banyan. An application tailored specifically for this \npurpose \nwill be presented in detail.  In chapter 2 , a demonstration of, and a discussion about creating physical computing components with Python Banyan.  To demonstrate Python Banyan's flexibility, applications will be built from Python 2 components, Python 3 \ncomponents and even a JavaScript component, all cooperating and communicating with each other within a single \nPython Banyan application.  Python Banyan applications may be distributed across multiple computers, all without changing a single line of code.\nUsing the components created in this guide, all of the components will first be launched to run on a Raspberry Pi, and \nthen\n then the components will be re-distributed across a Linux Ubuntu PC, a Windows PC and the Raspberry Pi without \n having to change a single line of code.  In  Chapter 3 , we will add components to control an 8x8 bicolor LED matrix connected to a Raspberry Pi. A \ndemonstration of using Python Banyan to control an i2c device will be presented.  If you need to control multiple i2c devices sharing the same i2c pins, Python Banyan provides the concurrency support\n for you to do so.  Chapter 4  will discuss how to use Python's setup tools to convert a \nBanyan component into an executable file and have it automatically installed on the execution path.",
            "title": "What's In This Guide"
        },
        {
            "location": "/#before-we-begin",
            "text": "To learn how to install Python Banyan, and all of the examples presented in this guide, please see  the Required Additional Software section in this guide .  After following the installation instructions all of the example components are installed as \nexecutable modules.",
            "title": "Before We Begin"
        },
        {
            "location": "/#chapter-1-a-simple-24-hour-clock",
            "text": "In this example, we will:   Learn about the Python Banyan Backplane.   Take a brief look at the Banyan base class,  banyan_base.py  Create the three components that make up this application  Learn how to use the  Python Banyan Monitor  utility to test each component.  Create a Web based Python Banyan compatible GUI using the \n   remi  \n  library.  Launching the components to form the application.",
            "title": "CHAPTER 1: &nbsp;A SIMPLE 24 HOUR CLOCK"
        },
        {
            "location": "/#the-python-banyan-backplane",
            "text": "The backplane is installed as an executable module when Python Banyan is installed. The backplane  must be running  \n  before the first Python Banyan application component is invoked.  To start the backplane, just open a command window and type:    backplane  You should see a welcome banner in the console.   The banner identifies the name of the program, \"Banyan Backplane\", the IP address of the computer on which the \n backplane is running, and the two IP port numbers to be used by all Python Banyan components. For \n applications\n  where all of the Python Banyan components are running on a single computer, this is purely informational. We will use\n  these values in a later example when we distribute the Banyan components across multiple computers.  The backplane is an implementation of a\n    ZeroMQ forwarder device .  A forwarder device collects messages from a set of publishers and forwards these messages to a set of subscribers. \n  This allows\n  all Python Banyan components to use a single IP address in conjunction with a set of well known port numbers to \n  send and receive messages.  This simplifies system configuration and no configuration files need to be maintained.   The backplane is invoked using a common coding pattern. Although not required, it is good practice to be used by \n  all Python Banyan components. This \n  pattern is used to create and install Banyan modules as an executable on the executable path. We will learn more \n  about this in  Chapter 4 .  For the backplane, the bp() function near the end of the file, \n  instantiates the BackPlane class. It calls the  run_back_plane  method to start the backplane, and additionally \n  attaches a \n  Control-C signal handler so \n  that the user can cleanly quit the program.  def bp():\n\n    \"\"\"\n    Instantiate the backplane and run it.\n    Attach a signal handler for the process to listen for user pressing Control C\n    :return:\n    \"\"\"\n\n    backplane = BackPlane()\n    backplane.run_back_plane()\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        backplane.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\nif __name__ == '__main__':\n    bp()",
            "title": "The Python Banyan Backplane"
        },
        {
            "location": "/#a-brief-look-at-the-the-banyan-base-class",
            "text": "Every Python Banyan component must inherit from this class. Using a derived class called MyComponent as an example, \nhere is a pattern as to how the MyComponent class would begin.  import argparse\nimport signal\nimport sys\nimport time\nimport zmq\nimport umsgpack\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass MyComponent(BanyanBase):\n    \"\"\"\n    All the MyComponent class methods and overwritten BanyanBase methods would follow \n    below this point ...\n    \"\"\"  The banyan_base class contains 6 methods:  1.\u00a0\u00a0__init__  \n__init__(self, back_plane_ip_address=None, subscriber_port='43125', publisher_port='43124', \n               process_name='None', loop_time=0.1)\n\n           The __init__ method sets up all the ZeroMQ \"plumbing\"\n\n           :param back_plane_ip_address: banyan_base back_planeIP Address -\n                                         if not specified, it will be set to the\n                                         local computer\n           :param subscriber_port: banyan_base back plane subscriber port.\n                  This must match that of the banyan_base backplane\n           :param publisher_port: banyan_base back plane publisher port.\n                                  This must match that of the banyan_base backplane\n           :param process_name: Component identifier\n           :param loop_time: loop sleep time when no message is available\n           :return: No Return Value  This method establishes the connections to the Python Banyan Backplane. A derived class must initialize the parent class\nby using the super() method.  super().__init__(back_plane_ip_address, subscriber_port, publisher_port, \n                         process_name=process_name, loop_time=loop_time)  Any component specific initialization code is added as necessary.  2.\u00a0\u00a0set_subscriber_topic  \nset_subscriber_topic(self, topic)\n      This method registers a component to receive messages\n       containing the specified topic.\n\n       You can subscribe to multiple topics by calling this method for\n       each topic.\n\n       :param topic: A topic string\n       :return: No Return Value  All Python Banyan messages are published with an associated topic string. In order to receive messages published for a \ngiven topic, a component must register for those messages by calling  set_subscriber_topic . This method is called \nfor each topic that the component wishes to receive.  This method encapsulates and hides the details of the ZeroMQ subscription process.  This method is typically not overwritten.  3.\u00a0\u00a0publish_payload  \n  publish_payload(self, payload, topic='')\n           This method will publish a python_banyan payload and its associated topic\n\n           :param payload: Message data, typically in the form of a Python dicationary.\n           :param topic: A string value\n           :return: No Return value  Messages are published as  multi-part  messages consisting of a topic in the form of a string, and the payload, which\nis normally represented as a Python dictionary.  This method publishes a message by wrapping the payload in the MessagePack transport format and presenting both the \nthe payload and topic to the low level ZeroMQ publish method.  This method encapsulates and hides the details of the ZeroMQ publishing process.  This method is typically  not  overwritten.  4.\u00a0\u00a0receive_loop  \n  receive_loop(self)\n           This is loops wait to receive any incoming messages.\n\n           This method may be overwritten to meet the needs\n           of the application before handling received messages.\n\n           :return: This method never returns.  Subscribed messages are received in this  non-blocking event loop .   The receive_loop continually checks to see if ZeroMQ has delivered a message. If no message is \navailable, ZeroMQ throws a  zmq.error.Again  \nexception. When this exception occurs, the exception handler sets a short sleep interval, and then checks again.\nIf a message is available, this method calls the incoming_message_processing method.\nThe default value for the sleep delay is 0.1 seconds, but this value may be changed by setting the loop_time \nparameter in __init__.  5.\u00a0\u00a0incoming_message_processing  \n  incoming_message_processing(self, topic, payload)\n           Override this method with a custom python_banyan message\n           processor for subscribed messages\n\n           :param topic: Message Topic string\n           :param payload: Message Data\n           :return: No Return Value  This method is called by the receive_loop method for each message received. The message topic and payload are passed to \nthis method for processing.   This method must be overwritten to \nprocess the incoming messages.  6.\u00a0\u00a0clean_up  \n  clean_up(self)\n           Clean up before exiting - override if additional cleanup is necessary\n\n           :return: No Return Value  This method attempts to cleanly shutdown a Python Banyan component. Any additional clean up for your component may be\n placed in this method.",
            "title": "A Brief Look At The The Banyan Base Class"
        },
        {
            "location": "/#designing-for-python-banyan",
            "text": "The first step in designing a Python Banyan application is to define the feature set for the application. \nAn application may contain a single feature, such as in the first example we will cover, or it may contain many \nfeatures, such as the control and monitoring of a robotic vehicle.  Features are comprised of individual Python Banyan components.  Features should be designed to be as independent from other features as possible, and the components that comprise \nthe feature, should implement very targeted and specific behavior.  For example, a robot vehicle is likely to require motor control for speed and direction, and when the \nmotors are \nturning, wheel encoder telemetry may be generated.  One might think to combine both the motor control and encoder processing into a single feature, but it is probably \nbest to think of these as 2 separate features. The reason being, if you keep them separate you can reuse both \nfeatures in different scenarios without having to have one component carry the baggage of the other.  Once deciding upon a set of features, we need to go one level further deeper in decomposition, \nand that is to define our components.   Our initial clock demo is a rather simple one, so there is only a single feature - display the current time on a Web \npage.   For the clock demo, the feature can be broken down into three components. we will build three components as described \nbelow:     A  one second \"tick\" event generator . This component will publish a \"tick event\" message once every second. The \nmessage is \nconsistent with all other Python Banyan messages. It would be advantageous if this component could optionally set the\n tick period to be something other than one second so that testing can be accelerated, and so that the component \n could be reused in other features.    A  tick processor . This component subscribes to the \"tick event\" messages generated by the tick generator. It \naccumulates these ticks to form the \ncurrent time in seconds, minutes, and hours. Each unit is handled as a separate entity. When a tick message is \nreceived, \na seconds accumulator is incremented and tested to see if the seconds have reached a value of 60. If so the second \naccumulator is reset to 0, the minutes accumulator is incremented and an update message for the minutes is published.\n If the accumulated seconds is less \nthan 60, only an update message for seconds is published.\nThe processing\n of hours is handled in a very similar fashion.    The  clock GUI .\nThe GUI is a Web page display. It subscribes to and receives second_update, minute_update and hour_update messages. When\none of these messages is received, the display for that category is updated to the value in the message.    Now that we described what each component will do, it is time to design the messaging protocol for each component.\n  UML sequence diagrams  \ncan be helpful to capture the \nmessaging design.   This diagram captures what happens when the TickCounter receives a tick message. The current time had \nbeen 14:59:59. Because each of the time units needs to be advanced, a message for each unit type is generated and \nsent to the GUI. If a unit does not need to be advanced, no message is sent for that unit.   The sequence diagram shows the message originator and a sample of the message contents. So for example, a message with\n a topic of \"update_minutes\" is being sent to the GUI with a payload of {\"minutes: '06'}. By using a Python dictionary \n as\n the payload, the receiving class can easily dereference the contents of the payload.",
            "title": "Designing For Python Banyan"
        },
        {
            "location": "/#implementing-the-tick-generator-component",
            "text": "Now that we have our component and interface design complete, we may proceed to implement the design. For this \nexample, we will be running all components on a single computer. This application has been tested on a Raspberry Pi \nrunning Raspbian, on a desktop computer running Ubuntu 16.10, and on a Windows 10 computer.  \n# tick_generator.py\n\nfrom __future__ import absolute_import\nimport argparse\nimport signal\nimport sys\nimport time\n\ntry:\n    from python_banyan.banyan_base import BanyanBase\nexcept ImportError:\n    from python_banyan import BanyanBase\n\n\nclass TickGenerator(BanyanBase):\n    \"\"\"\n    This class will publish a \"tick\" message on a periodic basis. The period default\n    is 1 seconds, but may be set by the tick_duration_time parameter\n\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124',\n                 process_name='None', loop_time=.1, tick_duration_time=1.0, ):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        :param tick_duration_time:\n        \"\"\"\n        # initialize the base class\n        super(TickGenerator, self).__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                                            process_name=process_name,\n                                            loop_time=loop_time)\n\n        # allow time for ZeroMQ connections to form\n        time.sleep(.03)\n\n\n\ndef tick_generator():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-d\", dest=\"tick_duration_time\", default=\"1.0\",\n                        help=\"Set tick duration time\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Local Tick_Generator\", help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n    kw_options['tick_duration_time'] = float(args.tick_duration_time)\n\n    my_tick_gen = TickGenerator(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_gen.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_generator()  The source for the tick generation component is shown above. This component only publishes information and does not \nsubscribe\n to receive any messages. It consists of\nthe  TickGenerator  class \nthat \ncontains a \nsingle \nmethod, __init__, which overrides the __init__ method of the base class. There is also a function named,  tick_generator  that is defined outside of \nthe class.  This is an instantiation function \nthat is called by a \nstandard Python \ninvocation of:  if __name__  == '__main__':  Let's look at the code.   First, after importing some standard Python modules, we import the Python Banyan BaseClass. We then define the \ncomponent's class inheriting BanyanBase:  \nimport argparse\nimport signal\nimport sys\nimport time\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass TickGenerator(BanyanBase):  Now let's look at the __init__ method.  The first thing that the __init__ method does is initialize the parent class by calling super().       def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124',\n                 process_name='None', loop_time=.1, tick_duration_time=1.0, ):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        :param tick_duration_time:\n        \"\"\"\n\n        # initialize the base class\n        super(TickGenerator, self).__init__(back_plane_ip_address, subscriber_port,\n                                             publisher_port, process_name=process_name,\n                                            loop_time=loop_time)\n\n        # allow time for ZeroMQ connections to form\n        time.sleep(.03)  The signature of this derived method is similar to the parent, and all common arguments are passed to the parent \nwhen super() is called. There is an additional parameter, tick_duration_time, and this parameter allows us to \noptionally set \nthe \nperiod of a tick at invocation time. This is useful both for testing purposes, and if we wish to reuse this \ncomponent in some other feature.  As we shall see, this forms a pattern for all Python Banyan components. That is, a call to super() initializes the \nparent, and then there is a short waiting time to allow all ZeroMQ connections to be succeed. Note \nthat the parent class\n handles all of the connection details of ZeroMQ and are purposefully hidden from the derived class.  The __init__ method is extended with the following code:  \n        self.tick_duration_time = tick_duration_time\n\n        self.tick_topic = 'tick'\n        self.tick_payload = {'tick': True}\n\n        # This is a forever loop that publishes a tick message, once per second\n        while True:\n            try:\n                self.publish_payload(self.tick_payload, self.tick_topic)\n                time.sleep(self.tick_duration_time)\n            except KeyboardInterrupt:\n                sys.exit(0)  Variables are created and initialized. These variables save the tick duration time, and hold the message topic and \npayload.  The \ncode then \nenters a \n\"forever\" loop. This loop calls the parent method,  publish_payload  with the topic and payload for the tick. The \nmethod sleeps for the duration_time and then repeats.  The function outside of the class, tick_generator(), shown below,  although not required, demonstrates a Python Banyan \npattern \nto include command line arguments for the component as well as attaching a signal handler to allow a user to kill the\n component by pressing Control C. By combining this pattern with the  if __name__  == \n '__main__':  \nconstruct, setup.py has the capability to  automatically install the module as an executable on the executable path. We \nwill discuss this capability in  Chapter 4 .  The name of the component printed to the console is specified in this function by the default value for the process \nname.  def tick_generator():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-d\", dest=\"tick_duration_time\", default=\"1.0\",\n                        help=\"Set tick duration time\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Local Tick_Generator\", \n                        help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n    kw_options['tick_duration_time'] = float(args.tick_duration_time)\n\n    my_tick_gen = TickGenerator(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_gen.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_generator()  To see the available command line arguments for the component we invoke the component with a -h argument on the \ncommand line:  python3 tick_generator.py -h\nusage: tick_generator.py [-h] [-b BACK_PLANE_IP_ADDRESS]\n                         [-d TICK_DURATION_TIME] [-n PROCESS_NAME]\n                         [-t LOOP_TIME]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -b BACK_PLANE_IP_ADDRESS\n                        None or IP address used by Back Plane\n  -d TICK_DURATION_TIME\n                        Set tick duration time\n  -n PROCESS_NAME       Set process name in banner\n  -t LOOP_TIME          Event Loop Timer in seconds  For the purposes of this demo, we can accept all of the defaults. \nThe BACK_PLANE_IP_ADDRESS is used when we wish to run this component on a computer different from the computer that \nis running the backplane. We will see an example of this in a later demo.   The TICK_DURATION_TIME option allows us to set the period of the generated tick.   The PROCESS_NAME is an identifier that will be printed to the console when we start the component.  The LOOP_TIME allows us to modify the maximum amount of time that the Python Banyan received_loop waits before checking \nfor the next message to arrive. We will accept the default for this component  All of the command line arguments use the \n  Python argparse module  \nin a standard fashion.",
            "title": "Implementing The Tick Generator Component"
        },
        {
            "location": "/#executing-the-tick-generator-component",
            "text": "Before executing the first component of a Banyan application, the backplane must already be running. When Banyan is \ninstalled, \nthe backplane is installed as an executable on the executable path. To start the backplane, open up a command window,\n and type  backplane .   Next, open another command window and start the component. \nIf you installed the examples using  pip , then simply open up a command window and type tick_generator.   Or you if you cloned or forked the  python_banyan_examples  repository, go to the \ndirectory that \ncontains \ntick_generator.py, and then invoke it with python3:   Notice that backplane address and publisher and subscriber ports match between the backplane and the tick generator. \nThis happens automatically as result of inheriting the BanyanBase class.",
            "title": "Executing The Tick Generator Component"
        },
        {
            "location": "/#testing-the-tick-generator-component-introducing-the-monitor",
            "text": "Now that we have the backplane and the tick generator running, let's verify that the messages being published are \nwhat we designed. With the backplane and tick_generator running, start the monitor by opening a new command window \nand typing:  monitor   The monitor program is simply another Banyan component that can be plugged into or removed from the backplane at \nanytime.  We see that the topic and payload for each of the tick generator messages is displayed by the monitor.  The topic, \"tick\" is followed by the payload - {'tick': True}.   Let's compare this to our design:   The message matches perfectly with what we designed, we can go on to coding the next component.  If you do not see any messages on the monitor, make sure that the backplane is running. Also you may need to adjust the \nconnection wait time in \nyour \ncomponent:  \n# allow time for ZeroMQ connections to form\n        time.sleep(.03)  Be aware that when the monitor is attached to the backplane, it may affect performance of your application \nsince printing to the console can be quite time consuming.",
            "title": "Testing The Tick Generator Component - Introducing The Monitor"
        },
        {
            "location": "/#implementing-the-tick-counter-component-part-1",
            "text": "The tick processor subscribes to 'tick' messages, accumulates the ticks, processes the ticks and publishes \nupdate messages for seconds, minutes and hours.  # tick_counter.py\n\nimport argparse\nimport signal\nimport sys\nimport time\nimport datetime\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass TickCounter(BanyanBase):\n    \"\"\"\n    This class receives subscribes for tick messages\n\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125', \n    publisher_port='43124', process_name=None, loop_time=.1):\n        \"\"\"\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        \"\"\"\n        # initialize the base class\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port, \n                         process_name=process_name, loop_time=loop_time)\n\n        # allow time for ZeroMQ connections\n        time.sleep(.03)                         \n\n        # event message from RPi\n        self.set_subscriber_topic('tick')\n\n        # get the current time\n        current_time = datetime.datetime.now().time()\n\n        # set up some unit accumulator variables\n        self.hours = self.prev_hour = current_time.hour\n        self.minutes = current_time.minute\n        self.seconds = current_time.second\n\n        # publish the time for all 3 accumulators\n        self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n        self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n        self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        # receive loop is defined in the base class\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, \n                                          'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, \n                                          'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\ndef tick_counter():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                         help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Tick Counter\", \n                         help=\"Set process name in banner\")\n    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".1\", \n                         help=\"Event Loop Timer in seconds\")\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n    kw_options['loop_time'] = float(args.loop_time)\n\n    my_tick_counter = TickCounter(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_tick_counter.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    tick_counter()  If you compare this file with the tick generator, you will notice some very similar patterns. The invoking functions \nat the end of each file are almost identical, so we won't be discussing those again.  As do all Python Banyan component classes, the TickCounter class inherits the BanyanBase class. The __init__ method \nalso starts out with a standard pattern. The super() method is called and then there is a short wait time to allow \nfor the component to connect with the backplane.  Let's look at where things begin to differ in __init__:          # event message from RPi\n        self.set_subscriber_topic('tick')\n\n        # get the current time\n        current_time = datetime.datetime.now().time()\n\n        # set up some unit accumulator variables\n        self.hours = self.prev_hour = current_time.hour\n        self.minutes = current_time.minute\n        self.seconds = current_time.second\n\n        # publish the time for all 3 accumulators\n        self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n        self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n        self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        # receive loop is defined in the base class\n        self.receive_loop()  The parent method, set_subscriber() is called to subscribe to receive 'tick' messages.  Then the current time is read and the time unit variables are initialized with the current time values.  When the payload is constructed, the value string for each of the accumulators is zero filled so that each value is 2 \ndigits \nlong \nwith a \nleading \nzero when necessary.  The parent method, publish_payload is called for each of the unit accumulators and finally the receive_loop, defined \nin the parent is called, to receive incoming tick messages.",
            "title": "Implementing The Tick Counter"
        },
        {
            "location": "/#incrementally-testing-the-tick-processor-component-part-1",
            "text": "Since the __init__ method publishes some messages,  we can run the tick_counter by \nitself and \nmonitor its \noutput to \nverify the messages being sent within __init__ are what we expect.   First kill the tick generator component so that we can test the the tick counter as a standalone component.  Next restart the monitor component. Notice that we did not have to restart the backplane. You can add and remove \ncomponents at will.   Lastly, start the tick counter.      Comparing the messages with the original design, we see that they match in format. The actual payload contents \nreflect the time when the test was performed..   Now we can go on with the rest of the coding for the class.",
            "title": "Incrementally Testing The Tick Processor Component Part 1"
        },
        {
            "location": "/#writing-the-tick-counter-component-part-2",
            "text": "In the __init__ method, the parent method,  receive_loop  was called. It does not need to be changed for this \nexample and the parent method is executed as is with no overwrite.   The  receive_loop  constantly checks for the arrival of new messages. When a message has arrived,  receive_loop  calls\n the  incoming_message_processing  method. The parent version of this method is essentially a place holder\n  so we need to overwrite this method to process the message.  \n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, \n                                          'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, \n                                          'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, \n                                      'update_seconds')  When a tick message is received, this method increments the seconds accumulator and tests for a value of 60. If it is\n 60, the seconds need to be reset to 0, and the minutes incremented by 1. Then the code tests if the new minute \n cascades \n into a new hour and updates the hour accumulator appropriately.  For each of the accumulators, if an accumulator value changes, a message is published for that accumulator.",
            "title": "Writing The Tick Counter Component Part 2"
        },
        {
            "location": "/#incrementally-testing-the-tick-processor-component-part-2",
            "text": "Leaving the monitor and tick counter running, start the tick generator in a new command window.  Because the monitor prints all messages, we see a  tick message  followed by an  update_seconds message . When the \nseconds are currently at 59 and the next tick is received, the seconds are reset to zero immediately followed by\n an  update_minutes  message. If the hour had turned, a third \nmessage \nindicating this would have been published.   To test the turning of an hour, you can either wait, or when you start tick_generator.py you can modify the tick period\nto be a much shorter tick period by using the -d command line option.",
            "title": "Incrementally Testing The Tick Processor Component Part 2"
        },
        {
            "location": "/#integrating-a-gui-with-python-banyan",
            "text": "When creating a GUI for your application, Python offers many GUI libraries to choose from. When choosing a GUI, you \nwill need to integrate the GUI library's event loop with the Banyan event loop. Python \nBanyan  compatible  applications have been successfully integrated with the  tkinter,    kivy,     and  remi    The  remi  library, in my opinion, has an advantage over every other Python GUI library. That is, it creates a Web \nbased GUI totally written in Python. You get all the advantages of having a Web based GUI, such as portability, \nwithout having to deal with HTML/CSS/JavaScript.  With  remi  you have the choice of implementing your GUI by writing code to access the  remi  APIs directly or \nhave\n  remi  generate the code for you. Remi includes a  What You See Is What You Get  (WYSIWYG)\neditor. There is a  preliminary tutorial  \n that demonstrates how easy the graphical editor is to use. The editor not \nonly allows you \nto visually layout your GUI,  but generates the code that will both launch an HTTP server and then display your Web page\n on \nyour default browser. If you want to access your GUI from a remote device, such as a phone or tablet - no problem,  remi  allows multiple connections to the Web server.  Another great advantage of using  remi  to generate the code, is that it not only saves coding time, but testing time\n as well.  For this demo project, we used the WYSIWYG editor to generate the GUI.    A more complicated GUI was designed and \nimplemented \nusing the editor and is included with code in the Python Banyan Examples repository for the  robot example",
            "title": "Integrating a GUI With Python Banyan"
        },
        {
            "location": "/#integrating-remi-generated-code-with-python-banyan",
            "text": "To turn the generated code into a Banyan component, we need to perform several coding steps.  A \"before\" and \n\"after\" snapshot of the code will be displayed for each step along the way, in addition to some explanatory text.  1.Add imports, rename the class, and add Python Banyan specific variables to the generated GUI class.  Unmodified Generated Code  import remi.gui as gui\nfrom remi.gui import *\nfrom remi import start, App\n\n\nclass untitled(App):\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(untitled, self).__init__(*args, static_file_path='./res/')  Modified Code  import sys\nimport socket\nimport signal\nimport zmq\nimport umsgpack\nimport remi.gui as gui\nfrom remi.gui import *\nfrom remi import start, App\n\n\nclass GuiClock(App):\n\n    # ZeroMQ backplane address\n    back_plane_ip_address = None\n\n    #ZeroMQ backplane ports\n    subscriber_port = '43125'\n    publisher_port = '43124'\n\n    # ip address where the remi server is running\n    gui_ip_address = None\n\n    # ZeroMQ connections\n    publisher = None\n    subscriber = None\n\n    # topics that this application wishes to subscribe to\n    subscriber_topics = ['update_seconds', 'update_minutes', 'update_hours']\n\n    # The ZeroMQ context\n    context = None\n\n\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(GuiClock, self).__init__(*args, static_file_path='./res/')  For this step we added some additional module imports, renamed the class and added some class level variables.\nIn addition, a list of subscription topics is created.  The __init__ method for this example did not need to be modified.  2. Overwrite the  remi  idle() method to incorporate the Python Banyan event loop functionality.  Unmodified Generated Code      def idle(self):\n        #idle function called every update cycle\n        pass  Modified Code      def idle(self):\n        # idle function called every update cycle\n        data = None\n\n        try:\n            data = self.subscriber.recv_multipart(zmq.NOBLOCK)\n            self.incoming_message_processing(data[0].decode(), umsgpack.unpackb(data[1]))\n        except zmq.error.Again:\n            pass\n        except KeyboardInterrupt:\n            self.clean_up()  The  idle  method gets called at a user settable rate (more about that later). Here, we added code from the \nBanyanBase class that looks very similar and acts as the Banyan receive_loop(). When a message is received, this \nmethod will call the incoming_message_processing method, the same as is done in BanyanBase.  3. Modify the  remi  main() method to connect publisher and subscriber sockets to the Python Banyan backplane.  Unmodified Generated Code      def main(self):\n        return untitled.construct_ui(self)  Modified Code      def main(self):\n        print('\\n************************************************************')\n        print('Clock GUI using Back Plane IP address: ' + self.back_plane_ip_address)\n        print('GUI IP Address = ' + self.gui_ip_address)\n        print('Subscriber Port = ' + self.subscriber_port)\n        print('Publisher  Port = ' + self.publisher_port)\n        print('************************************************************')\n\n        self.context = zmq.Context()\n        # noinspection PyUnresolvedReferences\n        self.subscriber = self.context.socket(zmq.SUB)\n        for topic in self.subscriber_topics:\n            self.subscriber.setsockopt(zmq.SUBSCRIBE, topic.encode())\n        #\n        connect_string = \"tcp://\" + GuiClock.back_plane_ip_address + \n                         ':' + self.subscriber_port\n        self.subscriber.connect(connect_string)\n        #\n        # noinspection PyUnresolvedReferences\n        GuiClock.publisher = self.context.socket(zmq.PUB)\n        connect_string = \"tcp://\" + GuiClock.back_plane_ip_address + \n                          ':' + self.publisher_port\n        self.publisher.connect(connect_string)\n        the_gui = GuiClock.construct_ui(self)\n        # alias to help access widgets directly\n        GuiClock.the_widgets = self.clock_top_panel.children\n        return the_gui  This code looks and acts very similarly to the BanyanBase __init__ method. It instantiates ZeroMQ, creates the \nconnections to the backplane, and calls the generated  construct_ui()  method. This method \ninstantiates\n all of the widgets.  In addition, all of the topics in the list of subscriber topics are registered.  We also added and initialized a variable called  the_widgets  that is used as a handle to gain access to and \nmanipulate the generated widgets.   4. Add a new method to  remi  class to process incoming messages that have been subscribed to.      def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n        if topic == 'update_seconds':\n            self.the_widgets['label_seconds'].set_text(payload['seconds'])\n        elif topic == 'update_minutes':\n            self.the_widgets['label_minutes'].set_text(payload['minutes'])\n        elif topic == 'update_hours':\n            self.the_widgets['label_hours'].set_text(payload['hours'])  This is the method that dereferences and processes the incoming messages that the GUI subscribed to. Here we are \nupdating the label widgets for seconds, minutes and hours.  5. Add a new method to publish Python Banyan compatible messages.      def publish_payload(self, payload, topic=''):\n        \"\"\"\n        This method will publish python_banyan payload with the specified topic.\n\n        :param payload: A dictionary of items\n        :param topic: A string value\n        :return:\n        \"\"\"\n        if not type(topic) is str:\n            raise TypeError('Publish topic must be python_banyan string', 'topic')\n\n        # create python_banyan message pack payload\n        message = umsgpack.packb(payload)\n\n        pub_envelope = topic.encode()\n        self.publisher.send_multipart([pub_envelope, message])  This method prepares and publishes a message to the Banyan backplane.  6. Add a clean_up method to cleanly take down Python Banyan connections and to close ZeroMQ      def clean_up(self):\n        \"\"\"\n        Clean up before exiting - override if additional cleanup is necessary\n\n        :return:\n        \"\"\"\n        self.publisher.close()\n        self.subscriber.close()\n        self.context.term()  This method closes the ZeroMQ connections and terminates the ZeroMQ instance.  7. Create A Modified Instantiation Function  Unmodified Generated Code  \n\n#Configuration\nconfiguration = {'config_enable_file_cache': True, 'config_start_browser': True, 'config_address': '0.0.0.0', \n                 'config_project_name': 'untitled', 'config_port': 8081, 'config_resourcepath': './res/', \n                 'config_multiple_instance': True}\n\nif __name__ == \"__main__\":\n    # start(MyApp,address='127.0.0.1', port=8081, multiple_instance=False,enable_file_cache=True, \n                           update_interval=0.1, start_browser=True)\n\n    start(untitled, address=configuration['config_address'], port=configuration['config_port'], \n                        multiple_instance=configuration['config_multiple_instance'], \n                        enable_file_cache=configuration['config_enable_file_cache'],\n                        start_browser=configuration['config_start_browser'])  Modified Code  def clock_gui():\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # use the google dns\n    s.connect(('8.8.8.8', 0))\n    GuiClock.gui_ip_address = s.getsockname()[0]\n\n    # test if user wants to specify the backplane address\n    if len(sys.argv) > 1:\n        GuiClock.back_plane_ip_address = sys.argv[1]\n    # argument, so just use the local host\n    else:\n        GuiClock.back_plane_ip_address = s.getsockname()[0]\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    start(GuiClock,  debug=False, address=GuiClock.gui_ip_address,\n          update_interval=.00001)\n\n\nif __name__ == \"__main__\":\n    clock_gui()  This method sets the IP address of the remi HTTP server to be the IP address of the invoking machine.  It checks to see if there was a command line argument provided to set the backplane IP address. If not, it uses\nthe address of the local machine.  Signal handlers are attached to detect the user terminating the component.  The  remi  start() method is called passing the name of the GUI class, turning debugs off, the address to use for the\n HTTP server and finally the update_interval for the idle loop.",
            "title": "Integrating remi Generated Code With Python Banyan"
        },
        {
            "location": "/#testing-the-application",
            "text": "Now that we have all of our components for this application written, we can start the GUI to perform end to end testing.  To start the application:   Start the backplane.  Start the GUI.  Start the tick processor.  Start the tick generator.",
            "title": "Testing the Application"
        },
        {
            "location": "/#component-startup-order",
            "text": "Does the order that we start our components matter? That depends upon the application and how we designed the \napplication. For our \nexample, it turns out it does. If the GUI is started last, most likely you will only see the seconds display, that is\n until there is a turn of an hour. To fix this behavior, the GUI could publish a message, and the tick processor can \n subscribe to this message. The message would request that the full current time be published.   The installed example code, as well as the code published on Github, was \nmodified to do just that.  The __init__ method in gui_clock.py was modified to publish a message requesting the current time. The message \ncontains the topic: 'update_me' \nand a payload \nof: \n{'first':\n 'a'}.   Because this is in the __init__ method, this message is only published once, when the class is instantiated.  class GuiClock(App):\n    back_plane_ip_address = None\n    gui_ip_address = None\n    publisher = None\n    subscriber = None\n    subscriber_port = '43125'\n    publisher_port = '43124'\n    subscriber_topics = ['update_seconds', 'update_minutes', 'update_hours']\n    context = None\n    default_button_color = '#1d81f1'\n\n    def __init__(self, *args, **kwargs):\n        if not 'editing_mode' in kwargs.keys():\n            super(GuiClock, self).__init__(*args, static_file_path='./res/')\n\n            # request for time to be updated\n            self.publish_payload({'first': 'a'}, 'update_me')  The tick_counter, was modified to subscribe to the 'update_me' topic and when it receives an 'update_me' message, it \nreturns messages for all three time units.\nThe incoming_message_processing method for tick_counter.py is shown below.      def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method accumulates ticks and publishes update message for the GUI\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        if topic == 'tick':\n            self.seconds += 1\n\n            if self.seconds == 60:\n\n                current_time = datetime.datetime.now().time()\n                self.seconds = current_time.second\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n                self.hours = current_time.hour\n\n                if self.hours != self.prev_hour:\n                    self.prev_hour = self.hours\n                    self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n\n                if self.minutes != current_time.minute:\n                    self.minutes = current_time.minute\n                    self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n\n                self.seconds = current_time.second\n            else:\n                self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')\n\n        elif topic == 'update_me':\n            # current_time = datetime.datetime.now().time()\n            self.publish_payload({'hours': str(self.hours).zfill(2)}, 'update_hours')\n            self.publish_payload({'minutes': str(self.minutes).zfill(2)}, 'update_minutes')\n            self.publish_payload({'seconds': str(self.seconds).zfill(2)}, 'update_seconds')  Back to testing. Because we have tested our messaging interface all along the way, we only need to concentrate on \nverifying that the GUI is displaying the time units correctly. Using remi to generate the GUI code also made testing \nsimpler since we bypassed hand coding widget creation, instantiation and testing the results.  Your default web browser should open and the time should be displayed, being updated every second.",
            "title": "Component Startup Order"
        },
        {
            "location": "/#component-launch-strategies",
            "text": "For a small application with only a few components, it is not difficult to open a separate command or shell window for\n each component. For larger applications, this quickly becomes unmanageable. Here are some strategies that simplify \n the launching of an application using a single command.",
            "title": "Component Launch Strategies"
        },
        {
            "location": "/#windows",
            "text": "For windows, create a .bat file to launch all of the components. Here is the contents of a file named clock.bat \nthat \nwill \nlaunch all of the clock demo components in separate command windows.  start backplane.exe\nstart tick_generator.exe\nstart tick_counter.exe\nstart clock_gui.exe",
            "title": "Windows"
        },
        {
            "location": "/#mac",
            "text": "For the Mac, you can create a shell script that will launch the components and when Control C is pressed, will kill \nall of the components.  The launching file should contain a \".sh\" extension, and you should change the files permissions to be executable.\nHere is a sample shell script to launch the clock demo named clock_demo.sh:  #!/bin/bash\n\necho 'Press Control C to kill all of the components.'\n\nxterm -e backplane &\nxterm -e clock_gui &\nxterm -e tick_counter &\nxterm -e tick_generator\n\nfunction finish {\n   killall backplane\n   killall clock_gui\n   killall tick_counter\n   killall tic_generator\n}\n\ntrap 'kill $(jobs -p)' SIGINT  To make this file executable after it is created, use:  chmod ugo+x clock_demo.sh  Then to run the script type:  \n./clock_demo.sh",
            "title": "Mac"
        },
        {
            "location": "/#linux",
            "text": "For Linux, you may use the same shell script shown above for the Mac, or you can use a utility called  Lunch . To\n install lunch on Ubuntu or the Raspberry Pi, open a command window and type:   sudo apt-get install python-lunch  The Lunch utility uses a configuration file, called .lunchrc to launch the components. If you installed the examples\n  onto your computer using pip or setup.py, you can automatically create the .lunchrc file for the clock demo by \n  opening a command window and typing:    lunch_config   A .lunchrc file will installed in your home directory, which is where lunch expects to find the file.  Here is the contents of that file:  add_command(command=\"backplane\", env={}, identifier=\"back_plane\")\nadd_command(command=\"tick_generator\", env={}, identifier=\"tick_generator\")\nadd_command(command=\"tick_counter\", env={}, identifier=\"tick_counter\")\nadd_command(command=\"clock_gui\", env={}, identifier=\"clock_gui\")  Each line adds a command for lunch to execute. The \"command\" parameter is the name of the executable to launch, the \n\"env\" is unused for our purposes and left as {}, and the \"identifier\" parameter allows us to pick a name of our \nchoosing.  Note that if you execute the lunch_config program again, it will overwrite any changes you may have made to the \n.lunchrc file, so you may wish to backup this file before running lunch_config.  Lunch installs a menu item with a cherry as its icon.   On Raspbian, after installing lunch, you will find it under the System Tools menu on the GUI.   When you invoke lunch from the GUI, you will see window that looks something like this:   If lunch fails to be able to start a process, it will constantly retry, until it succeeds.  Through the lunch gui, you can start and stop individual components, and view their console output.  When you exit the lunch GUI window, all launched components will exit.",
            "title": "Linux"
        },
        {
            "location": "/#chapter-2-physical-computing-gpio-interfacing",
            "text": "Now that we know the basics of programming with Python Banyan, let's move on to creating a Python Banyan\napplication \nto control the digital output pins for both a Raspberry Pi and an Arduino.  In this chapter, the application requirements will be stated, and a typical \"use case\" will be provided. Previously, we \nused a \nsequence \ndiagram to help capture the design. A \ndescriptive text approach will be used for this chapter as a contrast with the sequence diagram approach.  The examples will be executed on a Raspberry Pi.",
            "title": "CHAPTER 2: &nbsp;PHYSICAL COMPUTING - GPIO INTERFACING"
        },
        {
            "location": "/#application-requirements",
            "text": "The application shall allow a user to toggle one or more digital output pins (simultaneously) on the target device \n(Arduino or \nRaspberry Pi)  The user shall be able to set the toggle rate when the application begins.  Other than the component that controls the board specific GPIO interface, a common, non-hardware specific code set, \nshall be implemented to \ncontrol the Arduino and Raspberry Pi, simultaneously or singularly.",
            "title": "Application Requirements"
        },
        {
            "location": "/#use-case",
            "text": "A potential use case is to have the ability to  toggle  a light source and a video camera, on and off simultaneously.\nThe camera and light source may be attached to a single or multiple Raspberry Pi modules or a Raspberry Pi and an \nArduino.",
            "title": "Use Case"
        },
        {
            "location": "/#simulation-application",
            "text": "For the purposes of this demo application, the camera and light source are simulated by using discrete LEDs in their \nplace.",
            "title": "Simulation Application"
        },
        {
            "location": "/#component-high-level-design",
            "text": "When designing a component, a separation of concerns should always be the goal. In this example, all the components \nare designed with a specific purpose in mind. This not only makes testing easier, but promotes component reuse for \nfuture projects.  Instead of using a sequence diagram to capture our design, we will be using a text based approach.  Our design will consist of three components. The first is an  event generator  that is a reuse of the tick generator\ncreated in chapter 1. The second component is a  \"toggler\"  component that will  interpret the events of the tick \ngenerator and translate \nthose events into \"toggle\" messages . Both of these components are hardware independent. The  third component  \nwill translate the \n\"toggle\" messages into actions that  directly control the GPIO pins of either the Raspberry Pi or Arduino . There \nwill \nbe two implementation versions for this component. One for the Raspberry PI, using  pigpio  library, and for the Arduino, the PyMata  library  Here is the design for each component.    An event generator component that will trigger the toggling of the pin state.   Reuse the tick_generator created for chapter 1.   Subscribes to:   Does not subscribe to any messages.    Messages Published:  topic: 'tick'  payload: {'tick': True}       A \"toggler\" component. This will keep track of the last state change and send a message to toggle to the opposite \nstate.   A new component.  Subscribes to:  'tick' topic    Messages Published:  topic: 'digital_output'  payload: {'command': 'set_state', 'state': 0 or 1}       Separate GPIO interface components for the Arduino and for the Raspberry Pi. These components translate the \ndigital_output topic messages into GPIO library commands.   A new component.  Subscribes to:  'digital_output' topic - translates the messages into low-level, board specific GPIO control methods.    Messages Published:  None.",
            "title": "Component High Level Design"
        },
        {
            "location": "/#component-implementation",
            "text": "",
            "title": "Component Implementation"
        },
        {
            "location": "/#tick_generator",
            "text": "This component is reused from chapter 1 and \nis described  here",
            "title": "tick_generator"
        },
        {
            "location": "/#toggler",
            "text": "This component is very similar in form to all the other components discussed in chapter 1. The class definition is\nshown below, and the comments in the code adequately describe its contents.  The standard Python Banyan component instantiation scheme as discussed  here  is used as \nwell.  # toggler.py\n\nimport sys\nimport signal\nimport argparse\nimport time\n\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass Toggler(BanyanBase):\n    \"\"\"\n    This class is a subscriber for \"tick\" messages. When a tick message is received, \n    it will togglea state variable and then  publish a digital_output message with\n    a payload reflecting the current state.\n\n    It is independent of any specific hardware platform.\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None, loop_time=.1):\n        \"\"\"\n\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        :param loop_time:\n        \"\"\"\n\n        # initialize the parent\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                         process_name=process_name, loop_time=loop_time)\n\n        # allow time for zmq connections to be established\n        time.sleep(.03)\n\n        # subscribe to topics\n        self.set_subscriber_topic('tick')\n\n        # last digital output state\n        self.tick_tock = 0\n\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        This method will toggle the tick_tock state with each incoming tick.\n        It will then publish the new state as a digital_output topic message\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n        if topic == 'tick':\n            self.tick_tock ^= 1\n            payload = {'command': 'set_state', 'state': self.tick_tock}\n            self.publish_payload(payload, 'digital_output', )",
            "title": "toggler"
        },
        {
            "location": "/#testing-togglerpy",
            "text": "Start the backplane.  start tick_generator.  start the monitor.  start the toggler.   As you can see below with each tick, the toggler changes the state in the published digital_output message, and meets\n our\n design.",
            "title": "Testing toggler.py"
        },
        {
            "location": "/#rpi_digital_out",
            "text": "Once again, the familiar Python Banyan class definition patterns emerge. Let's take a look at what is new.  import argparse\nimport signal\nimport sys\nimport time\n\nimport pigpio\n# noinspection PyUnresolvedReferences\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass RPiDigitalOut(BanyanBase):\n    \"\"\"\n    This class is the interface class for Raspberry Pi digital\n    output control using the pigpio library.\n\n    It is used to set  BCM pins as digital outputs and to set their states.\n    \"\"\"\n\n    def __init__(self, pins, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None):\n        \"\"\"\n        Initialize the BanyanBase parent object.\n        Subscribe to topics of interest.\n        Create an instance of pigpio\n\n        :param back_plane_ip_address:\n        :param subscriber_port:\n        :param publisher_port:\n        :param process_name:\n        \"\"\"\n        # initialize the base class and wait for zmq connections to complete\n        super().__init__(back_plane_ip_address, subscriber_port, publisher_port,\n                         process_name=process_name)\n\n        time.sleep(.3)\n\n        # set the subscriber topic\n        self.set_subscriber_topic('digital_output')\n\n        # create a pigpio object\n        # make sure to start the pipgio daemon before starting this component\n        self.pi = pigpio.pi()\n\n        # save the requested list of pins that need to be controlled\n        self.pins = pins\n\n        # set all the pins in the list to output pins\n        for pin in pins:\n            self.pi.set_mode(pin, pigpio.OUTPUT)\n\n        # subscribe to digital_output messages\n        self.set_subscriber_topic('digital_output')\n\n        # start the receive loop\n        self.receive_loop()  The first thing to notice in the __init__ method, is the addition of the parameter 'pins'. This parameter is a \nlist of BCM pins that we wish \nto toggle. The list is specified with the required -p option when the component is invoked. The format of the \ncommand line option is -p \nfollowed by the space delimited list of pins we wish to affect. The reason that this is a required option is, that \nunlike the Arduino, the Raspberry Pi has no built in LED.  After \ninstantiating the pigpio library, we use the list of pins to set each pin in the list as an output pin.  We then subscribe to the 'digital_output' messages published by the toggler component, and then call the receive loop\n to wait for incoming messages.      def incoming_message_processing(self, topic, payload):\n        \"\"\"\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        # set the state for all the pins in the pin list\n        if payload['command'] == 'set_state':\n            for pin in self.pins:\n                self.pi.write(pin, payload['state'])\n        else:\n            raise TypeError('Unknown command received')  The incoming_message_processing method sets the state of each pin in the pin list to the state specified in the \n payload of the message.  Next is The pi_digital_out() invocation function that uses the standard Python Banyan pattern. The only major change\n  is the \naddition of the -p option. This is a required option and at least one pin must be provided.   def rpi_digital_out():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"LED Back End\",\n                        help=\"Set process name in banner\")\n\n    parser.add_argument('-p', nargs='+', required=True, type=int, dest='pins',\n                        help='Required - Enter a list of space delimited pin numbers')\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n\n    my_rpi_digital_out = RPiDigitalOut(args.pins, **kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        my_rpi_digital_out.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    rpi_digital_out()",
            "title": "rpi_digital_out"
        },
        {
            "location": "/#testing-rpi_digital_out",
            "text": "Connect an LED or LEDs to the bcm pin(s) of your choice. With the backplane,tick_generator and toggler \ncomponents running, start \nrpi_digital_out by specifying the pins you wish to toggle You \nshould see the LED or LEDs blink at 1 second rate.  To simplify testing, you can use a Raspberry Pi hat, such as the Pibrella, or  wire one up on your own.  Using the  Pibrella green LED (BCM pin 4) and yellow LED (BCM pin 17)  rpi_digital_out is \ninvoked using\n the -p \noption, with the following command line:  rpi_digital_out -p 4 17  Since we are using the pigpio library, we need to first start its daemon by executing the following command:  sudo pigpiod  Next, to simplify the application start up, the .lunchrc may be updated by adding the toggler and \nrpi_digital_out components.  add_command(command=\"backplane\", env={}, identifier=\"back_plane\")\nadd_command(command=\"tick_generator\", env={}, identifier=\"tick_generator\")\nadd_command(command=\"tick_counter\", env={}, identifier=\"tick_counter\")\nadd_command(command=\"clock_gui\", env={}, identifier=\"clock_gui\")\nadd_command(command=\"toggler\", env={}, identifier=\"toggler\")\nadd_command(command=\"rpi_digital_out -p 4 17\", env={}, identifier=\"rpi_digial_out\")",
            "title": "Testing rpi_digital_out"
        },
        {
            "location": "/#adding-an-arduino-component-into-the-mix",
            "text": "Continuing on with the GPIO control theme, we are going to add a component that will blink the board LED connected to\n pin 13 on an \nArduino. We will be using the PyMata control library to control pin 13 on the Arduino. This library was chosen over \nthe newer pymata-aio library, because pymata-aio requires the use of Python 3.5 or greater. Using PyMata will allow \nus to continue using Python 3.4.2 that is installed with the Raspberry Pi Raspbian distribution of 2017-01-11.  To install PyMata, open up a command window on the Raspberry Pi and type:  sudo pip3 install PyMata  PyMata implements the Firmata protocol. You will need to install the StandardFirmata Arduino sketch that is included \nwith the Arduino IDE, or the \nFirmataPlus sketch that comes with as part of the PyMata package. For further information on PyMata, please check out\n the  PyMata Github page  and the  PyMata Wiki page.  Here is the source code for  arduino_digital_out  # arduino_digital_out.py\n\nimport time\nimport sys\nimport signal\nimport argparse\nimport zmq\nimport umsgpack\n\nfrom PyMata.pymata import PyMata\nfrom python_banyan.banyan_base import BanyanBase\n\n\nclass ArduinoDigitalOut(BanyanBase):\n    \"\"\"\n    This class is the interface class for Arduino output using the\n    PyMata library.\n\n    It is used to set a BCM pin as a digital output and to set its state.\n    \"\"\"\n\n    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',\n                 publisher_port='43124', process_name=None, pins=[13],\n                 com_port='/dev/tty_ACM0'):\n\n        super(ArduinoDigitalOut, self).__init__(back_plane_ip_address, subscriber_port, \n                                                publisher_port, process_name=process_name)\n\n        time.sleep(.3)\n\n        # initialize pin direction\n\n        self.pins = pins\n        self.com_port = com_port\n\n        self.board = PyMata(com_port, verbose=True)\n\n        for pin in pins:\n            self.board.set_pin_mode(pin, self.board.OUTPUT, self.board.DIGITAL)\n\n        self.set_subscriber_topic('digital_output')\n\n        self.receive_loop()\n\n    def incoming_message_processing(self, topic, payload):\n        \"\"\"\n\n        :param topic: Message Topic string\n        :param payload: Message Data\n        :return:\n        \"\"\"\n\n        # set the state of the pin specified in the message.\n        if payload['command'] == 'set_state':\n            for pin in self.pins:\n                self.board.digital_write(pin, payload['state'])\n        else:\n            raise TypeError('Unknown command received')\n\n\ndef arduino_digital_out():\n    # noinspection PyShadowingNames\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",\n                        help=\"None or IP address used by Back Plane\")\n    parser.add_argument(\"-c\", dest=\"com_port\", default=\"/dev/ttyACM0\",\n                        help=\"Enter Arduino Com Port\")\n    parser.add_argument(\"-n\", dest=\"process_name\", default=\"Arduino Digital Output\",\n                        help=\"Set process name in banner\")\n\n    parser.add_argument('-p', nargs='+', type=int, default=[13], dest='pins',\n                        help='Required - Enter a list of space delimited pin numbers')\n\n    args = parser.parse_args()\n    kw_options = {}\n\n    if args.back_plane_ip_address != 'None':\n        kw_options['back_plane_ip_address'] = args.back_plane_ip_address\n\n    kw_options['process_name'] = args.process_name\n\n    kw_options['com_port'] = args.com_port\n\n    ard_dig_out = ArduinoDigitalOut(**kw_options)\n\n    # signal handler function called when Control-C occurs\n    # noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocal\n    def signal_handler(signal, frame):\n        print('Control-C detected. See you soon.')\n\n        ard_dig_out.clean_up()\n        sys.exit(0)\n\n    # listen for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n\nif __name__ == '__main__':\n    arduino_digital_out()  The __init__ method contains a pins parameter similar to that of the rpi_digital_out component. This parameter \nhas a default value of pin 13 for the Arduino board LED. Additional pins can be enabled by using the -p option when \ninvoking arduino_digital_out. For arduino_digital_out the -p is not required as it is for the Raspberry Pi.  An instance of PyMata is created and the PyMata API is used to set the specified pins for digital output.  There is also a com_port parameter. The Arduino communicates over a serial interface, and the default is \n/dev/tty/ACMO, which is the default when we plug the Arduino USB connector into the Raspberry Pi. This value may be \noverwritten using the -c command line option.  The incoming_message_processing method set the state of the output pin using the PyMata API as well.  When the arduino_digital_out component is invoked from a terminal window, here is its output:   PyMata announces the com port it is using, the number of pins it found on the Arduino device. The component will then\n proceed to blink the Arduino LED.",
            "title": "Adding An Arduino Component Into The Mix"
        },
        {
            "location": "/#and-now-for-something-totally-different-adding-a-javascript-banyan-compatible-module-to-the-application",
            "text": "We are about to add an additional component to our already running system. This module, however is written in \nJavaScript. It so happens that you may write a component in any language that supports both ZeroMQ and MessagePack, \nand there is a very   long list of languages that do.  \nlong list of languages that do.\nBut why would you want to do something like this? Here are some reasons:   You need support for a hardware device. The only support you can find is written in another language and \nporting would be difficult,\n if not \nimpossible.  You would like to perform a remote procedure call with a component written in something other than Python to perform \nsome task, perhaps some complicated data analysis.   The flexibility of Python Banyan allows you to craft components to meet your application's needs, including doing so \nin a language other than Python.  The following is a simple JavaScript component. When executed using node.js, it attaches itself to the backplane \nand when it receives an update_seconds messages, it prints the topic and payload to the console.  // node_backplane_monitor.js\n\n// This is a simple JavaScript monitor compatible with Python Banyan.\n// It subscribes to all messages with the topic of \"update_seconds\"\n\n\nvar zmq = require('zmq'),\n    sock = zmq.socket('sub');\n\nvar msgpack = require(\"msgpack-lite\");\nvar data;\n\n// remember to set ip address to the same ip address that the backplane uses.\nsock.connect('tcp://192.168.2.185:43125');\n\n//sock.subscribe('update_seconds');\nsock.subscribe('update_seconds');\n\nconsole.log('Subscriber connected to port 43125');\n\nsock.on('message', function(topic, message) {\n  data = msgpack.decode(message);\n  console.log('received a message related to:', \n              topic.toString('utf-8'), 'containing message:', data);\n\n});  The code connects to the backplane located at 192.168.2.185:43125, which just happens to be the IP address and port for \nthe backplane that is running on my Raspberry Pi. If you would like to try this on your network, you will most likely\n need to change the IP address, but the port number may stay the same.  The component then subscribes to receive \"update_seconds\" \nmessages and prints the\n messages to the console. Here is some output when the component was run on an Ubuntu 16.10 computer. Since the IP \n address is hardcoded for this example, it automatically connects to the backplane and prints the messages it \n subscribed to.  $ node node_backplane_monitor.js\nSubscriber connected to port 43125\nreceived a message related to: update_seconds containing message: { seconds: '27' }\nreceived a message related to: update_seconds containing message: { seconds: '28' }\nreceived a message related to: update_seconds containing message: { seconds: '29' }\nreceived a message related to: update_seconds containing message: { seconds: '30' }  The version of node.js that is supplied with Raspbian is old and will not work with ZeroMQ. It needs to be updated, but \ndoing\n so removes node red. So unless you are willing to put in the effort to update node.js, and willing to lose node red,\n it is probably easier to run this example on some other computer.",
            "title": "And Now, For Something Totally Different - Adding A JavaScript Banyan Compatible Module To The Application"
        },
        {
            "location": "/#distributing-python-banyan-components-across-multiple-computers",
            "text": "We have already seen an example of running a Python Banyan component on a computer that is not running the backplane \nin the  previous section.    To keep things simple, the JavaScript example did not implement command line option processing, so if we want to \nconnect the component to something other than the hard-coded IP address, the code would need to be modified.  If you recall, for all the other examples, as a standard Python Banyan pattern, the Python argparse library was used\n to help retrieve any command line options the user wishes to use. \nThe \"-b\" option allows a user to specify the IP address for the backplane.  Here is a component distribution map. All of the computers have had Python Banyan and the example distribution \ninstalled. The examples distribution installs all of the components as executables and we will take advantage of that.\nSee  Chapter 4  for instructions on how to turn your \nmodules into executables.     Component  Computer  IP Address      backplane  Raspberry Pi  192.168.2.185    monitor  Windows 10 (virtual box)  192.168.2 180    tick_generator  Ubuntu 16.10  192.168.2.190    tick_counter  OBRevenge Linux (virtual box)  192.168.2.181    toggler  Raspberry Pi  192.168.2.185    rpi_digital_out  Raspberry Pi  192.168.2.185    arduino_digital_out  Ubuntu 16.10  192.168.2.190    clock_gui  Windows 10 (virtual box)  192.168.2 180     There are no code changes necessary to start any of the modules on any of the computers. The only thing you need to \nkeep track of is the IP address of the computer where the backplane was invoked, and then use the -b option when \ninvoking the component. For the components to be run on the \nRaspberry Pi, no command line option is needed, since they will automatically attach to the backplane. Just remember \nto start the backplane before starting any other component.  Here are the Raspberry Pi components being started:   \nNow let's start the tick_counter on the OBRevenge machine using the -b option:  tick_counter -b 192.168.2.185    On to the Ubuntu computer where will start the tick_generator and the arduino_digital_out components:    And finally we start the clock_gui and monitor components on the Windows 10 machine. The clock_gui does not use \nargparse and so its command line argument to set backplane address simply follows the command:  clock_gui 192.168.2.185    And there you have it. All the components have been distributed and are running without a single line of code needing\n to be changed.",
            "title": "Distributing Python Banyan Components Across Multiple Computers"
        },
        {
            "location": "/#chapter-3-adding-an-i2c-based-bcd-time-display",
            "text": "Before moving on to the next topic, let's review what we have \naccomplished so far.\nWe've created an application consisting of 2 independent  features  that execute concurrently within a single \napplication. Each feature is \nconstructed as a set of Python Banyan  components , and some of these components are being shared and simultaneously \nused by both \nfeatures.   Here is a table summarizing these features and the components used to implement each one:     Feature  Component      Web Clock  clock_generator     tick_counter     clock_gui    Pin Toggler  clock_generator     tick_counter     toggler     rpi_digital_out     arduino_digital_out     Now, let's continue on with our \"clock\" theme by attaching an  Adafruit Bicolor LED Square Pixel Matrix \nto the i2c pins of the Raspberry Pi, and using the display as a  BCD clock display .   \nThe time being displayed in the photo at the top of this chapter is 14:12:24. The green LEDs represent a \"1\" and red \nLEDs \nrepresent a \"0\".",
            "title": "CHAPTER 3: &nbsp;ADDING AN I2C BASED BCD TIME DISPLAY"
        },
        {
            "location": "/#the-high-level-component-design",
            "text": "",
            "title": "The High Level Component Design"
        },
        {
            "location": "/#component-1-binary_clockpy",
            "text": "The highest level component for the BCD clock is called binary_clock.py and it is an abstraction of the BCD \ndisplay configured as a BCD display.  This component subscribes to update_hours, update_minutes and update_seconds messages, and then translates those \nmessages into commands for the underlying i2c device, (HTK1633), to control the individual pixels to display the \ntime in BCD format. It publishes messages containing a topic of \"8x8_matrix\" for each pixel to be modified for the \nupdated unit. The payload for these messages is:  \n {'command': 'set_pixel', 'x': row, 'y': column, 'value': RED | GREEN}  When all of the pixels for the time unit have been published, it then publishes a message to display the updated pixels:  \n{'command': 'output_display_buffer'}  The code adheres to  the standard Python Banyan patterns already covered in previous sections, and the code itself is\n well commented, so it needs no further discussion.",
            "title": "Component 1:  &nbsp;&nbsp;binary_clock.py"
        },
        {
            "location": "/#component-2-i2c_htk1633py",
            "text": "This component provide an abstraction for the HTK1633 16x8 LED i2c Controller Driver. For reference, the data sheet for the HTK1633 may be found  here .  This component utilizes the standard Python Banyan design patterns, but introduces the use of the i2c device \ndescriptor. This section will describe that descriptor and it usage.  \n        # i2c commands for the htk1633\n        # the values will be filled in by the methods for each command\n        self.i2c_device = {\n            \"htk1633\": {\n                \"commands\": {\n                    \"init\": [\n                        {\n                            u\"command\": u\"init\",\n                            u\"device_address\": self.device_address\n                        }\n                    ],\n                    \"set_oscillator_state\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.OSCILLATOR_OFF\n                        }\n                    ],\n\n                    \"set_blink_rate\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.HT16K33_BLINK_CMD\n                        }\n                    ],\n                    \"set_brightness\": [\n                        {\n                            u\"command\": u\"write_byte\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": self.HT16K33_BRIGHTNESS_CMD\n\n                        }\n                    ],\n                    \"write_pixel\": [\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": self.device_address,\n                            u\"value\": 0\n                        }\n                    ]\n                }\n            }\n        }  An i2c device descriptor, as shown for the HTK1633 above, describes the operations that may be performed on \nbehalf of the i2c device. Each operation is considered to be a macro command. A macro command contains one or more i2c \ncommunication messages that will implement the macro command.  A communication message is essentially an i2c read or write instruction with its optional parameters.  To understand how this works, let's look at the device initialization method:  \n    def initialize_i2c_device(self):\n            \"\"\"\n            This method establishes the i2c address of the device on the MCU.\n            :return:\n            \"\"\"\n            msg = self.i2c_device['htk1633']['commands']['init']\n            self.publish_payload(msg, self.publisher_topic)  A command execution method, such as initialize_i2c_device, dereferences the i2c device descriptor to retrieve \nthe message or messages\nthat will ultimately execute the command.  For the initialize command, the following payload is published with a topic of 'i2c_8x8_matrix':  {\n    u\"command\": u\"init\",\n    u\"device_address\": self.device_address\n}  In addition to the HTK1633 device, there are components provided that support the  PCF8591 Analog To Digital Converter  and the\n and \n  ADXL345 Accelerometer .  Each i2c device implements a unique Python Banyan component to support the device.  The ADXL345 component has an i2c device descriptor with an example of multiple i2c communication messages for its \ninit macro command. Here is the entire descriptor containing an init and a read macro command:  # this is python_banyan descriptor for the i2c commands to be sent to the i2c target device\n        self.i2c_device = {\n            \"adxl345\": {\n                \"commands\": {\n                    \"init\": [\n                        {\n                            u\"command\": u\"init\",\n                            u\"device_address\": device_address\n                        },\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 45,\n                            u\"value\": 0\n                        }, {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 45,\n                            u\"value\": 8\n                        }, {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 49,\n                            u\"value\": 8\n                        },\n                        {\n                            u\"command\": u\"write_byte_data\",\n                            u\"device_address\": device_address,\n                            u\"register\": 49,\n                            u\"value\": 3\n                        }\n                    ],\n                    \"read\": [{\n                        u\"command\": \"read_block\",\n                        u\"device_address\": device_address,\n                        u\"num_bytes\": 6,\n                        u\"register\": 50,\n                        u\"report\": True,\n                        u\"tag\": 0\n                    }]\n                }\n            }\n        }",
            "title": "Component 2:&nbsp;&nbsp; i2c_htk1633.py"
        },
        {
            "location": "/#component-3-i2c_pigpiopy",
            "text": "This component adheres to the Python Banyan patterns covered in the past.   There is a single instance of i2c_pigpio that receives all 'i2c' message from the device specific i2c components. This \ncomponent \ncommunicates directly with the i2c device via the SDA/SCL pins to perform i2c reads and writes.\nA read command can optionally return a value. The reason that this is optional is that sometimes a read is used to \nincrement an internal pointer within the device and not to retrieve a data value.",
            "title": "Component 3:  &nbsp;&nbsp;i2c_pigpio.py"
        },
        {
            "location": "/#running-the-bcd-clock-display",
            "text": "To run the BCD clock, make sure the clock components of chapter 1 are already running, and then run i2c_pigpio.py, \ni2c_htk1633.py and \nbinary_clock.py",
            "title": "Running The BCD Clock Display"
        },
        {
            "location": "/#chapter-4-installing-your-components-as-executable-modules",
            "text": "If you would like to install your Python Banyan components as executable modules that are found on the execution pah, \nyou may \nuse a feature of the  standard setup.py module . Full documentation for setup.py may be found\n  here.    You would first need to add you package to the packages list in setup.py. \nNext you need to make an entry into entry_points/console scripts section.  The format for this section is:  \"name_of_executable = module.with:function_to_execute\"  from setuptools import setup\n\nsetup(\n    name='python-banyan-examples',\n    version='1.0',\n    packages=[\n        'python_banyan.examples.clock',\n        'python_banyan.examples.digital_toggling',\n        'python_banyan.examples.launching',\n        'python_banyan.examples.matrix',\n        'python_banyan.examples.raspberry_redbot.i2c',\n        'python_banyan.examples.raspberry_redbot.i2c.validators',\n        'python_banyan.examples.raspberry_redbot.i2c.accelerometers',\n        'python_banyan.examples.raspberry_redbot.i2c.a2d',\n        'python_banyan.examples.raspberry_redbot.encoders.validators',\n        'python_banyan.examples.raspberry_redbot.led',\n        'python_banyan.examples.raspberry_redbot.led.validators',\n        'python_banyan.examples.raspberry_redbot.buzzer.validators',\n        'python_banyan.examples.raspberry_redbot.led.validators',\n        'python_banyan.examples.raspberry_redbot.buzzer',\n        'python_banyan.examples.raspberry_redbot.buzzer.validators',\n        'python_banyan.examples.raspberry_redbot.motors',\n        'python_banyan.examples.raspberry_redbot.motors.validators',\n        'python_banyan.examples.raspberry_redbot.encoders',\n        'python_banyan.examples.raspberry_redbot.switches',\n        'python_banyan.examples.raspberry_redbot.gui',\n        'python_banyan.examples.raspberry_redbot.i2c.led_matrix',\n    ],\n    install_requires=[\n        'python_banyan',\n        'pyzmq',\n        'u-msgpack-python',\n        'PyMata'\n    ],\n\n    package_data={'python_banyan.examples.launching': ['*.txt']},\n\n    entry_points={\n        'console_scripts': [\n            'clock_gui = python_banyan.examples.clock.clock_gui:clock_gui',\n            'tick_counter = python_banyan.examples.clock.tick_counter:tick_counter',\n            'tick_generator = python_banyan.examples.clock.tick_generator:tick_generator',\n            'binary_clock = python_banyan.examples.clock.binary_clock:binary_clock',\n\n            'rpi_digital_out=python_banyan.examples.digital_toggling.rpi_digital_out:rpi_digital_out',\n            'toggler=python_banyan.examples.digital_toggling.toggler:toggler',\n            'arduino_digital_out=python_banyan.examples.digital_toggling.arduino_digital_out:arduino_digital_out',\n\n            'lunch_config=python_banyan.examples.launching.lunch_config:lunch_config',\n\n            'i2c_htk1633 = python_banyan.examples.matrix.i2c_htk1633:i2c_htk1633',\n            'i2c_pigpio = python_banyan.examples.raspberry_redbot.i2c.i2c_pigpio:i2c_pigpio',\n\n            'buzzer_pigpio = python_banyan.examples.raspberry_redbot.buzzer.buzzer_pigpio:buzzer_pigpio',\n            'encoders_pigpio = python_banyan.examples.raspberry_redbot.encoders.encoders_pigpio:encoders_pigpio',\n            'i2c_pcf8591 = python_banyan.examples.raspberry_redbot.i2c.a2d.i2c_pcf8591:i2c_pcf8591',\n            'i2c_adxl345 = python_banyan.examples.raspberry_redbot.i2c.accelerometers.i2c_adxl345:i2c_adxl345',\n            'led = python_banyan.examples.raspberry_redbot.led.led:led',\n            'led_pigpio = python_banyan.examples.raspberry_redbot.led.led_pigpio:led_pigpio',\n            'motors = python_banyan.examples.raspberry_redbot.motors.motors:motors',\n            'motors_pigpio = python_banyan.examples.raspberry_redbot.motors.motors_pigpio:motors_pigpio',\n            'switches_gpio = python_banyan.examples.raspberry_redbot.switches.switches_pigpio:switches_pigpio',\n            'redbot = python_banyan.examples.raspberry_redbot.gui.redbot_controller:redbot_gui',\n\n\n        ]\n    },\n)  When you run pip or setup.py, your module will be placed on the executable path independent of operating system.",
            "title": "CHAPTER 4: &nbsp;INSTALLING YOUR COMPONENTS AS EXECUTABLE MODULES"
        },
        {
            "location": "/#software-required-by-python-banyan",
            "text": "The examples presented here were tested using Python 3.4.2 on a Raspberry Pi, Python 3.5.2 on Ubuntu Linux, and \nPython 3.6 on Windows. There are no known Python 3 dependencies in the Framework.  Python Banyan runs on Windows, Linux, and Mac, however you may need to install some additional software \nto your computer to meet the needs of Python Banyan. Here is a list of items that must available for Python Banyan to\n run:    Python 3 \n  The examples in this manual have been tested using Python 3.4.2, Python 3.5 and Python 3.6. \u00a0Python Banyan \nis not  inherently Python 3 specific so you are free to try it with Python 2 if you wish.    ZeroMQ \n  ZeroMQ is a networking library that is at the heart of Python Banyan. It acts as a non-blocking asynchronous \ntransport for Python Banyan applications. It also allows a Python Banyan application to distribute its components \nacross \nmultiple computers. The examples in this manual will demonstrate how to run an application on a single computer, and \nhow to take that same application and run its components on multiple computers. \n  In addition, ZeroMQ allows components written in languages other than Python to interact and become part your \napplication. An example of integrating a JavaScript component will be discussed. \n  Also, ZeroMQ helps form a Python Banyan \"backplane\". You may plug in or remove components of your application while \nthe other components are already running. This too will be demonstrated.    The Python Banyan Distribution \n  This includes Python Banyan's base class, used to create Python Banyan compatible applications, the Python Banyan \nbackplane, an executable Python module, and a utility module called the \"monitor\", that will allow you to view \ntraffic on the backplane.    Optional Packages    The Lunch Launcher \nThe Lunch launcher is not required, but provides a managed way to launch a Python Banyan application. Lunch is only \navailable for Linux systems. For Windows, a \nbatch script (.bat) can be created. For Mac a shell script can be created (.sh).    The  remi GUI Library \nThis package is not required, but is used in conjunction with the  Clock  demo described in this guide.",
            "title": "SOFTWARE REQUIRED BY PYTHON BANYAN"
        },
        {
            "location": "/python3_install/",
            "text": "Checking For Python 3\n\n\nTo check to see if you already have Python 3 installed on your computer, open a command window and type:\n\n\npython -V\n\n\n\n\nor \n\n\npython3 -V\n\n\n\n\nHere are the results from a Windows computer:\n\n\n\n\nThe results from a  Linux or Mac computer should look very similar.\n\n\nIf you have Python3 already installed, skip down to \nInstalling ZeroMQ.\n\n\nInstalling Python 3\n\n\nIf you need to install Python3 on your computer, I recommend using the latest version as of this writing, version 3.6.\nIf you have an earlier version already installed, upgrading to Python 3.6 is not necessary.\n\n\n\u00a0\u00a0\u00a0\u00a0Windows Users\n\n\nTo install Python 3.6 or later, go to the\n\nPython home page,\n \nand download the 3.6.0 (or later) distribution for your operating system.\n\n\nIf you have Python 2.7 installed, you do not need to remove it. \n\n\nDuring the installation process, if there is a checkbox to add Python 3.6 to your path, make sure it is checked before proceeding with the installation.\n\n\n\n\n\u00a0\u00a0\u00a0\u00a0Linux/Mac Users\n\n\nIf you are using linux, here are the build and installation instructions\n\n\n\n\nsudo apt-get update\n\n\nsudo apt-get upgrade\n\n\nsudo apt-get dist-upgrade\n\n\nsudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus\n\n\nsudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-dev\n\n\nsudo apt-get install zlib1g-dev libsqlite3-dev tk-dev\n\n\nsudo apt-get install libssl-dev openssl\n\n\ncd ~\n\n\nmkdir build\n\n\ncd build\n\n\nwget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz\n\n\ntar -zxvf Python-3.6.0.tgz\n\n\ncd Python-3.6.0\n\n\n./configure\n\n\nmake\n\n\nsudo make install\n\n\n\n\n\u00a0\u00a0\u00a0\u00a0Verify The Python Installation\n\n\nClick this link for instructions",
            "title": "Python 3 Installation"
        },
        {
            "location": "/python3_install/#checking-for-python-3",
            "text": "To check to see if you already have Python 3 installed on your computer, open a command window and type:  python -V  or   python3 -V  Here are the results from a Windows computer:   The results from a  Linux or Mac computer should look very similar.  If you have Python3 already installed, skip down to  Installing ZeroMQ.",
            "title": "Checking For Python 3"
        },
        {
            "location": "/python3_install/#installing-python-3",
            "text": "If you need to install Python3 on your computer, I recommend using the latest version as of this writing, version 3.6.\nIf you have an earlier version already installed, upgrading to Python 3.6 is not necessary.",
            "title": "Installing Python 3"
        },
        {
            "location": "/python3_install/#windows-users",
            "text": "To install Python 3.6 or later, go to the Python home page,  \nand download the 3.6.0 (or later) distribution for your operating system.  If you have Python 2.7 installed, you do not need to remove it.   During the installation process, if there is a checkbox to add Python 3.6 to your path, make sure it is checked before proceeding with the installation.",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Windows Users"
        },
        {
            "location": "/python3_install/#linuxmac-users",
            "text": "If you are using linux, here are the build and installation instructions   sudo apt-get update  sudo apt-get upgrade  sudo apt-get dist-upgrade  sudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus  sudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-dev  sudo apt-get install zlib1g-dev libsqlite3-dev tk-dev  sudo apt-get install libssl-dev openssl  cd ~  mkdir build  cd build  wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz  tar -zxvf Python-3.6.0.tgz  cd Python-3.6.0  ./configure  make  sudo make install",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Linux/Mac Users"
        },
        {
            "location": "/python3_install/#verify-the-python-installation",
            "text": "Click this link for instructions",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Verify The Python Installation"
        },
        {
            "location": "/zmq_install/",
            "text": "Checking For An Existing ZeroMQ Installation\n\n\nOpen a command window, and start Python3. \n\n\nThen at the Python prompt type:\n\n\nimport zmq\n\n\n\n\nIf you see no errors, you have ZeroMQ installed.\n\n\nIf ZeroMQ is not installed, follow the procedures for your platform.\n\n\n\n\n\u00a0\u00a0\u00a0\u00a0Windows Users\n\n\nAlthough you can build ZeroMQ from source, the easiest way to install is by using a provided MSI installer.\n\n\nI used \nthis link\n on Windows 10 64 Bit\n without issue. It installs both ZeroMQ and PyZMQ.\n\n\nIf you are running a 32 Bit machine, \ngo here\n and find latest \ncompatible MSI installer for your system.\n\n\nVerify the installation\n\n\n\u00a0\u00a0\u00a0\u00a0Linux Users\n\n\nHere are the steps necessary to build and install ZeroMQ on Ubuntu, BeagleBone Black and Raspberry Pi.\n\n\n\n\nsudo apt-get update\n\n\nsudo apt-get upgrade\n\n\nsudo apt-get install python3.5-dev  (not available for Raspberry Pi)\n\n\ncd\n\n\nsudo apt-get install libtool pkg-config build-essential autoconf automake\n\n\nmkdir build\n\n\ncd build/\n\n\nwget https://download.libsodium.org/libsodium/releases/libsodium-1.0.8.tar.gz\n\n\ntar -zxvf libsodium-1.0.8.tar.gz\n\n\ncd libsodium-1.0.8/\n\n\n./configure\n\n\nmake\n\n\nsudo make install\n\n\nsudo ldconfig\n\n\ncd ..\n\n\nwget http://download.zeromq.org/zeromq-4.1.4.tar.gz\n\n\ntar -zxvf zeromq-4.1.4.tar.gz\n\n\ncd zeromq-4.1.4/\n\n\n./configure\n\n\nmake\n\n\nsudo make install\n\n\nsudo ldconfig\n\n\nreboot\n\n\n\n\nVerify the installation\n\n\n\u00a0\u00a0\u00a0\u00a0Mac Users\n\n\nI do not own a Mac so I can't verify the following sources. But I have built from source for Linux on Ubuntu, \nBeagleBone Black and Raspberry Pi without issue.\n\n\n\n\nBuilding ZeroMQ from source code.\n \n\n\nThe Mac Store\n \n\n\n\n\nVerify the installation",
            "title": "ZeroMQ Installation"
        },
        {
            "location": "/zmq_install/#checking-for-an-existing-zeromq-installation",
            "text": "Open a command window, and start Python3.   Then at the Python prompt type:  import zmq  If you see no errors, you have ZeroMQ installed.  If ZeroMQ is not installed, follow the procedures for your platform.",
            "title": "Checking For An Existing ZeroMQ Installation"
        },
        {
            "location": "/zmq_install/#windows-users",
            "text": "Although you can build ZeroMQ from source, the easiest way to install is by using a provided MSI installer.  I used  this link  on Windows 10 64 Bit\n without issue. It installs both ZeroMQ and PyZMQ.  If you are running a 32 Bit machine,  go here  and find latest \ncompatible MSI installer for your system.  Verify the installation",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Windows Users"
        },
        {
            "location": "/zmq_install/#linux-users",
            "text": "Here are the steps necessary to build and install ZeroMQ on Ubuntu, BeagleBone Black and Raspberry Pi.   sudo apt-get update  sudo apt-get upgrade  sudo apt-get install python3.5-dev  (not available for Raspberry Pi)  cd  sudo apt-get install libtool pkg-config build-essential autoconf automake  mkdir build  cd build/  wget https://download.libsodium.org/libsodium/releases/libsodium-1.0.8.tar.gz  tar -zxvf libsodium-1.0.8.tar.gz  cd libsodium-1.0.8/  ./configure  make  sudo make install  sudo ldconfig  cd ..  wget http://download.zeromq.org/zeromq-4.1.4.tar.gz  tar -zxvf zeromq-4.1.4.tar.gz  cd zeromq-4.1.4/  ./configure  make  sudo make install  sudo ldconfig  reboot   Verify the installation",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Linux Users"
        },
        {
            "location": "/zmq_install/#mac-users",
            "text": "I do not own a Mac so I can't verify the following sources. But I have built from source for Linux on Ubuntu, \nBeagleBone Black and Raspberry Pi without issue.   Building ZeroMQ from source code.    The Mac Store     Verify the installation",
            "title": "&nbsp;&nbsp;&nbsp;&nbsp;Mac Users"
        },
        {
            "location": "/banyan_install/",
            "text": "Installing Python Banyan\n\n\nFrom a command window type:\n\n\npip install python-banyan\n\n\n\n\nor \n\n\npip3 install python-banyan\n\n\n\n\nThe command may need to be preceded with sudo. For example:\n\n\nsudo pip3 install python-banyan\n\n\n\n\nInstalling Python Banyan With All The Examples\n\n\npip install python-banyan[examples]\n\n\n\n\nor \n\n\npip3 install python-banyan[examples]\n\n\n\n\nThe command may need to be preceded with sudo. For example:\n\n\nsudo pip3 install python-banyan[examples]",
            "title": "Python Banyan Installation"
        },
        {
            "location": "/banyan_install/#installing-python-banyan",
            "text": "From a command window type:  pip install python-banyan  or   pip3 install python-banyan  The command may need to be preceded with sudo. For example:  sudo pip3 install python-banyan",
            "title": "Installing Python Banyan"
        },
        {
            "location": "/banyan_install/#installing-python-banyan-with-all-the-examples",
            "text": "pip install python-banyan[examples]  or   pip3 install python-banyan[examples]  The command may need to be preceded with sudo. For example:  sudo pip3 install python-banyan[examples]",
            "title": "Installing Python Banyan With All The Examples"
        },
        {
            "location": "/lunch_install/",
            "text": "To Install Lunch On Debian Based Linux Systems\n\n\nIn a command window type:\n\n\nsudo apt-get install lunch\n\n\n\n\nTo Install Lunch On Non-Debian Based Linux Systems\n\n\nFor non Debian based systems consult your package manager or visit the \nLunch Web Page",
            "title": "Lunch Launcher Installation"
        },
        {
            "location": "/lunch_install/#to-install-lunch-on-debian-based-linux-systems",
            "text": "In a command window type:  sudo apt-get install lunch",
            "title": "To Install Lunch On Debian Based Linux Systems"
        },
        {
            "location": "/lunch_install/#to-install-lunch-on-non-debian-based-linux-systems",
            "text": "For non Debian based systems consult your package manager or visit the  Lunch Web Page",
            "title": "To Install Lunch On Non-Debian Based Linux Systems"
        },
        {
            "location": "/remi_install/",
            "text": "Installing Remi\n\n\nRemi is a GUI library for Python applications which transpiles an application's interface into HTML to be rendered in a\nweb browser. This removes platform-specific dependencies and lets you easily develop cross-platform applications \nin Python!\n\n\nTo install, go to the\n\nGetting Started section\n \nfor remi on \n\nGithub\n \nand follow the installation instructions.",
            "title": "Remi GUI Library"
        },
        {
            "location": "/remi_install/#installing-remi",
            "text": "Remi is a GUI library for Python applications which transpiles an application's interface into HTML to be rendered in a\nweb browser. This removes platform-specific dependencies and lets you easily develop cross-platform applications \nin Python!  To install, go to the Getting Started section  \nfor remi on  Github  \nand follow the installation instructions.",
            "title": "Installing Remi"
        },
        {
            "location": "/about/",
            "text": "This document and associated software is Copyright (c) 2016-2017 Alan Yorinks All right reserved. \n\n\nIt is copyrighted under GPL 3.0 with the license shown below:\n\n\nGNU GENERAL PUBLIC LICENSE\n\n\nVersion 3, 29 June 2007\n\n\nCopyright (C) 2007 Free Software Foundation, Inc.\n\nhttp://fsf.org/\n\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nPreamble\n\n\nThe GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n\nThe licenses for most software and other practical works are designed\nto take away your freedom to share and change the works. By contrast,\nthe GNU General Public License is intended to guarantee your freedom\nto share and change all versions of a program--to make sure it remains\nfree software for all its users. We, the Free Software Foundation, use\nthe GNU General Public License for most of our software; it applies\nalso to any other work released this way by its authors. You can apply\nit to your programs, too.\n\n\nWhen we speak of free software, we are referring to freedom, not\nprice. Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n\nTo protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights. Therefore, you\nhave certain responsibilities if you distribute copies of the\nsoftware, or if you modify it: responsibilities to respect the freedom\nof others.\n\n\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received. You must make sure that they, too, receive\nor can get the source code. And you must show them these terms so they\nknow their rights.\n\n\nDevelopers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n\nFor the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software. For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n\nSome devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the\nmanufacturer can do so. This is fundamentally incompatible with the\naim of protecting users' freedom to change the software. The\nsystematic pattern of such abuse occurs in the area of products for\nindividuals to use, which is precisely where it is most unacceptable.\nTherefore, we have designed this version of the GPL to prohibit the\npractice for those products. If such problems arise substantially in\nother domains, we stand ready to extend this provision to those\ndomains in future versions of the GPL, as needed to protect the\nfreedom of users.\n\n\nFinally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish\nto avoid the special danger that patents applied to a free program\ncould make it effectively proprietary. To prevent this, the GPL\nassures that patents cannot be used to render the program non-free.\n\n\nThe precise terms and conditions for copying, distribution and\nmodification follow.\n\n\nTERMS AND CONDITIONS\n\n\n0. Definitions.\n\n\n\"This License\" refers to version 3 of the GNU General Public License.\n\n\n\"Copyright\" also means copyright-like laws that apply to other kinds\nof works, such as semiconductor masks.\n\n\n\"The Program\" refers to any copyrightable work licensed under this\nLicense. Each licensee is addressed as \"you\". \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n\nTo \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of\nan exact copy. The resulting work is called a \"modified version\" of\nthe earlier work or a work \"based on\" the earlier work.\n\n\nA \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n\nTo \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy. Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n\nTo \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies. Mere interaction with a user\nthrough a computer network, with no transfer of a copy, is not\nconveying.\n\n\nAn interactive user interface displays \"Appropriate Legal Notices\" to\nthe extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License. If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n\n1. Source Code.\n\n\nThe \"source code\" for a work means the preferred form of the work for\nmaking modifications to it. \"Object code\" means any non-source form of\na work.\n\n\nA \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n\nThe \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form. A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n\nThe \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities. However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work. For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n\nThe Corresponding Source need not include anything that users can\nregenerate automatically from other parts of the Corresponding Source.\n\n\nThe Corresponding Source for a work in source code form is that same\nwork.\n\n\n2. Basic Permissions.\n\n\nAll rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met. This License explicitly affirms your unlimited\npermission to run the unmodified Program. The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work. This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n\nYou may make, run and propagate covered works that you do not convey,\nwithout conditions so long as your license otherwise remains in force.\nYou may convey covered works to others for the sole purpose of having\nthem make modifications exclusively for you, or provide you with\nfacilities for running those works, provided that you comply with the\nterms of this License in conveying all material for which you do not\ncontrol copyright. Those thus making or running the covered works for\nyou must do so exclusively on your behalf, under your direction and\ncontrol, on terms that prohibit them from making any copies of your\ncopyrighted material outside their relationship with you.\n\n\nConveying under any other circumstances is permitted solely under the\nconditions stated below. Sublicensing is not allowed; section 10 makes\nit unnecessary.\n\n\n3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n\nNo covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n\nWhen you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such\ncircumvention is effected by exercising rights under this License with\nrespect to the covered work, and you disclaim any intention to limit\noperation or modification of the work as a means of enforcing, against\nthe work's users, your or third parties' legal rights to forbid\ncircumvention of technological measures.\n\n\n4. Conveying Verbatim Copies.\n\n\nYou may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n\nYou may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n\n5. Conveying Modified Source Versions.\n\n\nYou may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these\nconditions:\n\n\n\n\na) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n\nb) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under\n    section 7. This requirement modifies the requirement in section 4\n    to \"keep intact all notices\".\n\n\nc) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy. This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged. This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n\nd) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n\n\n\nA compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit. Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n\n6. Conveying Non-Source Forms.\n\n\nYou may convey a covered work in object code form under the terms of\nsections 4 and 5, provided that you also convey the machine-readable\nCorresponding Source under the terms of this License, in one of these\nways:\n\n\n\n\na) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n\nb) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the Corresponding\n    Source from a network server at no charge.\n\n\nc) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source. This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n\nd) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge. You need not require recipients to copy the\n    Corresponding Source along with the object code. If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source. Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n\ne) Convey the object code using peer-to-peer transmission,\n    provided you inform other peers where the object code and\n    Corresponding Source of the work are being offered to the general\n    public at no charge under subsection 6d.\n\n\n\n\nA separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n\nA \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal,\nfamily, or household purposes, or (2) anything designed or sold for\nincorporation into a dwelling. In determining whether a product is a\nconsumer product, doubtful cases shall be resolved in favor of\ncoverage. For a particular product received by a particular user,\n\"normally used\" refers to a typical or common use of that class of\nproduct, regardless of the status of the particular user or of the way\nin which the particular user actually uses, or expects or is expected\nto use, the product. A product is a consumer product regardless of\nwhether the product has substantial commercial, industrial or\nnon-consumer uses, unless such uses represent the only significant\nmode of use of the product.\n\n\n\"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to\ninstall and execute modified versions of a covered work in that User\nProduct from a modified version of its Corresponding Source. The\ninformation must suffice to ensure that the continued functioning of\nthe modified object code is in no case prevented or interfered with\nsolely because modification has been made.\n\n\nIf you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information. But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n\nThe requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or\nupdates for a work that has been modified or installed by the\nrecipient, or for the User Product in which it has been modified or\ninstalled. Access to a network may be denied when the modification\nitself materially and adversely affects the operation of the network\nor violates the rules and protocols for communication across the\nnetwork.\n\n\nCorresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n\n7. Additional Terms.\n\n\n\"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law. If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n\nWhen you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit. (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.) You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n\nNotwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders\nof that material) supplement the terms of this License with terms:\n\n\n\n\na) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n\nb) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n\nc) Prohibiting misrepresentation of the origin of that material,\n    or requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n\nd) Limiting the use for publicity purposes of names of licensors\n    or authors of the material; or\n\n\ne) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n\nf) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions\n    of it) with contractual assumptions of liability to the recipient,\n    for any liability that these contractual assumptions directly\n    impose on those licensors and authors.\n\n\n\n\nAll other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10. If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term. If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n\nIf you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n\nAdditional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions; the\nabove requirements apply either way.\n\n\n8. Termination.\n\n\nYou may not propagate or modify a covered work except as expressly\nprovided under this License. Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n\nHowever, if you cease all violation of this License, then your license\nfrom a particular copyright holder is reinstated (a) provisionally,\nunless and until the copyright holder explicitly and finally\nterminates your license, and (b) permanently, if the copyright holder\nfails to notify you of the violation by some reasonable means prior to\n60 days after the cessation.\n\n\nMoreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n\nTermination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License. If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n\n9. Acceptance Not Required for Having Copies.\n\n\nYou are not required to accept this License in order to receive or run\na copy of the Program. Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance. However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work. These actions infringe copyright if you do\nnot accept this License. Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n\n10. Automatic Licensing of Downstream Recipients.\n\n\nEach time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License. You are not responsible\nfor enforcing compliance by third parties with this License.\n\n\nAn \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations. If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n\nYou may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License. For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n\n11. Patents.\n\n\nA \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based. The\nwork thus licensed is called the contributor's \"contributor version\".\n\n\nA contributor's \"essential patent claims\" are all patent claims owned\nor controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version. For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n\nEach contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n\nIn the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement). To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n\nIf you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients. \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n\nIf, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n\nA patent license is \"discriminatory\" if it does not include within the\nscope of its coverage, prohibits the exercise of, or is conditioned on\nthe non-exercise of one or more of the rights that are specifically\ngranted under this License. You may not convey a covered work if you\nare a party to an arrangement with a third party that is in the\nbusiness of distributing software, under which you make payment to the\nthird party based on the extent of your activity of conveying the\nwork, and under which the third party grants, to any of the parties\nwho would receive the covered work from you, a discriminatory patent\nlicense (a) in connection with copies of the covered work conveyed by\nyou (or copies made from those copies), or (b) primarily for and in\nconnection with specific products or compilations that contain the\ncovered work, unless you entered into that arrangement, or that patent\nlicense was granted, prior to 28 March 2007.\n\n\nNothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n\n12. No Surrender of Others' Freedom.\n\n\nIf conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License. If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under\nthis License and any other pertinent obligations, then as a\nconsequence you may not convey it at all. For example, if you agree to\nterms that obligate you to collect a royalty for further conveying\nfrom those to whom you convey the Program, the only way you could\nsatisfy both those terms and this License would be to refrain entirely\nfrom conveying the Program.\n\n\n13. Use with the GNU Affero General Public License.\n\n\nNotwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work. The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n\n14. Revised Versions of this License.\n\n\nThe Free Software Foundation may publish revised and/or new versions\nof the GNU General Public License from time to time. Such new versions\nwill be similar in spirit to the present version, but may differ in\ndetail to address new problems or concerns.\n\n\nEach version is given a distinguishing version number. If the Program\nspecifies that a certain numbered version of the GNU General Public\nLicense \"or any later version\" applies to it, you have the option of\nfollowing the terms and conditions either of that numbered version or\nof any later version published by the Free Software Foundation. If the\nProgram does not specify a version number of the GNU General Public\nLicense, you may choose any version ever published by the Free\nSoftware Foundation.\n\n\nIf the Program specifies that a proxy can decide which future versions\nof the GNU General Public License can be used, that proxy's public\nstatement of acceptance of a version permanently authorizes you to\nchoose that version for the Program.\n\n\nLater license versions may give you additional or different\npermissions. However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n\n15. Disclaimer of Warranty.\n\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT\nWARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND\nPERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE\nDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR\nCORRECTION.\n\n\n16. Limitation of Liability.\n\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR\nCONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES\nARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT\nNOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR\nLOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM\nTO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER\nPARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n\n17. Interpretation of Sections 15 and 16.\n\n\nIf the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n\nEND OF TERMS AND CONDITIONS\n\n\nHow to Apply These Terms to Your New Programs\n\n\nIf you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these\nterms.\n\n\nTo do so, attach the following notices to the program. It is safest to\nattach them to the start of each source file to most effectively state\nthe exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\nAlso add information on how to contact you by electronic and paper\nmail.\n\n\nIf the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\n\n\nThe hypothetical commands `show w' and `show c' should show the\nappropriate parts of the General Public License. Of course, your\nprogram's commands might be different; for a GUI interface, you would\nuse an \"about box\".\n\n\nYou should also get your employer (if you work as a programmer) or\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary. For more information on this, and how to apply and follow\nthe GNU GPL, see \nhttp://www.gnu.org/licenses/\n.\n\n\nThe GNU General Public License does not permit incorporating your\nprogram into proprietary programs. If your program is a subroutine\nlibrary, you may consider it more useful to permit linking proprietary\napplications with the library. If this is what you want to do, use the\nGNU Lesser General Public License instead of this License. But first,\nplease read \nhttp://www.gnu.org/philosophy/why-not-lgpl.html\n.",
            "title": "About"
        },
        {
            "location": "/about/#gnu-general-public-license",
            "text": "Version 3, 29 June 2007  Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/  Everyone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.",
            "title": "GNU GENERAL PUBLIC LICENSE"
        },
        {
            "location": "/about/#preamble",
            "text": "The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works. By contrast,\nthe GNU General Public License is intended to guarantee your freedom\nto share and change all versions of a program--to make sure it remains\nfree software for all its users. We, the Free Software Foundation, use\nthe GNU General Public License for most of our software; it applies\nalso to any other work released this way by its authors. You can apply\nit to your programs, too.  When we speak of free software, we are referring to freedom, not\nprice. Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights. Therefore, you\nhave certain responsibilities if you distribute copies of the\nsoftware, or if you modify it: responsibilities to respect the freedom\nof others.  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received. You must make sure that they, too, receive\nor can get the source code. And you must show them these terms so they\nknow their rights.  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software. For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the\nmanufacturer can do so. This is fundamentally incompatible with the\naim of protecting users' freedom to change the software. The\nsystematic pattern of such abuse occurs in the area of products for\nindividuals to use, which is precisely where it is most unacceptable.\nTherefore, we have designed this version of the GPL to prohibit the\npractice for those products. If such problems arise substantially in\nother domains, we stand ready to extend this provision to those\ndomains in future versions of the GPL, as needed to protect the\nfreedom of users.  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish\nto avoid the special danger that patents applied to a free program\ncould make it effectively proprietary. To prevent this, the GPL\nassures that patents cannot be used to render the program non-free.  The precise terms and conditions for copying, distribution and\nmodification follow.",
            "title": "Preamble"
        },
        {
            "location": "/about/#terms-and-conditions",
            "text": "",
            "title": "TERMS AND CONDITIONS"
        },
        {
            "location": "/about/#0-definitions",
            "text": "\"This License\" refers to version 3 of the GNU General Public License.  \"Copyright\" also means copyright-like laws that apply to other kinds\nof works, such as semiconductor masks.  \"The Program\" refers to any copyrightable work licensed under this\nLicense. Each licensee is addressed as \"you\". \"Licensees\" and\n\"recipients\" may be individuals or organizations.  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of\nan exact copy. The resulting work is called a \"modified version\" of\nthe earlier work or a work \"based on\" the earlier work.  A \"covered work\" means either the unmodified Program or a work based\non the Program.  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy. Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies. Mere interaction with a user\nthrough a computer network, with no transfer of a copy, is not\nconveying.  An interactive user interface displays \"Appropriate Legal Notices\" to\nthe extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License. If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.",
            "title": "0. Definitions."
        },
        {
            "location": "/about/#1-source-code",
            "text": "The \"source code\" for a work means the preferred form of the work for\nmaking modifications to it. \"Object code\" means any non-source form of\na work.  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form. A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities. However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work. For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.  The Corresponding Source need not include anything that users can\nregenerate automatically from other parts of the Corresponding Source.  The Corresponding Source for a work in source code form is that same\nwork.",
            "title": "1. Source Code."
        },
        {
            "location": "/about/#2-basic-permissions",
            "text": "All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met. This License explicitly affirms your unlimited\npermission to run the unmodified Program. The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work. This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.  You may make, run and propagate covered works that you do not convey,\nwithout conditions so long as your license otherwise remains in force.\nYou may convey covered works to others for the sole purpose of having\nthem make modifications exclusively for you, or provide you with\nfacilities for running those works, provided that you comply with the\nterms of this License in conveying all material for which you do not\ncontrol copyright. Those thus making or running the covered works for\nyou must do so exclusively on your behalf, under your direction and\ncontrol, on terms that prohibit them from making any copies of your\ncopyrighted material outside their relationship with you.  Conveying under any other circumstances is permitted solely under the\nconditions stated below. Sublicensing is not allowed; section 10 makes\nit unnecessary.",
            "title": "2. Basic Permissions."
        },
        {
            "location": "/about/#3-protecting-users-legal-rights-from-anti-circumvention-law",
            "text": "No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such\ncircumvention is effected by exercising rights under this License with\nrespect to the covered work, and you disclaim any intention to limit\noperation or modification of the work as a means of enforcing, against\nthe work's users, your or third parties' legal rights to forbid\ncircumvention of technological measures.",
            "title": "3. Protecting Users' Legal Rights From Anti-Circumvention Law."
        },
        {
            "location": "/about/#4-conveying-verbatim-copies",
            "text": "You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.",
            "title": "4. Conveying Verbatim Copies."
        },
        {
            "location": "/about/#5-conveying-modified-source-versions",
            "text": "You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these\nconditions:   a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.  b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under\n    section 7. This requirement modifies the requirement in section 4\n    to \"keep intact all notices\".  c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy. This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged. This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.  d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.   A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit. Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.",
            "title": "5. Conveying Modified Source Versions."
        },
        {
            "location": "/about/#6-conveying-non-source-forms",
            "text": "You may convey a covered work in object code form under the terms of\nsections 4 and 5, provided that you also convey the machine-readable\nCorresponding Source under the terms of this License, in one of these\nways:   a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.  b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the Corresponding\n    Source from a network server at no charge.  c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source. This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.  d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge. You need not require recipients to copy the\n    Corresponding Source along with the object code. If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source. Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.  e) Convey the object code using peer-to-peer transmission,\n    provided you inform other peers where the object code and\n    Corresponding Source of the work are being offered to the general\n    public at no charge under subsection 6d.   A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal,\nfamily, or household purposes, or (2) anything designed or sold for\nincorporation into a dwelling. In determining whether a product is a\nconsumer product, doubtful cases shall be resolved in favor of\ncoverage. For a particular product received by a particular user,\n\"normally used\" refers to a typical or common use of that class of\nproduct, regardless of the status of the particular user or of the way\nin which the particular user actually uses, or expects or is expected\nto use, the product. A product is a consumer product regardless of\nwhether the product has substantial commercial, industrial or\nnon-consumer uses, unless such uses represent the only significant\nmode of use of the product.  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to\ninstall and execute modified versions of a covered work in that User\nProduct from a modified version of its Corresponding Source. The\ninformation must suffice to ensure that the continued functioning of\nthe modified object code is in no case prevented or interfered with\nsolely because modification has been made.  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information. But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or\nupdates for a work that has been modified or installed by the\nrecipient, or for the User Product in which it has been modified or\ninstalled. Access to a network may be denied when the modification\nitself materially and adversely affects the operation of the network\nor violates the rules and protocols for communication across the\nnetwork.  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.",
            "title": "6. Conveying Non-Source Forms."
        },
        {
            "location": "/about/#7-additional-terms",
            "text": "\"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law. If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit. (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.) You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders\nof that material) supplement the terms of this License with terms:   a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or  b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or  c) Prohibiting misrepresentation of the origin of that material,\n    or requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or  d) Limiting the use for publicity purposes of names of licensors\n    or authors of the material; or  e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or  f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions\n    of it) with contractual assumptions of liability to the recipient,\n    for any liability that these contractual assumptions directly\n    impose on those licensors and authors.   All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10. If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term. If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions; the\nabove requirements apply either way.",
            "title": "7. Additional Terms."
        },
        {
            "location": "/about/#8-termination",
            "text": "You may not propagate or modify a covered work except as expressly\nprovided under this License. Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).  However, if you cease all violation of this License, then your license\nfrom a particular copyright holder is reinstated (a) provisionally,\nunless and until the copyright holder explicitly and finally\nterminates your license, and (b) permanently, if the copyright holder\nfails to notify you of the violation by some reasonable means prior to\n60 days after the cessation.  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License. If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.",
            "title": "8. Termination."
        },
        {
            "location": "/about/#9-acceptance-not-required-for-having-copies",
            "text": "You are not required to accept this License in order to receive or run\na copy of the Program. Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance. However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work. These actions infringe copyright if you do\nnot accept this License. Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.",
            "title": "9. Acceptance Not Required for Having Copies."
        },
        {
            "location": "/about/#10-automatic-licensing-of-downstream-recipients",
            "text": "Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License. You are not responsible\nfor enforcing compliance by third parties with this License.  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations. If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License. For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.",
            "title": "10. Automatic Licensing of Downstream Recipients."
        },
        {
            "location": "/about/#11-patents",
            "text": "A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based. The\nwork thus licensed is called the contributor's \"contributor version\".  A contributor's \"essential patent claims\" are all patent claims owned\nor controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version. For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement). To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients. \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.  A patent license is \"discriminatory\" if it does not include within the\nscope of its coverage, prohibits the exercise of, or is conditioned on\nthe non-exercise of one or more of the rights that are specifically\ngranted under this License. You may not convey a covered work if you\nare a party to an arrangement with a third party that is in the\nbusiness of distributing software, under which you make payment to the\nthird party based on the extent of your activity of conveying the\nwork, and under which the third party grants, to any of the parties\nwho would receive the covered work from you, a discriminatory patent\nlicense (a) in connection with copies of the covered work conveyed by\nyou (or copies made from those copies), or (b) primarily for and in\nconnection with specific products or compilations that contain the\ncovered work, unless you entered into that arrangement, or that patent\nlicense was granted, prior to 28 March 2007.  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.",
            "title": "11. Patents."
        },
        {
            "location": "/about/#12-no-surrender-of-others-freedom",
            "text": "If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License. If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under\nthis License and any other pertinent obligations, then as a\nconsequence you may not convey it at all. For example, if you agree to\nterms that obligate you to collect a royalty for further conveying\nfrom those to whom you convey the Program, the only way you could\nsatisfy both those terms and this License would be to refrain entirely\nfrom conveying the Program.",
            "title": "12. No Surrender of Others' Freedom."
        },
        {
            "location": "/about/#13-use-with-the-gnu-affero-general-public-license",
            "text": "Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work. The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.",
            "title": "13. Use with the GNU Affero General Public License."
        },
        {
            "location": "/about/#14-revised-versions-of-this-license",
            "text": "The Free Software Foundation may publish revised and/or new versions\nof the GNU General Public License from time to time. Such new versions\nwill be similar in spirit to the present version, but may differ in\ndetail to address new problems or concerns.  Each version is given a distinguishing version number. If the Program\nspecifies that a certain numbered version of the GNU General Public\nLicense \"or any later version\" applies to it, you have the option of\nfollowing the terms and conditions either of that numbered version or\nof any later version published by the Free Software Foundation. If the\nProgram does not specify a version number of the GNU General Public\nLicense, you may choose any version ever published by the Free\nSoftware Foundation.  If the Program specifies that a proxy can decide which future versions\nof the GNU General Public License can be used, that proxy's public\nstatement of acceptance of a version permanently authorizes you to\nchoose that version for the Program.  Later license versions may give you additional or different\npermissions. However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.",
            "title": "14. Revised Versions of this License."
        },
        {
            "location": "/about/#15-disclaimer-of-warranty",
            "text": "THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT\nWARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND\nPERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE\nDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR\nCORRECTION.",
            "title": "15. Disclaimer of Warranty."
        },
        {
            "location": "/about/#16-limitation-of-liability",
            "text": "IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR\nCONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES\nARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT\nNOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR\nLOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM\nTO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER\nPARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.",
            "title": "16. Limitation of Liability."
        },
        {
            "location": "/about/#17-interpretation-of-sections-15-and-16",
            "text": "If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.  END OF TERMS AND CONDITIONS",
            "title": "17. Interpretation of Sections 15 and 16."
        },
        {
            "location": "/about/#how-to-apply-these-terms-to-your-new-programs",
            "text": "If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these\nterms.  To do so, attach the following notices to the program. It is safest to\nattach them to the start of each source file to most effectively state\nthe exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.      <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  Also add information on how to contact you by electronic and paper\nmail.  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:      <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.  The hypothetical commands `show w' and `show c' should show the\nappropriate parts of the General Public License. Of course, your\nprogram's commands might be different; for a GUI interface, you would\nuse an \"about box\".  You should also get your employer (if you work as a programmer) or\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary. For more information on this, and how to apply and follow\nthe GNU GPL, see  http://www.gnu.org/licenses/ .  The GNU General Public License does not permit incorporating your\nprogram into proprietary programs. If your program is a subroutine\nlibrary, you may consider it more useful to permit linking proprietary\napplications with the library. If this is what you want to do, use the\nGNU Lesser General Public License instead of this License. But first,\nplease read  http://www.gnu.org/philosophy/why-not-lgpl.html .",
            "title": "How to Apply These Terms to Your New Programs"
        }
    ]
}